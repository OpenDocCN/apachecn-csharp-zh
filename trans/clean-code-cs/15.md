# 十五、答案

# 第一章

1.  糟糕代码的一个结果是，您可能最终得到一段写得非常糟糕、难以理解的代码。这通常会导致程序员压力和软件缺陷，难以维护，难以测试和扩展。
2.  好代码的一个结果是易于阅读和理解，因为您知道程序员的意图。这使得那些必须调试、测试和扩展代码的程序员压力更小。
3.  当您将一个大型项目分解为模块化组件和库时，每个模块都可以由单独的团队同时处理。小模块易于测试、编码、编写文档、部署、扩展和维护。
4.  **DRY**代表**不要重复自己**。寻找可重复的代码，并对其进行重构，以便删除重复的代码。这样做的好处是程序更小，因为如果这样的代码包含 bug，您只需在一个地方进行更改。
5.  KISS 意味着不会让程序员感到困惑的简单代码，特别是当您的团队中有年轻人时。KISS 代码易于阅读和编写测试。
6.  **S**为**单一责任原则**、**O**为**开/关原则**、**L**为**利斯科夫替代**、**I**为**接口隔离原则**、【T16 D 为**依赖倒置原则**。
7.  **雅格尼**是**的缩写，您不需要它**。换句话说，不要添加不需要的代码。只添加你绝对需要的代码，不要再添加了。
8.  奥卡姆剃刀的原理是：*实体在没有必要的情况下不能被倍增。**只在事实上交易。仅在绝对必要的情况下进行假设*。

# 第二章

1.  同行代码评审中的两个角色是审阅者和被审阅者。
2.  项目经理同意参与同行代码评审的人员。

3.  在请求同行代码审查之前，您可以通过确保您的代码和测试所有工作、您对项目执行代码分析并修复提出的任何问题，以及您的代码遵守公司的编码准则来节省审查人员的时间和精力。
4.  在检查代码时，请注意命名、格式、编程风格、潜在错误、代码和测试的正确性、安全性和性能问题。
5.  这三类反馈是积极的、可选的和关键的。

# 第三章

1.  我们可以将代码放在文件夹结构中的单个源文件中，并将类、接口、结构和枚举包装到映射到文件夹结构的命名空间中。
2.  一个类应该只有一个职责。
3.  您可以使用直接放在要记录的公共成员上方的 XML 注释在代码中为文档生成器添加注释。
4.  内聚是在同一职责上工作的代码的逻辑分组。
5.  耦合是指类之间的依赖关系。
6.  凝聚力应该很高。
7.  联轴器应低。
8.  您可以使用 DI 和 IoC 为变更进行设计。
9.  **DI**代表**依赖注入**。
10.  **IoC**代表**控制反转**。
11.  不可变对象是类型安全的，因此可以在线程之间安全地传递。
12.  对象应该公开方法和属性并隐藏数据。
13.  数据结构应该公开数据并且没有方法。

# 第四章

1.  没有参数的方法称为 niladic 方法。
2.  只有一个参数的方法称为一元方法。
3.  具有两个参数的方法称为并矢方法。
4.  具有三个参数的方法称为三参数方法。

5.  具有三个以上参数的方法称为多元方法。
6.  您应该避免重复代码。它不是一种高效的编程方式，会使程序变得不必要的大，并且有可能在整个代码库中传播相同的异常。
7.  函数式编程是一种软件编码方法，它将计算视为不修改状态的计算的数学评估。
8.  函数式编程的优点包括多线程应用中的安全代码，以及易于阅读和理解的更小、更有意义的方法。
9.  输入和输出可能是功能程序的问题，因为它依赖于副作用。功能性编程不考虑副作用。
10.  湿代码与干代码相反，因为每次需要时都会编写代码。这会产生重复，并且相同的异常可能发生在程序中的多个位置，从而使维护和支持更加困难。
11.  干代码与湿代码相反，因为代码只编写一次，并且可以在需要时重用。这减少了代码库和异常占用，从而使程序更易于阅读和维护。
12.  通过使用重构删除重复的代码，可以使湿代码变干。
13.  长方法很麻烦，而且容易出现异常。它们越小，越容易阅读和维护。程序员引入 bug 的机会也较少，尤其是逻辑性 bug。
14.  为了避免使用 try/catch 块，您可以编写参数验证器。然后调用方法顶部的验证器。如果参数验证失败，则抛出相应的异常，并且不执行该方法。

# 第五章

1.  已检查异常是在编译时检查的异常。
2.  未检查的异常是在编译时未检查或忽略的异常。
3.  当无法将高阶位分配给目标类型时，将引发溢出异常。在检查模式下，`OverflowException`升起。在未检查模式下，无法分配的高阶位将被忽略。
4.  试图访问空对象上的属性或方法的尝试。

5.  实现一个`Validator`类和一个`Attribute`类，该类检查参数是否为 null，并抛出`ArgumentNullException`。您可以在方法的顶部使用`Validator`类，这样在引发异常之前，您就不会中途完成方法。
6.  **业务规则例外**（**BRE**）。
7.  BRE 是一种不好的做法，因为它们期望引发异常以控制程序流。
8.  正确的编程不应该通过期望异常作为输出来控制计算机程序的流程。所以，考虑到 BRE 是坏的，因为它们期望异常的输出并使用它来控制程序流，更好的解决方案是使用条件编程。对于条件程序，使用布尔逻辑。布尔逻辑允许两种可能的执行路径，并且从不引发异常。条件检查是显式的，使程序更易于阅读和维护。您还可以轻松地扩展此类代码，而使用 BRE 则无法。
9.  首先，使用 Microsoft.NET Framework 中的已知异常类型，从错误捕获已知类型的异常开始，例如`ArgumentNullExceptions`和`OverflowExceptions`。但是，当这些数据不足，并且不能为您的特定情况提供足够的数据时，您将编写并使用自己的自定义异常，并应用有意义的异常消息。
10.  自定义异常必须继承自`System.Exception`，并实现三个构造函数：默认构造函数、接受文本消息的构造函数以及接受文本消息和内部异常的构造函数。

# 第六章

1.  一个好的单元测试必须是原子的、确定性的、可重复的和快速的。
2.  一个好的单元测试不能是无结论的。
3.  测试驱动开发。
4.  行为驱动的发展。
5.  一个小的代码单元，其唯一目的是测试只做一件事的单个代码单元。
6.  单元测试使用的假对象，用于测试真实对象的公共方法和属性，但不测试方法或属性依赖关系。
7.  伪对象与模拟对象相同。
8.  MSTest、NUnit 和 xUnit。

9.  犀牛模仿和 Moq。
10.  SpecFlow。
11.  不必要的注释、死代码和冗余测试。

# 第七章

1.  对一个完整系统进行端到端的测试。这可以手动、自动或使用这两种方法来执行。
2.  集成测试。
3.  所有功能的手动测试，所有单元测试都应该通过，我们应该编写自动化测试来测试在两个模块之间传递的命令和数据。
4.  工厂是实现工厂方法模式的类，其目的是允许在不指定其类的情况下创建对象。我们将在以下场景中使用它们：
    1.  该类无法预测必须实例化的对象类型。
    2.  子类必须指定要实例化的对象的类型。
    3.  该类控制其对象的实例化。
5.  DI 是一种生成易于维护和扩展的松散耦合代码的方法。
6.  使用容器可以轻松管理依赖项对象。

# 第八章

1.  线程是一个进程。
2.  一
3.  背景线程和前景线程。
4.  背景线程。
5.  前景线程。
6.  `Thread.Sleep(500);`
7.  `var thread = new Thread(Method1);`

8.  将`IsBackground`设置为`true`。
9.  死锁是两个线程被阻塞并等待另一个线程释放资源的情况。
10.  `Monitor.Exit(objectName);`
11.  使用相同资源的多个线程根据每个线程的计时生成不同的输出。
12.  使用带`ContinueWith()`的 TPL，使用`Wait()`等待任务完成后退出方法。
13.  使用其他方法共享的成员变量，并传入引用变量。
14.  对
15.  线程池。
16.  它是一个一旦构建就无法修改的对象。
17.  它们允许您在线程之间安全地共享数据。

# 第九章

1.  应用编程接口。
2.  代表性状态转移。
3.  统一接口，客户端-服务器，无状态，可缓存，分层系统，可选可执行代码。
4.  **作为应用状态**（**HATEOAS**的引擎的超媒体。
5.  RapidApi.com。
6.  授权和认证。
7.  声明是实体对自身做出的声明。然后根据数据存储验证这些声明。它们在基于角色的安全性中特别有用，用于检查提出声明的实体是否已就该声明获得授权。
8.  提出 API 请求并检查其响应。
9.  因为您可以根据需要更改数据存储。

# 第十章

1.  将软件正确划分为逻辑名称空间、接口和类，这有助于软件测试。
2.  通过理解 API，您可以亲吻您的代码，并通过不重新发明轮子和编写已经存在的代码来保持其干燥。这节省了时间、精力和金钱。
3.  结构。
4.  第三方 API 是由软件开发人员编写的，因此会受到人为错误的影响，从而导致错误。通过测试第三方 API，您可以确信它们能按预期工作，如果不能，则可以修复代码或为其编写包装器。
5.  您的 API 容易出错。通过按照规范及其验收标准对其进行测试，您可以确保以约定的质量级别交付业务所需的内容，并准备公开发布。
6.  规范和验收标准提供了正常的程序流程。从它们中，您可以确定要针对正常的执行流测试什么，还可以确定将遇到什么异常情况并为它们进行测试。
7.  名称空间、接口和类。

# 第十一章

1.  交叉关注点是那些不是构成核心关注点的业务需求的一部分，但必须在代码的所有领域中解决的关注点。**AOP**代表**面向方面编程**。
2.  方面是一个属性，当应用于类、方法、属性或参数时，它会在编译时注入代码。在应用方面的项之前，应用方括号中的方面。
3.  属性赋予项目语义。在应用属性的项之前，应用方括号中的属性。
4.  属性赋予代码语义，而方面删除样板代码，以便在编译时注入。
5.  构建代码时，编译器将插入方面对程序员隐藏的样板代码。这个过程称为代码编织。

# 第十二章

1.  代码度量是一些源代码度量，它们使我们能够识别软件有多复杂，以及软件的可维护性有多强。这样的度量使我们能够识别代码中可以通过重构降低复杂性和提高可维护性的区域。
2.  圈复杂度、可维护性指数、继承深度、类耦合、源代码行和可执行代码行。
3.  代码分析是对源代码的静态分析，旨在识别设计缺陷、全球化问题、安全问题、性能问题和互操作性问题。
4.  快速操作是由螺丝刀或灯泡标识的单个命令，它将抑制警告、添加 using 语句、导入缺少的库和添加 using 语句、纠正错误并实现语言使用改进，以简化代码和减少方法中的行数。
5.  JetBrains 的 dotTrace 实用程序是一种分析工具，用于分析源代码和已编译程序集，以识别软件的潜在问题。使用它，您可以执行采样、跟踪、逐行分析和时间轴分析。您可以分析执行时间、线程时间、实时 CPU 指令和线程周期时间。
6.  JetBrains 的 ReSharper 实用程序是一种代码重构工具，可帮助开发人员识别和修复代码问题，并实现语言功能，以改善和加快程序员的编程体验。
7.  源代码的反编译可用于检索丢失的源代码、生成用于调试和学习的 PDB。您还可以使用反编译器来查看您对代码的模糊程度，从而使黑客和其他人难以窃取您的代码机密。

# 第十三章

1.  应用级、类级和方法级。
2.  布尔盲症、组合爆炸、人为复杂性、数据块、除臭剂注释、重复代码、失去意图、变量突变、奇怪的解决方案、散弹枪手术、解决方案蔓延和不可控的副作用。

3.  圈复杂度、发散变化、降级、过度文字使用、特征嫉妒、不恰当的亲密关系、不雅的暴露、大类（也称为上帝对象）、懒惰类（也称为免费装载者和懒惰对象）、中间人类、变量和常量的孤儿类、原始痴迷、拒绝遗产、，好吧，说吧，别问了！，临时场。
4.  害群之马、圈复杂度、人为复杂度、死代码、数据返回过多、功能嫉妒、标识符大小、不恰当的亲密关系、长线又称神线、懒惰方法、长方法（神法）、长参数列表（参数太多）、消息链、中间人方法、古怪的解决方案和推测性通用性。
5.  使用 LINQ 而不是循环。让类只负责一件事。让方法只做一件事。用参数对象替换长参数列表。使用创造性设计模式来提高昂贵对象的创建和利用效率。将方法保持在 10 行或更少。使用 AOP 从方法中删除样板代码。分离对象并使其可测试。使代码高度内聚。
6.  表示分支和循环数量的值。
7.  减少发生的分支和循环的数量，直到圈复杂度值变为 10 或更少。
8.  使事情变得比需要的更复杂。
9.  **保持简单，愚蠢**（**亲吻**。
10.  同样的事情是通过不同的方法和不同的参数组合来完成的。
11.  创建可以对不同数据类型执行相同任务的通用方法，以便只有一个方法和一组参数。
12.  修复错误代码并删除注释。
13.  请求帮助。
14.  堆栈溢出。
15.  长参数列表可以替换为参数对象。
16.  将其重构为只做一件事的较小方法，并使用 AOP 将样板代码删除为方面。
17.  不超过 10 行。
18.  0-10; 除此之外的任何事情，你都是在自找麻烦。
19.  一
20.  未使用的变量、类、属性和方法。摆脱他们。
21.  选择最佳的实现方法，然后重构代码以仅使用该实现方法。

22.  将临时字段及其操作方法重构为它们自己的类。
23.  不同类中使用的同一组变量。将变量重构为它们自己的类，然后引用该类。
24.  类继承自另一个类，但不使用其所有方法。
25.  得墨忒尔定律。
26.  只允许班级与他们的近邻交谈。
27.  在另一个类或方法中花费太多时间的类或方法。
28.  重构它们自己的类或方法中的依赖项。
29.  工厂法。
30.  从基类继承，然后创建从基类继承的新类。
31.  单一责任是在应用的不同层的不同类的不同方法中实现的。将职责重构到自己的类中，使其仅位于单个位置。
32.  数据应放在对其进行操作的同一对象中。
33.  当您创建一个向另一个对象请求数据以使其可以对其执行操作的对象时。
34.  单个更改需要在多个位置进行更改。消除重复，消除耦合，提高内聚性。
35.  丢失意图是指类或方法的原因不清楚，因为有许多不相关的项聚集在一起。重构代码，使所有方法都位于正确的类中。这样，类和方法的意图就变得清晰了。
36.  您可以使用 LINQ 查询重构循环。LINQ 是一种函数式语言，它不改变位置变量，而且执行速度比循环快得多。

# 第十四章

1.  **GoF**是**四人帮**模式的缩写。这是 23 种模式，分为创意、结构和行为设计模式。它们被认为是所有软件设计模式的基础。它们一起工作以生成干净的面向对象代码。
2.  创建模式支持抽象和继承，以提供一种面向对象的方法，在对象创建成本较高时消除代码重复并提高性能。创建模式包括抽象工厂、工厂方法、单例、原型和构建器。

3.  结构模式可以正确管理对象之间的关系。我们可以使用结构模式使不兼容的接口能够协同工作，将抽象与其实现分离，并提高性能。结构模式包括适配器、桥接器、复合材料、装饰器、立面、flyweight 和代理。
4.  行为模式控制对象之间的交互和通信方式。我们可以使用它们来生成管道、封装将来要执行的命令和信息、在对象之间进行调解、观察对象中的状态变化等等。行为模式包括责任链、命令、解释器、迭代器、中介、记忆、观察者、状态、策略、模板方法和访问者。
5.  对
6.  在应用的整个生命周期中，singleton 只允许对象的单个实例。所有需要该对象的对象都可以全局访问该对象。当我们需要确保有一个集中的对象创建和对象访问点时，我们使用这种模式。
7.  当需要创建对象而不指定要实例化的确切类时，我们使用工厂方法。
8.  正面。
9.  使用 flyweight 设计图案。
10.  桥
11.  使用生成器模式。
12.  您可以使用责任链模式，因为您可以有一个处理程序管道，每个处理程序执行一项任务。如果处理程序无法处理该任务，则会将该任务传递给后续处理程序进行处理。