# 二十三、答案

# 第一章

1.  软件架构师需要了解任何可以帮助他们更快地解决问题并确保他们能够创建质量更好的软件的技术。
2.  Azure 提供了许多软件架构师可以在解决方案中实现的组件，并不断改进。
3.  最佳的软件开发过程模型取决于您拥有的项目、团队和预算的类型。作为软件架构师，您需要考虑所有这些变量，理解不同的过程模型，以便您能够适应环境的需要。
4.  软件架构师关注可能影响性能、安全性、可用性等的任何用户或系统需求。
5.  所有这些，但非功能性需求需要给予更多的关注。
6.  设计思维和设计冲刺是帮助软件架构师准确定义用户需求的工具。
7.  当我们想要定义功能需求时，用户故事是好的。它们可以快速编写，通常不仅提供所需的功能，还提供解决方案的验收标准。
8.  缓存、异步编程和正确的对象分配。
9.  为了检查实现是否正确，软件架构师将其与已经设计和验证的模型和原型进行比较。

# 第二章

1.  垂直和水平。
2.  是的，您可以自动部署到已定义的 web 应用，或者直接使用 Visual Studio 创建新的 web 应用。
3.  通过将可用硬件资源保持空闲的时间减至最少来利用这些资源。
4.  代码行为是确定性的，因此易于调试。执行流模仿顺序代码流，这意味着它更易于设计和理解。
5.  因为正确的顺序可以最大限度地减少填写表单所需的手势数量。
6.  因为它允许以独立于操作系统的方式操纵路径文件。
7.  它可以与多个.NETCore 版本以及多个经典.NET framework 版本一起使用。
8.  控制台、.NETCore 和.NET 标准类库；ASP.NETCore、测试和微服务。

# 第三章

1.  不，它可用于多个平台。
2.  自动、手动和负载测试计划。
3.  是的，他们可以–通过 Azure DevOps 订阅源。
4.  管理需求并组织整个开发过程。
5.  Epic 工作项表示由多个功能组成的高级系统子部分。
6.  父子关系。

# 第四章

1.  当您从内部部署解决方案迁移或拥有基础架构团队时，IaaS 是一个不错的选择。
2.  在团队专注于软件开发的系统中，PaaS 是快速、安全地交付软件的最佳选择。
3.  如果你打算交付的解决方案是由一个著名的玩家提供的，比如 SaaS，你应该考虑使用它。
4.  在构建新系统时，如果您没有专门从事基础架构的人员，并且您不想担心可扩展性，那么无服务器无疑是一种选择。
5.  Azure SQL Server 数据库可以在几分钟内启动，之后您将拥有 Microsoft SQL Server 的所有功能。
6.  Azure 提供了一组称为 Azure 认知服务的服务。这些服务为视觉、语音、语言、搜索和知识提供解决方案。
7.  在混合方案中，您可以灵活地为系统的每个部分确定最佳解决方案，同时尊重解决方案未来的开发路径。

# 第五章

1.  代码模块化和部署模块化。
2.  不需要。其他重要的优势包括处理好开发团队和整个 CI/CD 周期，以及轻松有效地混合异构技术的可能性。
3.  帮助我们实现弹性通信的库。
4.  在开发机器上安装 Docker 后，就可以开发、调试和部署停靠的.NETCore 应用。您还可以将 Docker 映像添加到使用 Visual Studio 处理的 Service Fabric 应用中。
5.  编排器是管理微服务集群中的微服务和节点的软件。Azure 支持两个相关的编排器：Azure Kubernetes 服务和 Azure 服务结构。
6.  因为它将通信中发生的参与者解耦。
7.  消息代理。它负责服务间的通信和事件。
8.  同一消息可以多次收到，因为发送方在其超时期间之前没有收到接收确认，因此发送方再次重新发送该消息。因此，一次或多次接收单个消息的效果必须相同。

# 第六章

1.  可靠的服务是本机 Azure 服务结构服务。但是，Azure 服务结构还可以承载其他类型的服务，例如停靠服务。
2.  无状态的和有状态的。无状态服务用于实现不需要存储任何状态的微服务，而有状态服务实现需要存储状态信息的微服务。
3.  它是`HostBuilder`方法，您可以在其中放置依赖项注入容器。
4.  暴露于来自集群外部的流量并可通过集群的 URI 访问的一个。
5.  为了使用*分片*在有状态服务中实现写/修改并行。
6.  使用只读端点。可通过提供`ServiceReplicaListener`的`IEnumerable`来添加自定义通信协议。

# 第七章

1.  由于 pod 没有稳定的 IP 地址，因此需要服务来向 pod 发送通信。
2.  服务理解诸如 TCP/IP 之类的低级协议，但大多数 web 应用依赖于更复杂的 HTTP 协议。这就是 Kubernetes 提供名为`Ingresses`的更高级别实体的原因，这些实体构建在服务之上。
3.  Helm 图表是一种组织包含多个`.yaml`文件的复杂 Kubernetes 应用的模板和安装的方法。
4.  是的，使用`---`分离器。
5.  与`livenessProbe`一起。
6.  因为 pod 没有稳定的位置，不能依赖于它们当前运行的节点的存储。
7.  `StatefulSet`通信可以分片，实现写/更新并行。

# 第八章

1.  在依赖数据库的提供者的帮助下。
2.  通过调用它们`Id`或使用`Key`属性对它们进行装饰。这也可以通过流畅的配置方法实现。
3.  具有`MaxLength`和`MinLength`属性。
4.  类似于：`builder.Entity<Package>().HasIndex(m => m.Name);`。
5.  类似于：

    ```cs
    builder.Entity<Destination>()
    .HasMany(m => m.Packages)
    .WithOne(m => m.MyDestination)
    .HasForeignKey(m => m.DestinationId)
    .OnDelete(DeleteBehavior.Cascade); 
    ```

6.  添加迁移和更新数据库。
7.  不可以，但是您可以在配置您的`DbContext`时使用`Include`LINQ 子句或`UseLazyLoadingProxies`选项强制包含它们。
8.  是的，多亏了`Select`LINQ 条款。
9.  通过呼叫`context.Database.Migrate()`。

# 第九章

1.  不，它是一个内存字典，可以用作缓存或满足其他内存存储需求。
2.  是的，他们是。本章的大部分章节都致力于解释原因。
3.  写操作。
4.  NoSQL 数据库的主要缺点是它们的一致性和事务，而它们的主要优点是性能，特别是在处理分布式写操作时。
5.  最终，一致性前缀，会话，有界过时，强。
6.  不，它们在分布式环境中效率不高。基于 GUID 的字符串性能更好，因为它们的唯一性是自动的，不需要同步操作。
7.  `OwnsMany`和`OwnsOne`。
8.  是的，他们可以。使用`SelectMany`后，可以使用索引搜索嵌套对象。

# 第十章

1.  Azure Functions 是一个 Azure PaaS 组件，允许您实现 FaaS 解决方案。
2.  您可以用不同的语言编写 Azure 函数，如 C#、F#、PHP、Python 和 Node。您还可以使用 Azure 门户和 Visual Studio 代码创建函数。
3.  Azure 功能中有两个计划选项。第一个计划是消费计划，根据你的使用量向你收费。第二个计划是应用服务计划，在该计划中，您可以根据功能的需要共享应用服务资源。
4.  在 Visual Studio 中部署函数的过程与在 web 应用部署中相同。
5.  有很多方法可以触发 Azure 功能，例如使用 Blob 存储、Cosmos DB、事件网格、事件集线器、HTTP、Microsoft Graph Events、队列存储、服务总线、计时器和 Webhook。
6.  Azure 功能 v1 需要.NET Framework 引擎，而 v2 需要.NET Core 2.2，v3 需要.NET Core 3.1 和.NET 5。
7.  每个 Azure 功能的执行都可以通过应用洞察进行监控。在这里，您可以检查每个函数调用中的处理时间、资源使用情况、错误和异常。

# 第十一章

1.  设计模式是解决软件开发中常见问题的好方法。
2.  虽然设计模式为我们在开发中面临的典型问题提供了代码实现，但设计原则可以帮助您在实现软件架构时选择最佳选项。
3.  生成器模式将帮助您生成复杂的对象，而无需在将要使用它们的类中定义它们。
4.  工厂模式在同一抽象中有多种类型的对象，并且在开始编码时不知道需要创建哪种对象的情况下非常有用。
5.  当您需要在软件执行期间只有一个实例的类时，Singleton 模式非常有用。
6.  当需要提供控制对另一个对象的访问的对象时，将使用代理模式。
7.  当需要执行将影响对象行为的*命令*时，使用命令模式。
8.  当您需要向一组其他对象提供有关对象的信息时，发布者/订阅者模式非常有用。
9.  如果要实现控制原理的反转，DI 模式非常有用。

# 第十二章

1.  专家使用的语言的变化和单词含义的变化。
2.  域映射。
3.  不整个通信都通过实体，即聚合根。
4.  因为聚合表示零件子部分层次结构。
5.  只有一个，因为存储库是以聚合为中心的。
6.  应用层操作存储库接口。存储库实现在依赖项注入引擎中注册。
7.  协调多个聚合上的单个事务操作。
8.  更新和查询的规范通常非常不同，特别是在简单的 CRUD 系统中。其最强形式的原因主要是查询响应时间的优化。
9.  依赖注入。
10.  不必须进行认真的影响分析，以便我们能够采用它。

# 第十三章

1.  不，因为在这种方法中会有大量重复的代码，这将在维护时造成困难。
2.  代码重用的最佳方法是创建库。
3.  对您可以在以前创建的库中找到已经创建的组件，然后通过创建将来可以重用的新组件来增加这些库。
4.  .NET 标准是一种规范，允许.NET 的不同框架（从.NET Framework 到 Unity）之间的兼容性。NETCore 是一个.NET 实现，是开源的。
5.  通过创建.NET 标准库，您将能够在不同的.NET 实现中使用它，例如.NETCore、.NET 框架和 Xamarin。
6.  您可以使用面向对象的原则（继承、封装、抽象和多态性）实现代码重用。
7.  泛型是一种复杂的实现，它通过定义一个占位符来简化具有相同特征的对象的处理方式，占位符将在编译时替换为特定类型。
8.  这个问题的答案由 Immo Landwerth 在 dotnet 博客上解释得很好：[https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/) 。基本的答案是.NET 5（和未来版本）需要被认为是共享代码向前推进的基础。
9.  当您重构代码时，您是在以更好的方式编写代码，尊重该代码将处理的数据的输入和输出契约。

# 第十四章

1.  不，因为这违反了服务对请求的响应必须依赖于请求本身，而不是依赖于之前与客户端交换的其他消息/请求的原则。
2.  否，因为这将违反互操作性约束。
3.  是的，它可以。`POST`的主要操作必须是创建，但删除可以作为副作用执行。
4.  三，即头和正文加上签名的 Base64 编码。
5.  来自请求主体。
6.  具有`ApiController`属性。
7.  `ProducesResponseType`属性。
8.  具有`Route`和`Http<verb>`属性。
9.  类似于`services.AddHttpClient<MyProxy>()`的东西。

# 第 15 章

1.  开发人员错误页和开发人员数据库错误页、生产错误页、主机、HTTPS 重定向、路由、身份验证和授权以及端点调用程序。
2.  不
3.  错误的可以在同一个标记上调用多个标记帮助程序。
4.  `ModelState.IsValid`。
5.  `@RenderBody()`。
6.  我们可以使用`@RenderSection("Scripts", required: false)`。
7.  我们可以使用`return View("viewname", ViewModel)`。
8.  三
9.  不还有一本`ViewState`字典。

# 第十六章

1.  它是 W3C 标准：运行在 W3C 兼容浏览器中的虚拟机的组装。
2.  在浏览器中创建动态 HTML 的 Web UI。
3.  基于当前浏览器 URL 选择页面。
4.  连接有路由的 Blazor 组件。因此，Blazor`router`可以选择它。
5.  定义 Blazor 组件类的.NET 命名空间。
6.  一种本地服务，负责存储和处理所有与表单相关的信息，如验证错误和 HTML 输入中的更改。
7.  无论是`OnInitialized`还是`OnInitializedAsync`。
8.  回调和服务。
9.  Blazor 是一种与 JavaScript 交互的方式。
10.  获取对组件或 HTML 元素实例的引用。

# 第 17 章

1.  可维护性使您有机会快速交付您设计的软件。它还允许您轻松修复 bug。
2.  圈复杂度是检测方法节点数的度量。数字越高，效果越差。
3.  版本控制系统将保证源代码的完整性，使您有机会分析所做的每次修改的历史记录。
4.  垃圾收集器是一个.NET Core/.NET Framework 系统，它监视您的应用并检测您不再使用的对象。它处理这些对象以释放内存。
5.  `IDisposable`接口首先很重要，因为它是确定性清理的良好模式。其次，在实例化需要程序员处理的对象的类中，它是必需的，因为垃圾收集器无法处理它们。
6.  .NETCore 以一种可以保证代码更安全的方式将一些设计模式封装在其某些库中，例如使用依赖项注入和生成器。

# 第 18 章

1.  因为大多数测试必须在任何软件更改发生后重复。
2.  因为单元测试及其相关应用代码中发生完全相同错误的概率非常低。
3.  当测试方法定义多个测试时使用`[Theory]`，当测试方法仅定义一个测试时使用`[Fact]`。
4.  `Assert`。
5.  `Setup`、`Returns`和`ReturnsAsync`。
6.  对与`ReturnAsync`一起。

# 第 19 章

1.  编写良好的代码是任何精通该编程语言的人都可以处理、修改和发展的代码。
2.  Roslyn 是 Visual Studio 内部用于代码分析的.NET 编译器。
3.  代码分析是一种实践，它考虑编写代码的方式，以便在编译之前检测不良实践。
4.  代码分析可以发现即使使用表面上很好的软件也会出现的问题，例如内存泄漏和糟糕的编程实践。
5.  Roslyn 可以检查代码的样式、质量、可维护性、设计和其他问题。这是在设计时完成的，因此您可以在编译代码之前检查错误。
6.  VisualStudio 扩展是已编程为在 VisualStudio 中运行的工具。在某些情况下，如果 VisualStudioIDE 没有适合您使用的功能，这些工具可以帮助您解决问题。
7.  Microsoft 代码分析、Sonarint 和代码破解程序。

# 第二十章

1.  DevOps 是持续向最终用户提供价值的方法。为了取得成功，必须进行持续集成、持续交付和持续反馈。
2.  持续集成允许您在每次提交更改时检查所交付软件的质量。您可以通过在 Azure DevOps 中启用此功能来实现这一点。
3.  持续交付允许您在确保所有质量检查都通过您设计的测试后部署解决方案。Azure DevOps 通过为您提供相关工具来帮助您实现这一点。
4.  持续反馈是指在 DevOps 生命周期中采用的工具，当涉及到您正在开发的应用的性能、可用性和其他方面时，能够实现快速反馈。
5.  构建管道将允许您运行用于构建和测试应用的任务，而发布管道将允许您定义在每个场景中如何部署应用。
6.  Application Insights 是一个有用的工具，用于监视您部署的系统的运行状况，这使它成为一个出色的连续反馈工具。
7.  测试和反馈是一种工具，允许涉众分析您正在开发的软件，并支持与 Azure DevOps 的连接以打开任务甚至 bug。
8.  使软件为目标组织提供的价值最大化。
9.  不它需要获得使软件增值最大化所需的所有能力。
10.  因为当新用户订阅时，必须自动创建其租户，并且必须将新的软件更新分发到客户的所有基础设施。
11.  对地形就是一个例子。
12.  Azure 管道。
13.  您的业务依赖于 SaaS 供应商，因此其可靠性至关重要。
14.  不可伸缩性与容错和自动故障恢复一样重要。

# 第 21 章

1.  这是一种确保对代码存储库的每一次提交都得到构建和测试的方法。这是通过频繁地将代码合并到代码主体中来实现的。
2.  是的，您可以单独使用 DevOps，然后在以后启用连续集成。您还可以启用连续集成，而无需在上连续交付。您的团队和流程需要做好准备并全神贯注于此。
3.  您可能会误解 CI 是一个持续的交付过程。在这种情况下，可能会损坏生产环境。例如，在最坏的情况下，您可能拥有一个尚未准备好但已部署的功能，您可能会导致客户在不合适的时间停止，或者您甚至可能由于错误的修复而遭受不良的附带影响。
4.  启用 CI-CD 时，多阶段环境可保护生产不受不良发行的影响。
5.  自动化测试可以预测预览场景中的错误和不良行为。
6.  拉请求允许在主分支中进行提交之前进行代码检查。
7.  不 pull 请求可以帮助您使用 Git 作为源代码控制的任何开发方法。

# 第 22 章

1.  不这取决于用户界面的复杂性和更改频率。
2.  ASP.NETCore 管道不会执行，但输入会直接传递给控制器。
3.  使用`Microsoft.AspNetCore.Mvc.Testing`NuGet 软件包。
4.  使用`AngleSharp`NuGet 软件包。