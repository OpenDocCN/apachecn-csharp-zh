# *第十二章*:多线程和异步编程

自从第一台个人计算机问世以来，我们一直受益于 CPU 能力的不断提高——这一现象严重影响了开发人员对工具、语言和应用程序设计的选择，而从历史上看，我们并没有在利用多线程进行编程方面投入太多精力。

在硬件方面，根据摩尔定律，处理器中晶体管的密度每两年就会翻一番，从而提供更多的计算能力，这一预测已经持续了几十年，但我们已经可以观察到它正在放缓。 即使 CPU 制造商在大约 20 年前就开始生产多核 CPU，并发执行代码的能力主要是由**操作系统(**操作系统**)用于更平滑地执行多个进程。**

 **这并不意味着代码无法利用并发的力量，只是只有一小部分应用程序完全包含了*多线程范例*。 这主要是因为我们编写的所有代码都是从操作系统基础架构提供的单个线程中顺序执行的，除非我们显式地请求创建其他线程并编排它们的执行。

这一趋势主要是由于许多编程语言不提供自动生成多线程代码的结构。 这是因为很难提供适合任何用例的语义并有效地利用现代 cpu 提供的并发处理能力。

另一方面，有些时候我们确实不需要并发地执行应用程序代码，但我们不能继续执行，因为有必要等待一些未完成的 I/O 操作。 同时，阻塞代码执行也是不可接受的，因此需要不同的策略。 这些问题属于*异步编程*范畴，需要稍微不同的工具。

在本章中，我们将学习多线程和异步编程的基础知识，并特别关注以下内容:

*   什么是线程?
*   在。net 中创建线程
*   理解同步原语
*   任务范式

在本章结束时，您将熟悉多线程技术，使用原语来同步代码执行、任务、延续和取消令牌。 您还将了解哪些操作具有潜在的危险，以及在多个线程之间共享资源时避免问题的基本模式。

现在我们将开始熟悉在g 中操作多线程和异步程序所需的基本概念。

# 什么是线程?

每个操作系统都提供抽象，允许多个程序共享相同的硬件资源，如 CPU、内存和输入输出设备。 进程就是这些抽象中的一种，它提供了一个保留的虚拟地址空间，使其运行的代码无法逃脱。 这个基本的沙盒避免了流程代码与其他流程的干扰，为平衡的生态系统建立了基础。 该进程与代码执行无关，但主要与内存有关。

负责代码执行的抽象是**线程**。 每个进程至少有一个线程，但是任何进程代码都可以请求创建更多线程，这些线程共享相同的虚拟地址空间(由所属进程划分)。 在一个进程中运行多个线程大致相当于一组从事同一项目的木工朋友——他们需要协调，关注彼此的进度，并注意不要阻碍彼此的活动。

所有现代操作系统都提供先发制人的多任务策略，而不是协同多任务。 这意味着操作系统的一个特殊组件可以调度每个线程的运行时间，而不需要运行代码的任何合作。

提示

Windows 的早期版本，如 Windows 3。 x 和 Windows 9x，使用协同多任务处理，这意味着任何应用程序都可以通过一个简单的无限循环挂起整个操作系统。 这主要是由于 CPU 能力和功能的限制。 所有后来的操作系统，例如从第一个**NT 3.1 Advanced Server**开始的 Windows 版本和所有类 unix 操作系统，都一直使用抢占式多任务，使操作系统更健壮，并提供更好的用户体验。

您可以使用任务管理器、进程资源管理器或进程黑客工具查看每个运行进程中使用的线程数。 您将立即注意到许多应用程序，包括所有的。net 应用程序，使用多个单独的线程。 这一信息并没有告诉我们很多关于如何应用程序设计,因为现代等运行时。net CLR 使用后台线程进行内部处理,如**垃圾收集器**,**终结队列**,等等。

提示

为了看到运行的进程所使用的线程的数量,打开**任务管理器***(*Ctrl*+*【T7 转变】+【显示】Esc*),点击**细节**选项卡,并添加【病人】线程列。 可以通过右键单击其中一个网格标题，选择**Select Columns**菜单项，最后检查**Threads**声音来添加列。*

 *下面的截图显示了一个 c++控制台应用程序，其中用户的代码使用一个线程，其他三个线程是由 c++运行时创建的:

![Figure 12.1 - The Task Manager showing NativeConsole.exe process with four threads ](img/Figure_12.1_B12346.jpg)

图 12.1 -任务管理器显示带有四个线程的 native econsole .exe 进程

包含处理线程的原语的名称空间是**System。 线程**，但在本章后面，我们还将介绍**任务**，它是**System.Threading.Tasks**命名空间的一部分。

当。net 应用程序启动时，. net 运行时准备我们的进程，分配内存并创建一些线程，包括从**Main**入口点开始旋转代码执行的线程。

下面的控制台应用程序访问当前线程并在屏幕上打印当前线程**Id**:

```cs
static void Main(string[] args)
{
    Console.WriteLine($"Current Thread Id: {Thread.CurrentThread.ManagedThreadId}");
    Console.ReadKey();
}
```

在诊断多线程代码时，**managedthreaddid**属性很重要，因为它将某些代码的执行与特定线程关联起来。

这个**Id**只能在运行的进程中使用，与 OS 线程标识符不同。 如果你曾经需要访问本地标识符，你需要使用互操作性，如下 windows 代码片段所示:

```cs
[DllImport("Kernel32.dll")]
private static extern int GetCurrentThreadId();
static void Main(string[] args)
{
    Console.WriteLine($"Current Thread Id: {Thread.CurrentThread.ManagedThreadId}");
    Console.WriteLine($"Current Native Thread Id: {GetCurrentThreadId()}");
    Console.ReadKey();
}
```

本地的**Id**是你可以在**进程浏览器**和**进程黑客**工具中看到的，并且是需要与其他本地 api 互操作的。 在下面的截图中，你可以看到左边控制台打印的结果，右边是 Process Hacker 线程窗口:

![Figure 12.2 - The console application side by side with Process Hacker showing the same native thread Id ](img/Figure_12.2_B12346.jpg)

图 12.2 -控制台应用程序与 Process Hacker 并排显示相同的本机线程 Id

线程也可以从操作系统、。net 运行时或某些库中创建，而无需我们的代码显式地请求它。 例如，下面的类在操作中显示了一个**FileSystemWatcher**类，并为每个文件系统操作打印了**ManagedThreadId**属性: **运行方法打印与主线程相关 ID,而**Wacher_Deleted**和【显示】Watcher_Created 方法从一个线程执行操作系统创建的或基础设施:**

 **```cs
public class FileWatcher
{
    private FileSystemWatcher _watcher;
    public void Run()
    {
        var path = Path.GetFullPath(".");
        Console.WriteLine($"Observing changes in path: {path}");
        _watcher = new FileSystemWatcher(path, "*.txt");
        _watcher.Created += Watcher_Created;
        _watcher.Deleted += Watcher_Deleted;
        Console.WriteLine($"TID: {Thread.CurrentThread.ManagedThreadId}");
        _watcher.EnableRaisingEvents = true;
    }
    private void Watcher_Deleted(object sender, FileSystemEventArgs e)
    {
        Console.WriteLine($"Deleted occurred in TID: {Thread.CurrentThread.ManagedThreadId}");
    }
    private void Watcher_Created(object sender, FileSystemEventArgs e)
    {
        Console.WriteLine($"Created occurred in TID: {Thread.CurrentThread.ManagedThreadId}");
    }
} 
```

您可以通过创建一个控制台应用程序并将以下代码添加到**Main**方法中来试验这段代码:

```cs
var fw = new FileWatcher();
fw.Run();
Console.ReadKey();
```

现在，如果您在控制台文件夹中开始创建和删除一些**.txt**文件，您将看到如下内容:

```cs
Observing changes in path: C:\projects\Watch\bin\Debug\netcoreapp3.1
TID: 1
Created occurred in TID: 5
Created occurred in TID: 7
Deleted occurred in TID: 5
Deleted occurred in TID: 5
```

每次重新运行应用程序时，您看到的**TID**数字可能会改变:它们既不可预测，也不能以相同的顺序使用。

现在我们将看到如何创建一个新线程，并发地执行一些代码，并检查线程的主要特征。

# 在。net 中创建线程

只有当您有一个只依赖于 CPU 的长时间运行的操作时，创建原始线程才最有意义。 举个例子，假设我们想要计算质数，而不真正关心可能的优化:

```cs
public class Primes : IEnumerable<long>
{
	public Primes(long Max = long.MaxValue)
	{
		this.Max = Max;
	}
	public long Max { get; private set; }
	IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable<long>)this).GetEnumerator();
	public IEnumerator<long> GetEnumerator()
	{
		yield return 1;
		bool bFlag;
		long start = 2;
		while (start < Max)
		{
			bFlag = false;
			var number = start;
			for (int i = 2; i < number; i++)
			{
				if (number % i == 0)
				{
					bFlag = true;
					break;
				}
			}
			if (!bFlag)
			{
				yield return number;
			}
			start++;
		}
	}
}
```

**Primes**类实现了**IEnumerable<long>**，这样我们就可以方便地在**foreach**语句中枚举出素数。 **Max**参数用于限制结果序列，否则由**long 限制。 MaxValue**。

调用前面的代码非常容易，但是由于的计算需要很长时间，它完全阻塞了正在执行的线程:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
// namespace and class declaration omitted for clarity
Console.WriteLine("Start primes");
foreach (var n in new Primes(1000000))   {  /* ...  */ }
Console.WriteLine("End primes"); // the wait is too long!
```

这里发生的是主线程忙着计算质数。 多亏了抢占式多任务处理，这个线程将被操作系统调度程序中断，给其他进程的线程机会来运行他们的代码。 然而，由于我们的应用程序没有其他线程执行应用程序代码，我们只能等待。

在任何桌面应用程序中，无论是控制台还是 GUI，用户体验都是令人沮丧的，因为与鼠标和键盘的任何交互都被*阻止*。 更糟糕的是，gui 甚至不能重新绘制屏幕的内容，因为唯一的线程被质数的计算窃取了。

第一步是将阻塞代码移动到一个单独的方法中，这样我们就可以在一个新的单独的线程中执行它:

```cs
private void Worker(object param)
{
    PrintThreadInfo(Thread.CurrentThread);
    foreach (var n in new Primes(1000000))
    {
        Thread.Sleep(100);
    }
    Console.WriteLine("Computation ended!");
}
```

**线程。 使用 Sleep**方法只是为了观察 CPU 的使用情况。 然后，**Sleep**告诉 OS 暂停当前线程执行给定的时间，以*毫秒*表示。 通常，在生产代码中不建议调用**Sleep**，因为它会阻止线程被重用。 在本章后面，我们将发现在代码中插入延迟的更好方法。

**Worker**方法没有任何特殊的内容，它可以选择获得一个对象参数，用于初始化局部变量。 我们不直接调用它，而是让基础架构在新线程的上下文中调用它:

```cs
Console.WriteLine("Start primes");
PrintThreadInfo(Thread.CurrentThread);
var t1 = new Thread(Worker);
//t1.IsBackground = true; // try with/without this line
t1.Start();
Console.WriteLine("Primes calculation is happening in background");
```

从前面的代码中可以看到，创建了**Thread**对象，但线程还没有启动。 我们必须显式地调用**Start**方法来实现它。 这很重要，因为**Thread**类有其他重要的属性，这些属性只能在线程启动之前设置。

最后，通过使用**PrintThreadInfo**方法打印主线程的详细信息。 请注意，有些属性并不总是可用的。 因此，我们必须在打印**Priority**或**IsBackground**之前检查线程是否正在运行。 由于**ThreadState**枚举具有**Flags**属性，且**Running**状态为零， 官方文档(https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadstate?view=netframework-4.8#remarks)提醒我们检查是否**Stopped**和**Unstarted**位没有设置:

```cs
private void PrintThreadInfo(Thread t)
{
    var sb = new StringBuilder();
    var state = t.ThreadState;
    sb.Append($"Id:{t.ManagedThreadId} Name:{t.Name} State:{state} ");
    if ((state & (ThreadState.Stopped | ThreadState.Unstarted)) == 0)
    {
        sb.Append($"Priority:{t.Priority} IsBackground:{t.IsBackground}");
    }
    Console.WriteLine(sb.ToString());
}
```

执行上述代码的结果如下:

```cs
Start primes
Id:1 Name: State:Running Priority:Normal IsBackground:False
Primes calculation is happening in background
Id:5 Name: State:Running Priority:Normal IsBackground:False
```

即使这个只是一个微不足道的例子，我们也必须注意以下几点:

*   首先，对于**prime 计算……**和**Id:5……**行，我们无法保证*输出顺序*。 它们可能以*倒序*出现。 为了获得*确定性行为*，您需要应用一种同步技术，我们将在稍后的*理解同步原语*小节中讨论这种技术。
*   另一个重要的考虑因素是*CPU 使用率*。 如果打开**任务管理器**，在**性能**选项卡下，可以设置该视图为每个逻辑 CPU 显示单独的图形。 在下面的截图中，您可以看到一个 4 核 CPU 有 8 个逻辑核(多亏了 Intel 超线程技术!) 您可能还想显示内核时间(以较深的颜色显示)，因为内核模式只执行操作系统和驱动程序的代码，而用户模式(以较浅的颜色显示)只执行我们编写的代码。 这种区别会让你立即看到哪些应用程序代码正在执行:

![Figure 12.3 - The Task Manager showing all the logical processors ](img/Figure_12.3_B12346.jpg)

图 12.3 -任务管理器显示所有的逻辑处理器

如果我们现在执行代码没有**睡眠**,我们将看到一个 CPU 将显示更高数量的 CPU 使用率在一个线程不断消耗全额的执行时间的操作系统。 该单个线程影响的 CPU 时间总量(100%)为*100% / 8 个 CPU = 12.5%*。 事实上，在计算过程中，**任务管理器**的**Details**标签会显示你的进程大约消耗 12%的 CPU:

![Figure 12.4 - The Task Manager showing the execution time distributed across all the available logical CPUs](img/Figure_12.4_B12346.jpg)

图 12.4 - Task Manager 显示所有可用逻辑 cpu 的执行时间分布

线程计算*分布*到多个逻辑 cpu。 每次操作系统中断线程，调度另一个进程的其他工作，然后返回到我们的线程，线程可以在任何其他逻辑 CPU 上执行。

就像一个实验，你可以通过在**Worker**方法的开头添加以下代码来强制执行在一个特定的逻辑 CPU 上:

```cs
var threads = System.Diagnostics.Process.GetCurrentProcess().Threads;
var processThread = threads
    .OfType<System.Diagnostics.ProcessThread>()
    .Where(pt => pt.Id == GetCurrentThreadId())
    .Single();
processThread.ProcessorAffinity = (IntPtr)2; // CPU 2
```

这段代码需要在类内部声明如下:

```cs
[DllImport("Kernel32.dll")]
private static extern int GetCurrentThreadId();
```

这些新的行代码检索进程的所有**ProcessThread**对象的列表，然后过滤本机 ID 与执行该进程的 ID 相匹配的**ProcessThread**对象。

设置**ProcessorAffinity**后,新的执行完全加载逻辑 CPU**2**我们的计算,如下截图所示的浅蓝色部分(CPU**2**完全填充矩形):

![Figure 12.5 – The Task Manager showing CPU 2 fully loaded with the execution of the sample code ](img/Figure_12.5_B12346.jpg)

图 12.5 - Task Manager 显示 CPU 2 完全加载了示例代码的执行

在立即开始线程之前，我们有可能通过设置一个或多个以下属性来塑造线程特征:

*   操作系统调度程序使用了**Priority**属性来决定线程可以运行的时间槽。 给它一个高优先级可以减少线程挂起的时间。
*   **Name**属性在调试时非常有用，因为你可以在 Visual Studio Thread 窗口中看到它。
*   我们简要地讨论了**ThreadState**属性，它可以假设许多不同的值。 其中一个——**WaitSleepJoin**——表示一个线程处于**Wait**方法中或处于睡眠状态。
*   **CurrentCulture**和**CurrentCulture**属性由依赖于*区域的*的某些 api 读取。 对于的例子,当你数字或日期转换成一个字符串(使用【显示】ToString 方法)或**解析静态方法相反的转换【病人】,当前文化设置使用。**
*   **IsBackground**属性指定线程是否应该阻止进程在其仍处于活动状态时终止。 当为 true 时，进程将不会等待线程完成其工作。 在我们的示例中，如果您将其设置为 true，那么您可以通过按任意键来结束该过程。

您可能已经注意到**线程**类有**中止**方法。 永远不应该使用它，因为它可能破坏内存状态或阻止托管资源的正确处理。

正确的终止线程的方法是正常地从它最初启动的方法退出。 在本例中，这是**Worker**方法。 一个简单的**return**语句就是所需要的。

我们已经看到了如何手动创建线程，但是还有一种更方便的方法可以在单独的线程中运行一些代码——**ThreadPool**类。

## 使用 ThreadPool 类

我们花了一些时间研究线程的特性，这确实非常有用，因为线程是基本的代码执行构建块。 手动创建线程是正确的，只要它执行的是依赖于 cpu 的长时间运行的代码。 无论如何，由于线程的成本取决于操作系统，创建足够数量的线程并重用它们是更明智的做法。 它们的数量很大程度上取决于可用的逻辑 cpu 和其他因素，这就是为什么使用**ThreadPool**抽象要好得多的原因。

静态的**ThreadPool**类提供了一个线程池，可以用来运行一些并发计算。 一旦代码结束，线程就返回池，对未来的操作可用，而不需要销毁和重新创建。

提示

注意不要修改从**ThreadPool**中选取的线程的任何属性。 例如，如果修改**ProcessorAffinity**，即使线程被用于不同的目的而重用，该设置也将继续有效。 如果您需要修改线程的属性，那么手动创建仍然是最好的选择。

使用**ThreadPool**类运行我们的**Worker**很简单:

```cs
Console.WriteLine("Start primes");
PrintThreadInfo(Thread.CurrentThread);
ThreadPool.QueueUserWorkItem(Worker);
Console.WriteLine("Primes calculation is happening in background");
```

请注意，**线程**类构造函数和**QueueUserWorkItem**接受的委托参数是不同的，但接受对象参数的委托参数与两者兼容。

我们已经看到了如何启动并行计算，但仍然无法协调它们的执行。 如果一个算法在不同的线程上运行，我们需要知道它的终止和如何访问结果。

提示

ThreadPool 来自于许多流行的库，包括。net 运行时附带的基类库。 当您需要访问需要一段时间才能成功或失败的 I/O 操作的资源时，大多数情况下，**ThreadPool**就会发挥作用。 这些资源包括数据库、文件系统对象或任何可以通过网络访问的资源。

每当您需要并发地访问一个资源时，无论是通过 I/O 操作检索的资源，还是内存中一个对象的实例，您可能需要同步其访问。 在下一节中，我们将看到如何同步线程执行。

# 了解同步原语

每次编写单线程代码时，任何方法的执行都是顺序发生的，不需要开发人员的特殊操作。 另一方面，当一些代码在单独的线程上执行时，需要同步以确保避免两个危险的并发条件:**竞态**和**死锁**。 在设计过程中必须小心避免这些类型的问题，因为它们的检测是困难的，而且它们可能偶尔发生。

**竞争条件**是指两个或多个线程访问未受保护的共享资源，或者线程的执行行为不同，这取决于时间和底层进程架构。

当两个或多个线程为了访问一个资源而相互之间存在循环依赖时，会发生*死锁条件*。

当编写一些可能从多个线程执行的代码时，一般的建议如下:

*   尽可能避免共享资源。 它们的访问必须与一个会影响执行性能的锁同步。
*   栈是你的朋友。 每次调用方法时，本地堆栈都是私有的，以确保本地变量不会与其他调用者和线程共享。
*   每次需要在多个线程之间共享资源时，使用文档来验证它是否是线程安全的。 只要不是线程安全的，锁就必须保护资源或代码序列。
*   即使共享资源是线程安全的，也必须考虑是否需要原子地执行许多语句以保证它们的可靠性。

线程库有许多原语可用来保护资源，但我们将更多地关注那些更可能在异步上下文中使用的原语，这是本章将讨论的最重要的主题。

有两组同步原语:

*   那些由 OS 在*内核模式*中实现的
*   由。net 类库提供的*用户模式*

这种区别非常重要，因为每次使用系统调用转换到内核模式时，操作系统都必须保存本地调用和堆栈，这些调用和堆栈将立即恢复，从而影响操作的性能。 内核模式原语的优点是能够给它们命名，并使它们在进程间共享，从而提供强大的机器范围的同步机制。

下面的示例显示了来自**ThreadPool**打印**Ping**和**Pong**的两个线程。 每个线程通过等待匹配**ManualResetEventSlim**来与其他线程同步:

```cs
public void PingPong()
{
    bool quit = false;
    var ping = new ManualResetEventSlim(false);
    var pong = new ManualResetEventSlim(false);
    ThreadPool.QueueUserWorkItem(_ =>
    {
        Console.WriteLine($"Ping thread: {Thread.CurrentThread.ManagedThreadId}");
        while (!quit)
        {
            pong.Wait();
            pong.Reset();
            Console.WriteLine("Ping");
            Thread.Sleep(1000);
            ping.Set();
        }
    });
    ThreadPool.QueueUserWorkItem(_ =>
    {
        Console.WriteLine($"Pong thread: {Thread.CurrentThread.ManagedThreadId}");
        while (!quit)
        {
            ping.Wait();
            ping.Reset();
            Console.WriteLine("Pong");
            Thread.Sleep(1000);
            pong.Set();
        }
    });
    pong.Set();
    Console.ReadKey();
    quit = true;
}
```

创建两个事件之后，运行两个线程并打印运行它们的线程的 ID。 在这些线程内部，每次执行都挂起在**Wait**方法中，这避免了线程消耗任何 CPU 功耗。 列表的最后是**乒乓。 方法开始游戏并解除第一个线程的阻塞。 因为这些事件是*手动*，所以必须将重置为未信号状态，以便下一次命中。 此时，将打印一条消息，延迟模拟一些艰苦的工作，最后，通知另一个事件，这将导致第二个线程解除阻塞。**

或者，我们可以使用**ManualResetEvent**内核事件，其用法与此非常相似。 例如，它用**WaitOne**方法代替**Wait**。 但如果我们在高性能同步算法中使用这些事件，就会有很大的不同。 下表显示了用流行的 Benchmark 测量的两个同步原语的比较。 净微型基准测试库。 两个测试都简单地调用**Set()**，然后调用**Reset()**方法:

```cs
|          Method |        Mean |     Error |    StdDev |
|---------------- |------------:|----------:|----------:|
| KernelModeEvent | 1,892.11 ns | 24.463 ns | 22.883 ns |
|   UserModeEvent |    25.67 ns |  0.320 ns |  0.283 ns |
```

两者之间的差异大约有两个数量级，这一点是不可忽略的。

除了使用内核事件来同步在不同进程中运行的代码的能力之外，它们还可以与强大的**WaitHandle 一起使用。 WaitAny**和**WaitAll**方法，示例如下:

```cs
public void WaitMultiple()
{
    var one = new ManualResetEvent(false);
    var two = new ManualResetEvent(false);
    ThreadPool.QueueUserWorkItem(_ =>
    {
        Thread.Sleep(3000);
        one.Set();
    });
    ThreadPool.QueueUserWorkItem(_ =>
    {
        Thread.Sleep(2000);
        two.Set();
    });
    int signaled = WaitHandle.WaitAny(
        new WaitHandle[] { one, two }, 500);
    switch(signaled)
    {
        case 0:
            Console.WriteLine("One was set");
            break;
        case 1:
            Console.WriteLine("Two was set");
            break;
        case WaitHandle.WaitTimeout:
            Console.WriteLine("Time expired");
            break;
    }
}
```

您可以使用以毫秒为单位的三个超时来查看不同的结果。 其主要思想是，一旦任何事件或超时到期(无论哪个先出现)就退出等待。

提示

Windows 操作系统的内核对象都可以在等待原语中使用。 例如，如果您想等待多个进程退出，您可以只使用前面代码块中显示的**WaitHandle**原语和进程句柄一起使用。

我们只是触及了表面，但是官方文档中有许多示例展示了各种同步对象的实际作用。 相反，我们将继续关注那些与本书更相关的内容，例如从多个线程访问共享资源。

在下面的例子中,我们有一个共同的变量叫做**互联网**,**ManualResetEvent 对象是用于启动的所有线程在一起,和一个简单的对象。 **Shared**属性使用了**线程。 休眠**，导致 setter 上的显式线程上下文切换。 切换通常发生在操作系统调度器先发制人地将控制权交给系统中的另一个线程时。 这不是把戏; 它只是增加了 getter 和 setter 不被每个线程连续执行的概率:**

```cs
int _shared;
int Shared
{
    get => _shared;
    set { Thread.Sleep(1); _shared = value; }
}
ManualResetEvent evt = new ManualResetEvent(false);
object sync = new object();
```

下面的方法将共享变量初始化为**0**，并创建 10 个线程，所有线程都执行 lambda 中的相同的代码:

```cs
public void SharedResource()
{
    Shared = 0;
    var loop = 100;
    var threads = new List<Thread>();
    for (int i = 0; i < loop; i++)
    {
        var t = new Thread(() =>
        {
            evt.WaitOne();
            //lock (sync)
            {
                Shared++;
            }
        });
        t.Start();
        threads.Add(t);
    }
    evt.Set(); // make all threads start together
    foreach (var t in threads)
        t.Join();   // wait for the thread to finish
    Console.WriteLine($"actual:{Shared}, expected:{loop}");
}
```

所有线程立即启动，并在**WaitOne**事件中阻塞执行，该事件由**Set**方法解除阻塞。 这为多个线程提供了更多的机会以相同的时间执行 lambda 中的代码。 最后，我们调用**Join**来等待每个线程的执行结束并打印结果。

这段代码存在同步问题，因为线程将读取一个值，增加 CPU 寄存器中的数字，并将结果写回变量中。 由于许多线程将读取相同的值，写入回变量的值是旧的，其实际的*当前*值将丢失。

通过取消 lock 语句的注释，我们指示编译器在花括号中使用**Critical Section**，这是可用的最快的用户模式同步对象。 这导致序列化对该代码的访问，这对性能有非常重要的影响，这是必要的，也是不可避免的。

我们在开始时创建的空对象实例不应该更改; 否则，不同的线程将等待不同的临界区。 请注意，**lock**参数可以是任何引用类型。 例如，如果您需要保护一个集合，您可以直接锁定它，而无需外部对象的帮助。 无论如何，在我们的示例中，**Shared**是一个值类型，必须在单独的引用类型的帮助下进行保护。

如果您将**Shared**属性替换为一个简单的字段，那么就不太可能发生这个问题。 另外，编译器的配置(调试和发布)也会有很大的不同，因为*内联*和其他优化使得访问字段或简单属性时更有可能不会发生线程上下文切换。 物理硬件配置和 CPU 架构是可能会极大影响这些测试结果的其他变量。

提示

单元测试*不适合*来确保不存在竞争条件或死锁等问题。 另外，请注意，虚拟机是测试并发代码的最糟糕环境，因为调度程序比运行在物理硬件上的操作系统更可预测。

我们已经看到了如何确保许多语句被原子地执行，不受干扰。 但是，如果只是为了确保底层的**_shared**字段的原子增量，有一个更方便的工具——**Interlocked**类。

**联锁**是一个静态类，它暴露了一些有用的方法来确保某些操作的原子性。 例如，我们可以使用下面的代码来代替**lock**语句，它要快得多，即使仅限于**连锁**所公开的操作。 下面的代码展示了如何以原子方式增加**_shared**变量:

```cs
Interlocked.Increment(ref _shared);
```

除此之外，我们还可以使用它来编写变量并以原子方式返回旧值(**Exchange**方法)，或者读取大小大于可用本地寄存器的变量(**Read**方法)。

我们已经看到了为什么需要同步以及我们可以使用哪些主要工具来防止这些并发访问问题。 但是现在，是时候引入一种使每个开发人员的工作更轻松的抽象了—任务范例。

# 任务范式

并发性主要是关于设计具有非常松散耦合的工作单元的算法，这通常是不可能的，或者超出了任何可能的好处而扩展了复杂性。

相反，异步编程与操作系统和设备的异步本质有关，这可能是因为它们会触发事件，也可能是因为执行请求的操作需要时间。 每当用户移动鼠标、在键盘上键入键或从互联网上检索一些数据时，操作系统就会在一个单独的线程中将数据呈现给我们的进程，而我们的代码必须准备好消费它。

最简单的例子之一是从磁盘加载文本文件并计算字符串长度，根据编码方式不同，字符串长度可能与文件长度不同:

```cs
public int ReadLength(string filename)
{
    string content = File.ReadAllText(filename);
    return content.Length;
}
```

一旦调用这个方法，调用线程就会被阻塞，直到操作系统和库完成对它的读取。 操作速度可能如闪电般快，也可能非常慢，这取决于它的大小和技术。 文本文件可能在**网络附加存储**(**NAS),本地磁盘,一个损坏的 USB 密钥,或在远程服务器上通过**虚拟私人网络访问**(**【显示】VPN)。

在桌面应用程序的上下文中，任何阻塞线程都会导致不愉快的用户体验，因为主线程已经负责重绘用户界面和响应来自输入设备的事件。

服务器应用程序也不例外，因为任何阻塞线程都是不能有效地与其他请求一起使用的资源，从而阻止应用程序扩展和服务其他用户。

几十年来,这个问题的解决方案是通过手动执行持久的代码创建一个单独的线程,但最近,. net 运行时引入了任务范式和 c#语言介绍了**异步**和**等待**关键词。 从那时起，整个. net 库被修订以包含这种范例，提供返回基于任务的操作的方法。

任务库(在**System.Threading.Tasks**命名空间中可用)和语言集成提供了一个抽象，极大地简化了异步操作的管理。 任务表示执行定义良好的工作的工作单元。 无论您处理的是并发事件还是异步事件，任务都定义了给定作业及其从创建到完成的生命周期，其中的选项包括成功、失败或取消。

通过定义在给定操作之后应该执行哪些其他任务，可以将任务组成。 链式任务称为**延续**，并通过**任务调度程序**从库中自动调度。

默认情况下，任务库提供了一个默认实现(**TaskScheduler。 默认的**静态属性)，大多数开发人员将永远不需要深入研究。 默认实现使用**ThreadPool**协调任务的执行，并使用*窃取工作*技术在多个线程上重新分配任务队列，以提供负载平衡并防止任务被暂停太长时间。 请注意，这个默认实现足够聪明，最终决定在主线程上直接调度任务的执行，而不是从池中选择一个。 最勇敢的人可以尝试创建自定义的调度程序来更改调度策略，但这不是很多开发人员真正需要做的事情。

后,在的*同步上下文部分中,我们将讨论**同步上下文,它允许延续在调用线程执行,避免了需要使用前一节中描述的同步原语。***

 **让我们开始研究异步版本读取文本文件的任务:

```cs
Task<string> content = File.ReadAllTextAsync(filename);
```

这个新版本的方法*立即完成*，并返回一个表示*正在进行的*操作的对象，而不是返回文件的内容。

由于我们刚刚启动了尚未完成的操作，管理完成所需的步骤如下:

1.  在一个单独的方法中重构异步操作(获取字符串长度)之后的代码。 此方法相当于旧式回调，在异步操作完成之前不能调用该回调。
2.  监视正在进行的任务，并在任务完成或失败时提供通知。
3.  一旦完成，检索结果并在主线程上同步执行(通过**同步上下文**)，或者在出现错误时抛出异常。 如果我们不想干扰潜在的竞态条件，这一步是至关重要的。
4.  调用我们在第一点重构出来的回调函数。

当然，我们没有来手动管理所有这些机器。 Task Library 的第一个有趣的优点是它对延续的支持，它允许开发人员指定一旦任务成功完成就执行的代码:

```cs
public Task<int> ReadLengthAsync(string filename)
{
    Task<int> lengthTask = File.ReadAllTextAsync(filename)
        .ContinueWith(t => t.Result.Length);
    return lengthTask;
}
```

这个新版本比创建线程和手动编写同步代码要好，即使它可以进一步改进。 **ContinueWith**方法包含的代码决定一旦成功读取文件，就执行其他代码。

变量**t**包含失败或成功完成的任务。 如果成功，**t.r ut**包含从**ReadAllTextAsync**方法获得的字符串内容。

不管怎样，我们还是不知道长度; 我们刚刚表达了在**ReadAllTextAsync**的结果被检索之后，如何检索*未来*中的长度。 这就是为什么**lengthTask**变量是**Task<int>**的原因，即整数的承诺。

任务和延续是我强烈推荐的构建模块，因为有时候它们需要直接管理。

但 c#语言也引入了两个宝贵的关键字，进一步简化了我们需要编写的代码。 **await**关键字用来表示操作的结果以及之后的所有内容都是延续的一部分。

多亏了**await**关键字，编译器重构并生成新的**中间语言**(**IL**)代码，以提供异步操作和继续的适当管理。 异步加载文件内容并返回字符串长度的最终代码如下:

```cs
public async Task<int> ReadLengthAsync(string filename)
{
    string content = await File.ReadAllTextAsync(filename);
    return content.Length;
}
```

编译器不只使用延续来重构突出显示的代码部分。 编译器生成一个*类*来处理负责监控任务进度的状态机，以及一个方法，用于在任务状态发生变化时调用适当的代码或抛出异常。

提示

如果您想深入了解生成代码的更多细节，可以使用**ILSpy**工具(https://github.com/icsharpcode/ILSpy/releases)查看生成的IL 代码。

显然，编译器可以去掉承诺，让我们处理返回的内容，对吧? 并非如此——这些代码被重构，我们编写的代码是表达我们期望的工件，而不是方法中通常和顺序发生的事情。

事实上，前面的代码看起来是矛盾的，就像**内容一样。 长度**整数只在将来可用，但是我们直接从返回类型为**Task<int>**的方法返回它。

这就是**async**关键字发挥作用的地方:

*   **async**关键字是一个修饰符，每次我们想在方法中使用**await**时都必须指定该修饰符。
*   **async**关键字通知我们**return**语句指定一个未来的对象或值。 在本例中，返回**int**，但是**async**告诉我们它实际上是一个**Task<int>**。
*   如果一个**异步**方法返回**void**，返回类型变为非泛型**Task**。

我们现在有一个异步处理文件的方法，但是我们必须将签名从**int**更改为**Task<int>**。

当您在 lambda 的主体中使用**await**关键字时，也需要**async**关键字。 例如，让我们看看下面的代码:

```cs
Func<int, int, Task<int>> adder = 
    async (a, b) => await AddAsync(a, b);
```

在一个方法上使用**async**意味着所有的调用者也必须包含任务范例，因为否则，它们就无法知道操作何时完成。

## 异步方法的同步实现

我们已经看到了任务范例如何影响方法签名，并且我们知道了方法签名的重要性。 当它出现在公共 API 或接口中时，它是一个契约，在大多数情况下，我们无法更改它。 从设计的角度来看，通过任务来预测给定方法实现的可能性是非常有价值的，但是在某些情况下不需要异步性。

对于这些情况，**Task**类公开了一个静态方法，允许我们直接构建一个有结果或没有结果的已完成任务。 在下面的示例中，异步方法同步返回一个已完成的任务:

```cs
public Task WriteEmptyJsonObjectAsync(string filename)
{
    File.WriteAllText(filename, "{}");
    return Task.CompletedTask;
}
```

**CompletedTask**属性只为整个应用程序域创建一次; 因此，它是非常轻量级的，不应该成为关注性能的任何原因。

如果我们需要返回一个值，我们可以使用静态的**FromResult**方法，该方法在每次调用时都会在内部创建一个新的已完成的**Task**:

```cs
public Task<int> AddAsync(int a, int b)
{
    return Task.FromResult(a + b);
}
```

每次添加两个数字时创建一个对象肯定是一个性能问题，因为它直接影响垃圾收集器必须做的工作量。 出于这个原因，微软最近引入了**ValueTask**类。

## 偶尔异步方法

**ValueTask**不可变结构是一个方便的同步结果或**任务**的包装器。 这种进一步的抽象是为了简化那些需要方法具有异步签名的情况，但它的实现只是偶尔异步。

我们在上一节中用任务定义的**AddAsync**方法可以很容易地转换为使用**ValueTask**结构体:

```cs
public ValueTask<int> AddAsync(int a, int b)
{
    return new ValueTask<int>(a + b);
}
```

使用**Task**的开销是很明显的; 因此，无论何时在热路径中调用这样的方法(一些性能关键代码)，它肯定会成为一个性能问题。

无论如何，在某些情况下，您可能需要将**ValueTask**转换为**Task**，以便从我们将在本章其余部分继续讨论的所有实用程序中获益。 可以通过**AsTask**方法进行转换，该方法返回包装的任务(如果有)，或者创建一个新的**任务**(如果没有)。

## 中断任务链-阻塞线程

给定一个任务，如果调用**Wait**方法或访问**Result**getter 属性，它们将阻塞线程的执行，直到任务完成或取消。 任务范式背后的基本原理是避免阻塞线程，以便它们可以用于其他目的。 但阻断也可能引发非常糟糕的副作用。

由于异步编程中线程的默认源是**ThreadPool**(如果它耗尽了线程)，任何进一步的请求将自动阻塞。 这种现象被称为**线程饥饿**。

一般的建议是避免等待，而使用**await**关键字或延续来完成一些工作。

## 手动创建任务

有些时候，库不提供异步行为，但您不想让当前线程忙那么久。 在这种情况下，您可以使用**任务。 运行**方法，它调度lambda 的执行，这很可能发生在一个单独的线程中。 下面的例子展示了如果我们之前使用的异步**ReadAllTextAsync**方法不可用时如何读取文件的长度:

```cs
public Task<int> ReadLengthAsync(string filename)
{
    return Task.Run<int>(() =>
    {
        var content = File.ReadAllText(filename);
        return content.Length;
    });
}
```

您应该始终选择提供的异步版本，而不是使用**Run**方法，因为调度此任务的线程将阻塞，直到同步执行结束。

现在我们来看看，当一个任务中有大量的工作需要完成时，最好的做法是什么。

## 长时间运行任务

即使您没有阻塞线程，当异步堆栈没有等待并成为长时间运行的作业时，仍然有饿死的风险，从而使线程处于繁忙状态。

这些病例可以用两种不同的策略来治疗:

*   第一种方法是手动*创建线程*，我们在本章开始时已经讨论过了。 当您需要更多的控制或需要修改线程属性时，这是最好的策略。
*   第二种可能性是*通知任务调度程序*任务将运行很长时间。 这样，调度程序将采用不同的策略，完全避免了**ThreadPool**。 下面的代码显示了如何运行长时间运行的任务:

    ```cs
    var t = new Task(() => Thread.Sleep(30000),
        TaskCreationOptions.LongRunning);
    t.Start();
    ```

最重要的建议是尝试将长时间的工作分解成更小的工作单元，以便轻松地转换成任务。

## 打破任务链-开火和忘记

我们已经看到，采用任务范式需要修改整个调用者链。 但有时这是不可能的，也是不可取的。 例如，在桌面 WPF 应用程序中，你可能需要在按钮点击事件处理程序中写入文件:

```cs
void Button_Click(object sender, RoutedEventArgs e) { ... }
```

我们不能将其签名更改为返回**Task**; 此外，这也没有意义，原因有二:

*   调用库已在任务之前设计，因此无法管理任务进度。
*   这是作为**Fire-and-Forget**操作设计的事件之一，这意味着您并不真正关心它们将花费多长时间或它们将计算哪个结果。

对于这些情况，您可以包含**async**/**await**关键字，而不使用返回的**Task**:

```cs
async void Button_Click(object sender, RoutedEventArgs e)
{
    await File.WriteAllTextAsync("log.txt", "something");
    // ... other code
}
```

但是请记住，当您中断任务链时，您就失去了知道操作是否完成或失败的可能性。

信息框

每次您在代码中看到**async void**时，您应该怀疑这是否可能是一个潜在的 bug，或者只是您真的不想知道该任务最终会发生什么。 多年来，使用**async void**而不是**async Task**的习惯已经成为异步代码中 bug 的主要来源。

同样的,如果你只是没有等待调用异步方法(或使用一个**ContinueWith**方法),你将失去控制的调用获得相同的*“即发即弃”的行为,因为异步方法返回后立即开始异步操作。 同样，非等待异步操作之后的所有代码都将并发执行，这会导致竞态条件或访问尚未可用的数据的风险:*

```cs
void Button_Click(object sender, RoutedEventArgs e)
{
    File.WriteAllTextAsync("log.txt", "something");
}
```

我们已经看到，当一切都成功完成时，管理异步操作是多么简单，但是代码可能会抛出异常，我们需要适当地捕获它们。

## 任务和异常

当出现问题时，有两种例外会发生。 第一个是在调用任何异步方法之前，而第二个是与异步代码中发生的异常相关。

下面的例子展示了这两种情况:

```cs
public Task<int> CrashBeforeAsync()
{
    throw new Exception("Boom");
}
public Task<int> CrashAfterAsync()
{
    return Task.FromResult(0)
        .ContinueWith<int>(t => throw new Exception("Boom"));
}
```

在第一种情况中，我们告诉调用者，我们将返回一个**Task<int>**，但是还没有开始异步操作。 这种情况正是在同步方法中发生的，可以相应地捕获:

```cs
public Task<int> HandleCrashBeforeAsync()
{
    Task<int> resultTask;
    try
    {
        resultTask = CrashBeforeAsync();
    }
    catch (Exception) { throw; }
    return resultTask;
}
```

另一方面，如果在继续中发生异常，异常不会立即发生; 它只在任务*被消耗*时发生:

```cs
public async Task<int> HandleCrashAfterAsync()
{
    Task<int> resultTask = CrashAfterAsync();
    int result;
    try
    {
        result = await resultTask;
    }
    catch (Exception) { throw; }
    return result;
}
```

一旦**resultTask**因*故障*而完成，异常就已经发生了，但是编译器生成的代码捕获了它并将其分配给**任务。 异常**属性。 由于**Task**中可能同时发生多个异常，因此生成的代码将所有捕获的异常封装在单个**AggregateException**中。 **AggregateException**中的**InnerException**和**InnerException**属性中包含了原始的异常。

当你想要处理异常并立即解决它们时，你可能想要使用延续而不是**await**关键字:

```cs
public Task<int> HandleCrashAfter2Async()
{
    Task<int> resultTask = CrashAfterAsync();
    try
    {
        return resultTask.ContinueWith<int>(t =>
        {
           if (t.IsCompletedSuccessfully) return t.Result;
           if(t.Exception.InnerException is OverflowException)
               return -1;
           throw t.Exception.InnerException;
        });                
    }
    catch (Exception) { throw; }
}
```

正如我们前面提到的,*中的例外指责*任务被尽快结果得到*,我们前面提到的上下文中使用**等待**。 然而，在访问**t.t result**属性时也可能发生这种情况。*

 *提示

**Task**类暴露了**GetAwaiter**方法，该方法返回表示异步操作的内部结构。 您可以使用**task. getawaiter (). getreresult()**和**task 获得异步操作的结果。 结果**，但有细微差别。 事实上，在异常的情况下，前者返回原始异常，而后者返回包含原始异常的**AggregateException**。

最后，值得一提的是我们可以用静态的**任务重写**CrashAfterAsync**方法。 FromException<T>**方法代替:

```cs
public Task<int> CrashAfterAsync() =>
    Task.FromException<int>(new Exception("Boom"));
```

类似于我们看到**<FromResult T>**,**一个新任务创建**,但是这一次,它的状态是初始化*指责*,它包含所需的例外。

前面的示例非常抽象，但足够简洁，可以让您了解如何正确地处理异常，这取决于抛出异常的时间。 在许多场景中，这种情况经常发生。 这种二元性的一个真实例子是，在准备 JSON 参数时或由于网络故障而在 HTTP rest 调用期间发生序列化异常。

除了转换到故障状态之外，还可以取消任务，这要归功于任务范例提供的内置标准机制。

## 取消任务

与故障不同，调用方请求取消以中断一个或多个任务的执行。 取消可以是强制性的，也可以只是一个超时，当一个给定的任务不应该超过给定的时间量时，这非常有用。

从调用方的角度来看，取消模式源于**CancellationTokenSource**类，它提供了三个不同的构造函数:

*   当您希望通过命令式调用**cancel**方法来取消任务时，将使用默认的构造函数。
*   其他构造函数接受**int**或**TimeSpan**，它们确定触发取消之前的最大时间量，除非任务提前完成。

在下面的示例中，我们将实验使用从计时**CancellationTokenSource**中获得的**CancellationToken**取消三个 worker方法中的一个:

```cs
public async Task CancellingTask()
{
    CancellationTokenSource cts2 = new
        CancellationTokenSource(TimeSpan.FromSeconds(2));
    var tok2 = cts2.Token;
    try
    {
        await WorkForever1Async(tok2);
        //await WorkForever2Async(tok2);
        //await WorkForever3Async(tok2);
        Console.WriteLine("let's continue");
    }
    catch (TaskCanceledException err)
    {
        Console.WriteLine(err.Message);
    }
}
```

令牌属性返回一个只读结构，可以被多个使用者使用，而不会影响垃圾收集器，甚至不会被复制，因为它是不可变的。

这里检查的第一个消费者接受**CancellationToken**，并将其正确地传播到接受取消的任何其他方法。 在我们的示例中，只有**Task。 Delay**，一种非常方便的方法，用于指示基础设施在 5 秒后触发延续:

```cs
public async Task WorkForever1Async(
    CancellationToken ct = default(CancellationToken))
{
    while (true)
    {
        await Task.Delay(5000, ct);
    }
}
```

前面的代码执行的结果是任务的取消，由**await**关键字生成的代码将其转换为**TaskCanceledException**:

```cs
A task was canceled.
```

另一种可能是当一个 worker 只执行*同步*代码，并且仍然需要取消:

```cs
public Task WorkForever2Async(
    CancellationToken ct = default(CancellationToken))
{
    while (true)
    {
        Thread.Sleep(5000);
        if (ct.IsCancellationRequested)
            return Task.FromCanceled(ct);
    }
}
```

请注意**Thread 的用法。 Sleep**而不是**Delay**方法，这是必要的，因为我们需要同步实现。

**线程。 Sleep**方法非常不同，因为它完全阻塞了线程并阻止线程在其他地方被重用，而**Task。 一旦指定的时间量过期，延迟**将生成调用以下代码作为延续的请求。

更有趣的部分是测试**IsCancellationRequested**布尔属性，以允许协作取消任务。 通过显式地检查该属性来实现协作是必要的，因为在处理某些资源(无论是写入数据库还是其他地方)之前，您可能不需要中断执行。

再一次，执行上述方法的结果如下:

```cs
A task was canceled.
```

第三种也是最后一种情况是，你不想抛出任何异常，只是想从执行中返回:

```cs
public async Task WorkForever3Async(
    CancellationToken ct = default(CancellationToken))
{
    while (true)
    {
        await Task.Delay(5000);
        if (ct.IsCancellationRequested) return;
    }
}
```

在本例中，我们小心地避免将**CancellationToken**传播到底层调用，因为通过使用**await**，它将触发异常。

最后一个**WorkForever3Async**方法的执行不会引发任何异常，并让执行正常继续:

```cs
let's continue
```

这种实现的缺点是取消可能不会立即发生。 **任务 延迟**将需要完成，无论取消，在最坏的情况下，不可能发生在 5 秒之前。

我们已经看到了任务范例如何使异步操作的运行变得非常简单，但是我们如何同时运行多个异步请求呢? 它们可以并行运行，以避免无用的等待。

## 监控任务进度

在用户开始一个长时间运行的操作后，提供反馈对于避免用户感到沮丧是非常重要的。 当您能够控制正在发生的事情时，这是可能的，例如使用某些耗时的算法。 相反，当长时间运行的操作依赖于对外部库的调用时，就不可能监视进程。

Task 库没有对进度监控的特定支持，但是. net 库提供了**IProgress<T>**，可以很容易地实现这个目标。 这个接口只提供了一个成员——**void Report(T value)**，这就给实现细节留下了完全的自由。 在最简单的情况下，**T**将是一个整数值，以百分比表示进度。

例如，一个加载操作可以实现如下:

```cs
public async Task Load(IProgress<int> progress = null)
{
    var steps = 30;
    for (int i = 0; i < steps; i++)
    {
        await Task.Delay(300);
        progress?.Report((i + 1) * 100 / steps);
    }
}
```

方法，在我们的示例中，它通过调用**Task 来模拟异步操作。 延迟**，必须有一个预测的总步骤数，这涉及到 100%的进度。 在每个步骤之后，调用**Report**方法来告知我们当前的百分比，但要确保代码不会被保护为 null，因为消费者可能对接收这样的反馈不感兴趣。

在用户端，要做的第一件事是创建进度提供者，它只是一个实现了**IProgress<int>**的类:

```cs
public class ConsoleProgress : IProgress<int>
{
    void IProgress<int>.Report(int value) =>
        Console.Write($"{value}%  ");
}
```

最后，调用者应该将提供者实例传递给**Load**方法:

```cs
await test.Load(new ConsoleProgress());
```

正如您所期望的，输出如下:

```cs
3%  6%  10%  13%  16%  20%  23%  26%  30%  33%  36%  40%  43%  46%  50%  53%  56%  60%  63%  66%  70%  73%  76%  80%  83%  86%  90%  93%  96%  100%
```

**IProgress<T>**的一般参数可能用于暂停执行或触发更复杂的逻辑，如暂停/恢复行为。

## 并行任务

一个常见的编程任务是从 internet 上检索一些资源。 例如，通过 HTTP 下载资源的关键代码如下所示:

```cs
public async Task<byte[]> GetResourceAsync(string uri)
{
    using var client = new HttpClient();
    using var response = await client.GetAsync(uri);
    response.EnsureSuccessStatusCode();
    return await response.Content.ReadAsByteArrayAsync();
}
```

多亏了**EnsureSuccessStatusCode**，任何失败都将触发一个异常，将捕获它的责任留给调用者。 此外，我们甚至没有设置任何头文件，但这对我们的目的来说已经足够了。

我们已经知道如何调用这个异步方法来下载图像，但现在的挑战是选择正确的策略来下载它们:

*   第一个问题是:*我们如何并行下载多个图像?* 如果我们需要下载 10 张图片，我们不想计算下载每一张图片所需的时间。 不管怎样，我们不会讨论我们能扩展到什么程度，比如说，你需要下载数百万张图片。 这超出了异步机制的讨论范围。
*   第二个问题是:*我们是否同时需要它们? 在本例中，我们可以使用**Task。 WhenAll**helper 方法，它接受一个任务数组并返回一个代表整个操作的任务。*

对于这些示例，我们将使用名为*Lorem PicSum*([https://picsum.photos/](https://picsum.photos/))的在线免费服务。 每当您对代码中看到的 URI 发出请求时，将检索到一个新的不同的大小为 200 x 200 的图像。 当然，你可以使用任何你选择的 URI:

```cs
public async Task NeedAll()
{
    var uri = "https://picsum.photos/200";
    Task<byte[]>[] tasks = Enumerable.Range(0, 10)
        .Select(_ => GetResourceAsync(uri))
        .ToArray();
    Task allTask = Task.WhenAll(tasks);
    try
    {
        await allTask;
    }
    catch (Exception)
    {
        Console.WriteLine("One or more downloads failed");
    }
    foreach (var completedTask in tasks)
        Console.WriteLine(
            $"New image: {completedTask.Result.Length}");
}
```

枚举**的使用 范围**是在给定次数下重复一个动作的好方法。 我们不关心生成的数字; 实际上，我们在**Select**方法中使用**discard(_)**令牌来代替变量。

**Select**lambda 只是启动下载操作，返回我们还没有等待的相应任务。 相反，我们要求**WhenAll**方法创建一个新的**Task**，当所有任务都成功完成时，这个 Task 就会发出信号。 如果任何任务失败，由**await**关键字生成的代码将导致抛出一个异常。

从**WhenAll**方法获得的任务不能用于检索结果，但它保证我们可以访问所有任务的**Result**属性。 因此，在等待**allTask**之后，我们迭代**task**数组，为所有下载的图像检索**字节[]**数组。 下面是同时等待所有下载得到的输出:

```cs
New image: 6909
New image: 3846
New image: 8413
New image: 9000
New image: 7057
New image: 8565
New image: 6617
New image: 8720
New image: 4107
New image: 6763
```

在许多情况下，这是一个很好的策略，因为在继续之前我们可能需要所有的资源。 另一种方法是等待第一次下载，以便开始处理，但我们仍然希望同时下载所有文件以节省时间。

这种替代策略可以借助**WaitAny**方法来实现。 在下面的例子中，启动下载也是一样的。 我们只是添加了一个**Stopwatch**类来显示下载结束时所花费的时间(以毫秒为单位):

```cs
public async Task NeedAny()
{
    var sw = new Stopwatch();
    sw.Start();
    var uri = "https://picsum.photos/200";
    Task<byte[]>[] tasks = Enumerable.Range(0, 10)
        .Select(_ => GetResourceAsync(uri))
        .ToArray();
    while (tasks.Length > 0)
    {
        await Task.WhenAny(tasks);
        var elapsed = sw.ElapsedMilliseconds;
        var completed = tasks.Where(t => t.IsCompleted).ToArray();
        foreach (var completedTask in completed)
            Console.WriteLine($"{elapsed} New image: {completedTask.Result.Length}");
        tasks = tasks.Where(t => !t.IsCompletedSuccessfully).ToArray();
    }
}
```

**while**循环用于处理所有未完成的任务。 最初，**任务**数组包含所有这些任务，但是每次**当 any**完成时，就意味着至少有一个任务已经完成。 完成的数据立即被打印在屏幕上，连同操作开始后经过的毫秒一起。 其他任务被重新分配给**任务**变量，这样我们就可以循环处理已完成的任务，直到最后一个。 新方法的输出如下:

```cs
368 New image: 9915
368 New image: 6032
419 New image: 6486
452 New image: 9810
471 New image: 7030
514 New image: 10009
514 New image: 10660
593 New image: 6871
658 New image: 2738
12850 New image: 6072
The last image took a lot of time to download, probably because the online service throttles the requests. Using WhenAll, we would have to wait about 13 seconds before getting them all. Instead, we could start processing as soon as each image was available.
```

当然，您可以将这两种方法结合起来。 例如，如果你想在不超过 100 毫秒的时间内获得尽可能多的下载图像，只需将**WhenAny**行替换为以下一行:

```cs
await Task.WhenAll(Task.Delay(100), Task.WhenAny(tasks));
```

换句话说，我们要求等待任何任务(至少一个)，但不是在 100 毫秒之前。 **while**循环将重复前面所做的操作，通过消耗所有剩余的任务:

```cs
345 New image: 8416
345 New image: 7315
345 New image: 8237
345 New image: 6391
345 New image: 5477
457 New image: 9592
457 New image: 3922
457 New image: 8870
563 New image: 3695
```

当您测试这些代码片段时，请确保在循环中运行它们，因为第一次运行可能受到**即时**编译器的严重影响。

我们已经看到了**Task**类如何提供一个非常强大的构建块来使用异步操作，但这需要库提供异步行为。 在下一节中，我们将看到如何公开手动任务并触发其完成。

## 使用 TaskCompletionSource 对象发送信号

回到*中的文件观察器示例，什么是线程? 在本章开始的*节中，您可能还记得**FileSystemWatcher**暴露事件而不包含任务范例。 您可能想知道我们是否编写了某种适配器来利用 Task Library 提供的所有优秀工具的功能，答案是*是*。

**TaskCompletionSource**对象提供了一个重要的构建块，我们可以使用它来公开异步行为。 它是在生产者端创建和使用的，用来表示操作的完成，无论它是成功还是失败。 它通过**Task**属性提供了客户机必须使用的任务对象来等待通知。

下面的类使用**FileSystemWatcher**监视当前文件夹中的文件系统。 **Deleted**事件停止通知，并通知完成源文件删除成功。 类似地，**Error**事件设置异常，该异常最终将在**await**语句的消费者端触发:

```cs
public class DeletionNotifier : IDisposable
{
   private TaskCompletionSource<FileSystemEventArgs> _tcs;
   private FileSystemWatcher _watcher;
   public DeletionNotifier()
   {
      var path = Path.GetFullPath(".");
      Console.WriteLine($"Observing changes in path: {path}");
      _watcher = new FileSystemWatcher(path, "*.txt");
      _watcher.Deleted += (s, e) =>
      {
         _watcher.EnableRaisingEvents = false;
         _tcs.SetResult(e);
      };
      _watcher.Error += (s, e) =>
      {
         _watcher.EnableRaisingEvents = false;
         _tcs.SetException(e.GetException());
      };
  }
  public Task<FileSystemEventArgs> WhenDeleted()
  {
    _tcs = new TaskCompletionSource<FileSystemEventArgs>();
    _watcher.EnableRaisingEvents = true;
    return _tcs.Task;
  }
  public void Dispose() => _watcher.Dispose();
}
```

每次调用**WhenDeleted**方法时，都会创建一个新的完成源，启动文件监视程序，并将负责通知的**任务**返回给客户端。

从消费者的角度来看，这个解决方案很棒，因为它消除了任何复杂性:

```cs
var dn = new DeletionNotifier();
var deleted = await dn.WhenDeleted();
Console.WriteLine($"Deleted: {deleted.Name}");
```

这种解决方案的缺点是一次只能检测到单个删除。

此外，由于**Deleted**事件中的代码关闭了通知，因此在循环中调用**WhenDeleted**方法可能会导致缺失删除。

但我们可以解决这个问题! 稍微复杂一点的解决方案是在线程安全的队列中缓冲事件，并通过将可用事件(如果有的话)从队列中退出来更改**WhenDeleted**方法策略。

以下是修改后的代码:

```cs
public class DeletionNotifier : IDisposable
{
  private TaskCompletionSource<FileSystemEventArgs> _tcs;
  private FileSystemWatcher _watcher;
  private ConcurrentQueue<FileSystemEventArgs> _queue;
  private Exception _error;
  public DeletionNotifier()
  {
    var path = Path.GetFullPath(".");
    Console.WriteLine($"Observing changes in path: {path}");
    _queue = new ConcurrentQueue<FileSystemEventArgs>();
    _watcher = new FileSystemWatcher(path, "*.txt");
    _watcher.Deleted += (s, e) =>
    {
      _queue.Enqueue(e);
      _tcs.TrySetResult(e);
    };
    _watcher.Error += (s, e) =>
    {
      _watcher.EnableRaisingEvents = false;
      _error = e.GetException();
      _tcs.TrySetException(_error);
    };
    _watcher.EnableRaisingEvents = true;
  }
  public Task<FileSystemEventArgs> WhenDeleted()
  {
    if (_queue.TryDequeue(out FileSystemEventArgs fsea))
      return Task.FromResult(fsea);
    if (_error != null)
      return Task.FromException<FileSystemEventArgs>(_error);
    _tcs = new TaskCompletionSource<FileSystemEventArgs>();
    return _tcs.Task;
  }
  public void Dispose() => _watcher.Dispose();
}
```

同样，我们可以通过任务库工具来解决这个问题。 根据用例的不同，此策略每次都需要重新创建一个新的**TaskCompletionSource<T>**，而且由于是一个引用类型，它可能会影响受垃圾收集影响的性能。 如果需要重用相同的通知对象，可以通过创建自定义通知对象来实现。

事实上，**await**关键字只需要一个实现**GetAwaiter**方法的对象，返回一个实现**INotifyCompletion**接口的对象。 这个对象，反过来，必须实现一个**IsCompleted**属性和所有必需的机器来模拟**TaskCompletionSource**行为。

在*进一步阅读*部分，你会发现一篇有趣的文章*，等待微软官方博客对这个主题进行深入探讨的文章*。

## 同步上下文

根据我们正在编写的应用程序，并非所有线程都是相等的。 桌面应用程序有一个主线程，它是唯一允许在屏幕上绘制和处理图形控件的主线程。 GUI 库围绕消息队列的概念工作，每个请求都在其中发布。 主线程负责将这些消息排出队列，并将它们分派到实现所需行为的用户定义处理程序中。

每当在与 UI 不同的线程上发生一些事情时，就必须发生封送操作，这将导致在主线程管理的队列中发布消息。 在 UI 线程中编组消息的两个流行示例是**Control。 在 Windows 窗体应用程序的上下文中调用**和**Dispatcher。 调用窗口表示基础**。

信息框

WPF 的第一个预发布版本是多线程的。 但是代码的复杂性要求用户处理多线程，而随之而来的用户代码中可能出现的 bug 也大大提高了门槛。 甚至许多 c++库，如 DirectX 和 OpenGL，也大多是单线程的，以减少复杂性。

在服务器端，ASP。 NET 应用程序也有主线程的上下文，但不止一个——事实上，每个用户的请求都有自己的主线程。

**SynchronizationContext**是一个抽象的基类，它定义了在*特殊*线程上下文中提供某些代码执行的标准方法。 这不是魔法; 实际上，正在执行的代码是在 lambda 中定义并在队列中发布的。 在主线程上，基础设施提供的一些代码将 lambda 从队列中取出并在其上下文中执行它。

这种自动编组是至关重要的,因为执行任何异步方法后,如从互联网上下载一个图像,你想避免调用**调用方法需要元帅结果回主线程,这是需要以更新用户界面返回的数据。**

每次等待某个异步操作时，生成的代码都会注意*捕获当前**SynchronizationContext**，并确保在该特定线程上执行延续。 基本上，您不需要做任何事情，因为基础结构已经为您做了。*

我们做了什么? 不完全是，因为有些时候这种情况不会发生。 根据我们所说的，下面例子中的三个 id 应该都是相同的:

```cs
public async Task AsyncTest1()
{
    Console.WriteLine($"Id: {Thread.CurrentThread.ManagedThreadId}");
    await Task.Delay(100);
    Console.WriteLine($"Id: {Thread.CurrentThread.ManagedThreadId}");
    await Task.Delay(100);
    Console.WriteLine($"Id: {Thread.CurrentThread.ManagedThreadId}");
}
```

但情况并非如此，因为它是一个控制台应用程序，默认情况下不设置任何同步上下文。 这样做的原因在微软的**控制台**类文档中。 您将在文档页面的末尾看到*线程安全性*部分，说明*这种类型是线程安全的*。 换句话说，没有理由回到原来的线程。

如果您转而创建一个新的 Windows 窗体应用程序，并在一个按钮单击处理程序中调用该代码，您将看到由于**SynchronizationContext**，ID 总是相同的。

理解异步代码在线程方面发生了什么总是很重要的，因为有时将结果编组回主代码并不合适，因为编组会影响性能。 例如，库开发人员在编写异步代码时必须非常小心，因为他们无法知道他们的代码是否会在存在或不存在同步上下文的情况下执行。

一个明显的例子是库开发人员处理来自网络的数据块。 每个块都是通过异步 HTTP 请求获取的，块的数量可能非常高，如下例所示:

```cs
public async Task AsyncLoop()
{
    Console.WriteLine($"Id: {Thread.CurrentThread.ManagedThreadId}");
    byte[] data;
    while((data = await GetNextAsync()).Length > 0)
    {
        Console.WriteLine($"Id: {Thread.CurrentThread.ManagedThreadId}");
        // process data
    }
}
```

除非处理代码将与 UI 交互(或任何与主线程相关的东西)，禁用同步上下文绝对是一个性能增益，并且非常容易做到:

```cs
public async Task AsyncLoop()
{
    Console.WriteLine($"Id: {Thread.CurrentThread.ManagedThreadId}");
    byte[] data;
    while((data = await GetNextAsync().ConfigureAwait(false)).Length > 0)
    {
        Console.WriteLine($"Id: {Thread.CurrentThread.ManagedThreadId}");
        // process data
    }
} 
```

通过应用**使用 ConfigureAwait**方法的异步方法,操作的结果将不会回到主线程,和生成的延续将在辅助线程上执行(每当异步操作将在一个不同的线程)。

这种经过修改的行为有两个后果:

*   在主线程队列中发布消息会产生*性能影响*。 例如，库开发人员在进行一些内部工作以提高性能时，可能希望将**ConfigureAwait**设置为**false**。
*   当您决定使用**Wait**方法或**Result**属性同步执行异步方法时，可能会发生*死锁*。 之所以会发生这种情况，是因为同步上下文将执行发回给繁忙的主线程。 虽然应该避免这种情况的发生,不要使用**等**和【显示】结果,另一种方法是使辅助线程上调用完成执行通过设置**使用 ConfigureAwait**【病人】错误。

请注意，如果您确实想在辅助线程上继续执行，请确保将**ConfigureAwait**应用于以下所有调用。 事实上，没有**ConfigureAwait**执行的第一个异步调用将导致执行返回到主线程。

因为下面的代码**ConfigureAwait**是在次要线程上执行的，所以要记住手动封送回主线程以避免竞争条件。 例如，要更新 UI，您必须调用相关的*Windows 窗体*或*WPF***Invoke**方法。

任务范式是编程语言中的一场革命，如果没有新的语言关键字和编译器生成魔术的帮助，它就不可能存在。 这个新特性在其他语言中也产生了巨大的共鸣。 例如，ECMAScript 2017 通过提供承诺和 async/await 关键字支持采用了这些概念。

在这漫长的一章中，我们了解了异步编程的重要性，以及 Task Library 如何使异步代码变得直观和易于编写，同时又不强迫我们过多地关注隐含的复杂性。 除了对这些工具有一个大致的了解之外，现在重要的是要进行试验并深入了解每个方面，以便掌握这些技术。

# 总结

在本章中，我们讨论了任何开发人员都可以用来利用多线程和异步编程技术的最重要的工具。

构建块是允许代码在不同的执行上下文中运行的基本抽象，而不管它们当前运行在哪个操作系统上。 必须巧妙地使用这些原语，但与本地语言和库相比，这并不会以任何方式限制开发人员的可能性。

此外，当涉及到与所有那些本质上是异步的事件交互时，任务范例提供了一种自然的方法。 命名空间**System.Threading.Tasks**提供了与异步现象交互所需的所有抽象。

图书馆已经被广泛地重组和扩大以支持任务范式。 最重要的是，该语言提供了**async**和**await**关键字来打破复杂性，使异步世界像过程代码一样流动。

在下一章中，我们将学习文件、文件流和序列化的概念。

# 测试你所学的内容

1.  如果要运行一个 cpu 密集型的、持久的算法，那么在手动创建线程时，您会采用哪种策略，使用任务库还是使用线程池?
2.  命名一种性能同步技术，它可以用来写入文件并在内存中增加一个整数值。
3.  应该使用什么方法将执行暂停 100 毫秒，为什么?
4.  要等待多个异步操作产生的结果，您应该做什么?
5.  如何创建等待 CLR 事件的任务?
6.  对于签名中有**Task**但不使用任何异步方法的方法，应该返回什么?
7.  如何创建长时间运行的任务?
8.  一个按钮点击处理程序正在对互联网进行异步访问以加载一些数据。 应该使用**Control 吗? 调用**来更新屏幕上的结果? 为什么?
9.  在**Task**上评估**ConfigureAwait**方法使用的原因是什么?
10.  你是否可以在使用**ConfigureAwait(false)**后直接更新 UI ?

# 进一步阅读

*   Benchmark 是一个非常强大的库，可以用来度量某些代码的性能。 NET([https://benchmarkdotnet.org/articles/overview.html](https://benchmarkdotnet.org/articles/overview.html))，微软内部也使用它来优化运行时和核心库。
*   如果您想构建自己的*可等待*对象，那么您不能错过微软团队的这篇描述底层基础结构如何工作的文章:[https://devblogs.microsoft.com/pfxteam/await-anything/](https://devblogs.microsoft.com/pfxteam/await-anything/)。
*   要深入了解关于同步上下文和**ConfigureAwait**的更多细节，您可以阅读以下文章:[https://devblogs.microsoft.com/dotnet/configureawait-faq/](https://devblogs.microsoft.com/dotnet/configureawait-faq/)。*********