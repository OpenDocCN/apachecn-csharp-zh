# 评估

# 第一章

1.  C# 语言的第一个版本 1.0 于 2002 年发布，与.NET Framework 1.0 和 Visual Studio . net 2002 捆绑在一起。 在撰写本书时，该语言的当前版本是 C# 8。
2.  CLI 是一种规范，它描述了如何在不同的计算机平台上使用运行时环境，而无需针对特定的架构进行重写。 CLI 描述四个主要组件:**常见的类型系统**(**CTS),**公共语言规范**(**CLS**),【显示】虚拟执行系统**(**类型),和程序的元数据的结构和内容。**
3.  CIL 是一种平台中立的中间语言，它表示 CLI 定义的中间语言二进制指令集。 编译程序源代码时，编译器将其转换为 CIL 字节码并生成 CLI 程序集。 当 CLI 程序集被执行时，字节码通过即时编译器来生成本机代码，然后由计算机的处理器执行。
4.  若要查看程序集的内容，必须使用反汇编程序。 反汇编程序的例子有.NET Framework 发行的 ildasm.exe，或者 ILSpy，一个开源的.NET 汇编浏览器和反编译器。
5.  公共语言运行库是。 NET Framework 中 ve 的实现。 CLR 提供诸如内存管理、类型安全、垃圾收集、异常处理、线程管理等服务。
6.  BCL 是标准库的一个组件，它提供了表示 CLI 内置类型、简单文件访问、自定义属性、字符串处理、格式化、集合、流等的类型。
7.  目前主要的.NET 框架有.NET Framework、.NET Core 和 Xamarin。 因为微软计划让.NET Core 成为构建桌面、服务器、web、云和移动应用的唯一框架; . net 框架处于维护模式，只包括安全更新。
8.  程序集是用于部署、版本控制和安全性的基本单元。 它们有两种形式:可执行文件(**.exe**)和动态链接库(**.dll**)。 程序集是类型、资源和元信息的集合，它们构成一个逻辑功能单元。 程序集的标识由名称、版本、区域性和公钥标记组成。
9.  GAC 是一个机器范围的代码缓存，它允许在应用之间共享程序集。 它的默认位置是**%windir%\Microsoft。 NET\程序集**。 运行时包商店相当于.NETCore应用。 它支持更快的部署和更低的磁盘空间要求。 通常，这个存储在 macOS 和 Linux 上的**/usr/local/share/dotnet/store**中，在 Windows 上的**C:/Program Files/dotnet/store**中。
10.  为了编译和执行，C# 程序必须包含一个包含名为**Main()**的静态方法的类。

# 第二章

1.  内置的积分类型在 C# 中**字节**,**sbyte**,**ushort**,**,【显示】使用 uint,**int**,【病人】ulong,**。****
*****   **浮点**和**双**类型表示小数部分使用 2 的逆幂。 因此，它们不能准确地表示像 1.23 或 19.99 这样的数字，而只是它们的近似值。 **double**有 15 位精度，而**float**只有 7 位精度; 执行重复计算时，精度损失会累积。 十进制**类型使用实数的十进制表示，它的计算速度要慢得多，但提供了更好的精度。 十进制**类型有 28 位精度，适用于各类应用，如金融应用，这是关键。*********   字符串可以使用**+**操作符进行连接。 除了拼接之外，还可以使用**string . format()**静态方法或字符串插值(这是该方法的一种语法快捷方式)来组合字符串。*   一些字符在字符串中有特殊的含义。 这些被称为转义序列，并以反弹(**\**)作为前缀。 例如单引号(**\'**)、双引号(**\"**)、换行符(**\n**)和反斜杠(**\**)。 逐字字符串是前缀为**@**令牌的字符串。 对于逐字字符串，编译器不解释转义序列。 例如，这使得编写多行文本或文件路径更加容易。*   隐式类型变量是使用**var**关键字声明的，而不是实际的类型，并且必须在声明期间初始化。 编译器从用于初始化的值或表达式中推断实际的类型。*   值类型和引用类型是 C# 和.NET 中类型的两个主要类别。 值类型的变量直接存储值。 引用类型的变量存储对包含实际对象的内存位置(地址)的引用。 值类型具有值语义(简单地说，当您复制一个对象时，它的值也会被复制)，而引用类型具有值语义(当您复制一个对象时，它的引用也会被复制)。 通常，值类型存储在堆栈上，引用类型存储在堆上，但这是实现细节，而不是类型的特征。*   装箱是将值类型存储在**对象**中的过程，而解装箱是将**对象**的值转换为值类型的相反操作。*   可空类型是**System 的实例。 可为空的<T>**，一种泛型值类型，它可以表示只能为值类型的底层**T**类型的值，以及一个额外的空值。 一个可为空的整数变量可以声明为**可为空的<int>**或**int?** 。*   C# 中有三种类型的数组。 第一种类型是一维数组，即一维数组。 例如**int[6]**，它是一个由 6 个整数组成的数组。 第二种类型是多维数组，这是两个或更多维度的数组，最多 32 个维度。 例如**int[2,3]**，这是一个包含 2 行 3 列的整数数组。 第三种类型是锯齿数组，它是数组的数组。 交错数组是一维数组，其元素是其他数组，每个数组可以是另一个维度。*   系统定义的类型转换是隐式转换(如从**int**到**double**)和显式转换(如从**double**到**int**)。 显式类型转换也称为强制类型转换，当两种类型之间的转换有丢失信息的风险时，这种转换是必要的。 用户定义转换可以通过为特定类型定义隐式或显式操作符或使用 helper 类来实现。********

 ********# 第三章

1.  在 C# 语言中，如果和**切换**，则选择语句为**。**
2.  **switch**语句的**默认**情况可以出现在列表的任何位置。 它总是在所有的案例标签被评估之后进行评估。
3.  **for**循环允许我们执行一个布尔表达式为 true 的代码块。 **foreach**循环允许我们遍历实现**IEnumerable**接口的集合中的元素。
4.  **while**回路是一个入口控制回路。 这意味着，只要指定的布尔表达式的计算结果为 true，它就会执行一个语句块。 在执行块之前检查表达式。 **do-while**循环是一个出口控制循环。 这意味着在循环结束时将检查布尔表达式。 这确保了**do-while**循环将总是至少执行一次，即使条件在第一次迭代中计算结果为 false。
5.  要从函数返回，可以使用**return**、**yield**或**throw**。 前两个表示正常返回。 **throw**语句表示由于执行流中的错误情况而返回。
6.  **break**语句可用于从**switch**case 中退出或终止循环的执行。 它适用于所有循环:的**，**while**，**do-while**和**foreach**。**
7.  它表示方法、操作符或**get**访问器(它出现在**return**或**break**语句之前)是一个迭代器。 迭代器方法返回的序列可以使用**foreach**语句来使用。 yield**yield**语句可以在生成值时返回值，在可用时使用它们，这在异步上下文中特别有用。
8.  你可以从函数调用捕获所有的异常与**(异常),在这种情况下,你可以访问的信息异常,或用一个简单的**抓住**声明(不指定一个异常类型),在这种情况下,你不会得到任何关于异常的信息。**
***   **finally**块包含将在**try**部分之后执行的代码。 这种情况不管执行恢复正常或控制了**试块,因为**,【显示】继续**,**goto**,或【病人】返回语句。*****   . net 中所有异常类型的基类是**系统。 例外**类。****

 ****# 第四章

1.  类是指定对象形式的模板或蓝图。 它包含数据和对该数据进行操作的代码。 对象是类的实例。 用**class**关键字引入一个类，并定义一个引用类型。 使用**struct**关键字引入一个结构，并定义一个值类型。 与类不同，结构不支持继承，也不能有显式的默认构造函数，并且字段不能在声明期间初始化，除非它们被声明为**const**或**static**。
2.  只读字段是用**只读**指示符定义的字段。 这样的字段只能在构造函数中初始化，以后不能更改其值。
3.  表达式体定义是一种替代语法，通常用于方法和属性，它只包含对表达式求值并可能返回求值的结果。 它们的形式为**成员=>表达式**。 它们支持所有类成员，不仅是方法，还支持字段、属性、索引器、构造器和终结器。 表达式求值的结果值的类型必须匹配方法的返回类型。
4.  默认构造函数是没有任何参数的类的构造函数。 另一方面，静态构造函数是用**static**关键字定义的构造函数，它没有参数或访问修饰符，不能被用户调用。 当静态类的第一个静态成员第一次被访问时，CLR 会在静态类中自动调用静态构造函数;或者在非静态类中，当类第一次实例化时，CLR 会自动调用该构造函数。 静态构造函数对于初始化静态字段很有用。
5.  自动实现的属性是编译器将为其提供一个私有字段和**get**和**set**访问器的实现。
6.  索引器是允许像数组一样对对象进行索引的类成员。 索引器像属性一样定义了**get**和**set**访问器。 索引器没有显式名称。 它是通过使用**this**关键字创建的。 索引器具有一个或多个参数，这些参数可以是任何类型。
7.  静态类是用**static**关键字声明的类。 它只能包含静态成员，不能实例化。 使用类名而不是通过对象访问静态类成员。 静态类基本上与非静态类相同，具有私有构造函数，并且所有成员都声明为**静态**。
8.  可用的参数说明符是**ref**、**out**和中的**。 **ref**说明符修改参数，使其成为参数的别名，参数必须是变量。 它允许我们创建一个按引用调用机制，而不是隐式的按值调用机制。** 说明符中的**与此类似，它使实参通过引用传递，但不允许函数修改它。 它基本上与**只读文献**相同。 **out**关键字也定义了引用调用机制，但它需要一个函数在函数返回之前初始化一个参数。 它保证在指定的函数调用期间给变量赋值。**
9.  具有可变数量参数的方法必须具有一个以**params**关键字开头的一维数组形参。 这不必是函数的唯一参数，但必须是最后一个。
10.  枚举是一组命名的整型常量。 必须使用**枚举**关键字来声明枚举。 枚举是一种值类型。 当我们希望为某些特定目的使用有限数量的整数值时，枚举是很有用的。

# 第五章

1.  面向对象编程是一种范例，它允许我们围绕对象编写程序。 它的核心原则是抽象、封装、继承和多态。
2.  封装允许我们将类中的数据隐藏起来，不让外界知道。 封装很重要，因为它通过为不同组件定义最小的公共接口来减少它们之间的依赖关系。 它还提高了代码的可重用性和安全性，并使代码更容易进行单元测试。
3.  继承是一种机制，通过它一个类可以继承另一个类的属性和功能。 C# 支持单继承，但只支持引用类型。
4.  虚方法是在基类中有实现但可以在派生类中重写的方法，这有助于更改或扩展实现细节。 基类中的实现是用**虚拟**关键字定义的。 派生类中的实现称为覆盖方法，并使用**override**关键字定义。
5.  通过使用**密封的**关键字来声明虚拟成员，可以防止它在派生类中被重写。
6.  抽象类不能实例化，这意味着我们不能创建抽象类的对象。 抽象类是使用**抽象**关键字声明的。 它们可以同时具有抽象和非抽象成员。 抽象成员不能是私有的，也不能有实现。 一个抽象类必须为它实现的所有接口(如果有的话)的所有成员提供一个实现。
7.  接口定义了一个由实现该接口的所有类型支持的契约。 接口是通过**interface**关键字引入的类型，它包含一组成员，必须由实现该接口的任何类或结构实现。 通常，接口只包含成员的声明，而不包含实现。 从 C# 8 开始，接口可以包含默认方法。
8.  有两种类型的多态性:编译时多态性(以方法重载表示)和运行时多态性。 运行时多态性有两个方面。 一方面，派生类的对象可以无缝地用作数组或其他类型集合、方法参数和其他地方的基类的对象。 另一方面，类可以定义可以在派生类中重写的虚方法。 在运行时，CLR 将调用与该对象的运行时类型对应的虚拟成员的实现。 当派生类的对象在基类对象的位置中使用时，对象的声明类型和运行时类型有所不同。
9.  重载方法是具有相同名称但具有不同类型或不同数量参数的方法。 方法重载不考虑返回类型。 操作符也可以重载。 当一个或两个操作数都属于该类型时，类型可以为可重载操作符提供自定义实现。 关键字**操作符**用于声明操作符。 这些方法必须是**public**and**static**。
10.  坚实的原则是:**单一责任原则(S)**,**启闭原理(O)**、**Liskov 替换原则(L)**,**接口隔离原则(我)**和【显示】依赖注入原理(D)。

# 第六章

1.  泛型是用其他类型参数化的类型。 泛型提供了可重用性，提高了类型安全性，并且可以提供更好的性能(通过避免对值类型进行装箱和拆箱)。
2.  用于参数化泛型类型或方法的类型称为类型参数。
3.  泛型类的定义方式与非泛型类相同，但有一个或多个类型参数的列表，在类名后的尖括号中指定(例如**<T>**)。 对于泛型方法也是如此; 类型参数在类名之后指定。
4.  类可以从泛型类型派生。 结构不支持显式继承，但它们可以实现任意数量的泛型接口。
5.  构造类型是通过用实际类型替换类型参数而从泛型类型构造的类型。 例如，对于一个**Shape<T>**generic 型，**Shape<int>**是一个构造型。
6.  协变类型参数是用**out**关键字声明的类型参数。 这样的类型参数允许接口方法具有比指定类型参数更派生的返回类型。
7.  逆变类型参数是用关键字中的**声明的类型参数。 这样的类型参数允许接口方法具有比指定类型参数派生更少的参数。**
8.  类型参数约束是为类型参数指定的限制，它通知编译器类型参数必须具有什么样的功能。 应用约束限制了可用于从泛型构造类型的类型。
9.  **new()**类型约束指定类型必须提供一个公共默认构造函数。
10.  C# 8 中引入的类型参数约束是**notnull**。 它只能在可为空的上下文中使用，否则编译器会生成一个警告。 它指定类型参数必须是非空类型。 它可以是一个不可为空的引用类型(在 C# 8 中)或一个不可为空的值类型。

# 第七章

1.  包含泛型集合的 BCL 名称空间为**System.Collections.Generic**。
2.  为泛型集合定义功能的所有其他接口的基本接口是**IEnumerable<T>**。
3.  泛型集合优于非泛型集合，因为它们提供了类型安全的好处，对值类型具有更好的性能(因为它们避免了装箱和拆箱)，而且在某些情况下，它们提供了非泛型集合中不可用的功能。
4.  **List<T>**泛型类表示可以被其索引访问的元素集合。 列表<T>与数组非常相似，不同之处是集合的大小不是固定的，而是可变的，它可以随着添加或删除元素的增加或减少。 您可以使用**add()**、**AddRange()**、**Insert()**和**InsertRange()**添加元素。 您可以使用**remove()**，**RemoveAt()**，**RemoveRange()**，**RemoveAll()**，以及**Clear()**来移除元素。
5.  **Stack<T>**泛型类代表一个后进先出语义的集合。 使用**Push()**方法将元素添加到顶部，使用**Pop()**方法将元素从顶部移除。
6.  **Queue<T>**泛型类表示一个具有先进先出语义的集合。 方法的作用是:**Dequeue()**从队列前面移除并返回项目。 **Peek()**方法从队列的前面返回项目，而不删除它。
7.  **LinkedList<T>**泛型类表示一个双链表。 其元素为**LinkedListNode<T>**类型。 要向链表添加元素，可以使用**AddFirst()**、**AddLast()**、**AddAfter()**和**AddBefore()**方法。
8.  **Dictionary<TKey, TValue>**泛型类表示一个键值对集合，允许基于键进行快速查找。 这个字典类的元素属于**KeyValuePair<TKey, TValue>**类型。
9.  **HashSet<T>**泛型类表示一组不同的项，这些项可以按任意顺序存储，但它们是连续存储的。 哈希集在逻辑上类似于一个字典，其中值也是键。 然而，不像**Dictionary<TKey, TValue>**，**HashSet<T>**是一个非关联容器。
10.  **BlockingCollection<T>**是一个实现了由**IProducerConsumerCollection<T>T3】接口定义的生产者-消费者模式的类。 它实际上是一个简单的包装在**<IProducerConsumerCollection T>**界面,没有内部底层存储,但必须提供一个(一个集合实现**【t16.1】IProducerConsumerCollection T>**界面)。 如果没有提供实现，它默认使用**ConcurrentQueue<T>**类。 它适用于需要包围和阻塞的场景。**

# 第八章

1.  回调是一个函数(或者更普遍地说，任何可执行代码)，它作为一个参数传递给另一个函数，以便立即(同步回调)或稍后(异步回调)被调用。 委托是强类型的回调。
2.  委托是使用**delegate**关键字定义的。 该声明看起来像一个函数签名，但编译器实际上引入了一个类，该类可以保存对其签名与委托签名匹配的方法的引用。 事件是用**event**关键字声明的委托类型的变量。
3.  在 C# 中有两种元组:引用元组，由**系统表示。 元组**类和值元组，由**系统表示。 值元组**结构。 引用元组最多只能容纳 8 个元素，而后者可以容纳任意数量的元素序列，尽管至少需要两个元素。 值元组可以具有编译类型的命名字段，并且具有更简单但更丰富的语法来创建、赋值、解构和比较值。
4.  命名元组是具有字段名称的值元组。 这些名称是字段**Item1**、**Item2**等的同义词，但仅在源代码级别可用。
5.  模式匹配是检查一个值是否具有特定形状，并在匹配成功时从值中提取信息的过程。 它可以与**是**和**互换**表达。
6.  空值不匹配类型模式，无论变量的类型是什么。 可以将模式匹配为 null 的**开关**case 标签添加到具有类型模式匹配的**开关**表达式中，以专门处理空值。 当使用**var**模式时，总是匹配空值。 因此，当使用**var**模式时，您必须添加显式的空检查，因为值可能为空。
7.  . net 类提供了对使用正则表达式的支持，它是来自**system . text . regularexpression**命名空间的**Regex**类。 默认情况下，它使用 UTF-8 编码来匹配字符串。
8.  **Match()**方法检查输入字符串是否匹配正则表达式，并返回第一个匹配。 **Matches()**方法执行相同的搜索，但返回所有匹配。
9.  扩展方法是在不更改源代码的情况下扩展类型的功能的方法。 它们很有用，因为一般来说，它们允许在不更改实现、创建派生类型或重新编译代码的情况下进行扩展。
10.  扩展方法被定义为静态、非嵌套、非泛型类的静态方法，它们的第一个参数是它们所扩展的类型，前面是**this**关键字。

# 第九章

1.  堆栈是编译器分配的一个相对较小的内存段，用于跟踪运行应用所需的内存。 堆栈具有**后进先出语义，当程序执行调用函数或从函数返回时，堆栈会增长或收缩。 另一方面，堆是程序在运行时用来分配内存的一大块内存，在.NET 中，它由 CLR 管理。 值类型的对象通常在堆栈上分配，而引用类型的对象在堆上分配。**
***   托管堆有三个内存段，称为代。 它们被命名为第 0、1 和 2 代。 第 0 代包含较小的、通常存在时间较短的对象，比如局部变量或为函数调用的生命周期实例化的对象。 第 1 代包含从第 0 代开始的内存垃圾回收中幸存下来的小对象。 第 2 代包含存活时间较长的小对象(它们在第 1 代的内存垃圾收集中幸存下来)和大对象(它们总是在这个段上分配)。*   垃圾收集有三个阶段。 首先，垃圾收集器构建所有活动对象的图，以便找出哪些对象仍在使用，哪些对象可能被删除。 其次，对将被压缩的对象的引用将被更新。 第三，删除死对象，并压缩幸存的对象。 通常，包含大对象的大对象堆没有进行压缩，因为移动大数据块会导致性能损失。*   终结器是类的一种特殊方法(与类具有相同的名称，但前缀为**~**)，它应该处理类拥有的非托管资源。 此方法在对象被收集时由垃圾收集器调用。 这个过程是不确定性的，这是最终处理和处理之间的关键区别。 后者是在显式调用**Dispose()**方法(对于实现**可删除**接口的类)期间发生的一个确定性过程。*   **GC.SuppressFinalize()**方法请求 CRL 不调用指定对象的终结器。 这通常在实现**可删除**接口时调用，这样非托管资源就不会被处理两次。*   **可删除**是一个接口，它只有一个名为**Dispose()**的方法，该方法定义了对象的确定性处置模式。*   使用语句的**表示对实现**可删除**接口的类型的对象进行确定性处理的简写语法。 使用**using**语句为语句中定义的变量引入一个作用域，并确保在退出作用域之前正确地处理了对象。 实际的处理细节取决于资源是值类型、可空值类型、引用类型还是动态类型。***   在 C# 中，可以使用平台调用服务(Platform Invocation Services)或 P/Invoke 来调用本地 DLL 中的函数。 为此，必须定义一个与本机函数的签名相匹配的**静态****extern**方法(为其参数使用等效的托管类型)。 这个托管函数必须使用**DllImport**属性进行修饰，该属性定义运行时调用本机函数所需的信息。*   不安全代码是 CLR 无法验证其安全性的代码。 不安全代码支持使用指针类型并支持指针算术。 不安全的代码不一定是危险的，但确保不引入指针错误或安全风险是您的全部责任。 使用不安全代码的典型场景是调用从本地 DLL 或 COM 服务器导出的函数，这些函数需要指针类型作为参数，并在性能至关重要的地方优化一些算法。*   不安全代码是用**不安全**关键字定义的，它可以应用于类型(类、结构、接口和委托)、类型成员(方法、字段、属性、事件、索引器、操作符、实例构造函数和静态构造函数)和语句块。**

 **# 第十章

1.  函数式编程的主要特征是不变性(对象具有不变的状态)和无副作用函数(函数不修改其局部作用域之外的值或状态)。 函数式编程的优点包括:首先，代码更容易理解和维护，因为函数不会改变状态，只依赖于它们接收的参数。 其次，出于同样的原因，代码更容易测试。 第三，实现并发更简单、更有效，因为数据是不可变的，函数也没有副作用，这就避免了数据竞争。
2.  高阶函数是接受一个或多个函数作为参数、返回一个函数或两者兼备的函数。
3.  C# 提供了将函数作为参数传递、从函数中返回函数、将函数赋值给变量、将它们存储在数据结构中、定义匿名函数、嵌套函数以及测试对函数的引用是否相等的能力。 所有这些特点使得 C# 成为一种将函数视为头等公民的语言。
4.  Lambda 表达式是编写匿名函数的一种方便方式。 这是一个代码块，可以是一个表达式，也可以是一个或多个语句，它们的行为类似于一个函数，可以被分配给一个委托。 因此，lambda 表达式可以作为参数传递给函数，也可以从函数返回。 它们是编写 LINQ 查询、将函数传递给高阶函数(包括应该由**Task.Run()**异步执行的代码)和创建表达式树的一种方便的方法。 lambda 表达式有两个部分，由 lambda 声明操作符**=>**分隔。 左边部分是参数列表，右边部分是表达式或语句。 lambda 表达式的一个例子是**n =>n%2==1**。
5.  在 lambda 表达式中应用于变量作用域的规则如下:首先，在 lambda 表达式中引入的变量在 lambda 之外是不可见的。 其次，lambda 不能从封闭方法的、**ref**或**中捕获**参数。 第三，lambda 捕获的变量不会被垃圾收集，直到 lambda 分配给的委托被垃圾收集，即使它们本来会超出范围。 第四，也是最后一点，lambda 表达式的 return 语句仅引用 lambda 所表示的匿名方法，而不会导致外围方法返回。****
6.  LINQ 是一组技术，它使开发人员能够以一致的方式查询大量数据源。 LINQ 标准查询操作符是一组扩展方法，它们对实现**IEnumerable<T>**或**IQueryable<T>**的序列进行操作。 LINQ 查询语法基本上是标准查询操作符的语法糖。 编译器将用查询语法编写的查询转换为使用标准查询操作符编写的查询。 查询语法比标准查询操作符更简单、更易于阅读，但它们在语义上是等价的。 然而，并不是所有标准查询操作符在查询语法中都具有等价的内容。
7.  **Select()**方法将序列的每个元素投影到一个新形式中。 这需要一个选择器，它是一个转换函数，为集合中的每个元素生成一个新值。 但是，当集合的元素本身是集合时，通常需要将它们平展为单个集合。 这就是**SelectMany()**方法所做的。
8.  偏函数应用是取带有*N*参数和一个参数的函数，将参数固定为函数的其中一个参数后返回另一个带有*N-1*参数的函数的过程。 这种技术与套用相反，套用是取一个带有*N*参数的函数，并将其分解为*N*函数，这些函数只带一个参数。
9.  单类是一种代数结构，它只有一个结合的二元运算和一个单位元素。 任何具有这两个元素的 C# 类型都是单一类。
10.  一个单子是一个容器，封装了一些功能上的价值，它包装。 一个单节点有两个操作:第一个是将一个值**v，**转换为一个容器(**v ->C(v)**)。 在函数式编程中，这个函数被称为 return。 第二个是将两个容器压扁成一个容器(**C(C(v)) ->C(v)**)。 在函数式编程中，这被称为绑定。 一个单子的例子是**IEnumerable<T>**使用 LINQ 查询操作符**SelectMany()**。

# 第十一章

1.  . net 中的部署单元是程序集。 程序集是一个文件(可执行文件或动态链接库)，其中包含 MSIL 代码以及关于程序集内容的元数据，以及资源(可选)。
2.  反射是运行时类型发现和更改它们的能力的过程。 这意味着我们可以在运行时检索关于类型、它们的成员和它们的属性的信息。 反射使轻松构建可扩展应用成为可能; 执行私有的类型和成员或具有其他访问级别的成员，否则无法访问它们，这对测试很有用; 在运行时修改现有类型或创建全新的类型并使用它们执行代码; 通常，在运行时更改系统行为，通常使用属性。
3.  提供类型元信息的类型是**System。 类型**。 可以使用**GetType()**方法、**type .GetType()**静态方法或 C#**typeof**操作符创建该类型的实例。
4.  一个共享程序集被几个应用使用，通常位于**全局程序集缓存(GAC)**下，这是一个程序集的系统存储库。 私有程序集旨在供单个应用使用，并存储在应用目录或其一个子目录中。 共享程序集必须被强命名并强制执行版本约束; 这些要求对于私有程序集不是必需的。
5.  在.NET 中，程序集可以在以下上下文之一中加载: load 上下文(包含从 GAC、app 目录或其子目录加载的程序集)、load-from 上下文(包含从前面提到的其他路径加载的程序集)、仅反射上下文(包含仅为反射目的加载的程序集)、 或者根本没有上下文(例如从字节数组加载程序集时)。
6.  早期绑定是在编译期间创建程序集依赖项(引用)的过程。 这为编译器提供了对程序集中可用类型的完全访问权。 后期绑定是在运行时加载程序集的过程，在这种情况下，编译器无法访问程序集的内容。 然而，这对于构建可扩展应用很重要。
7.  动态语言运行时是.NET 平台的一个组件，它定义了一个运行时环境，该环境在 CLR 之上添加了一组服务，以便使动态语言能够在 CLR 上运行，并向静态类型语言添加动态特性。
8.  **动态**类型是静态类型，这意味着该类型的变量在编译时被赋为**动态**类型。 但是，它们忽略了静态类型检查。 这意味着对象的实际类型只在运行时知道，编译器不能知道也不能强制对该类型对象执行的操作进行任何检查。 你可以用任何参数调用任何方法，编译器不会检查和抱怨; 但是，如果操作无效，将在运行时抛出异常。 当互操作程序集不可用时，通常使用**动态**类型来简化 COM 对象的使用。
9.  属性是派生自**系统的类型。 属性**抽象类，并提供关于程序集、类型和成员的元信息。 这些元信息由编译器、CLR 或使用反射服务读取它们的工具使用。 属性在方括号中指定，例如在**[SerializableAttribute]**中。 属性的命名约定是类型名称总是以单词**Attribute**作为后缀。 C# 语言提供了一个语法快捷方式，允许指定没有**属性**后缀的属性的名称，例如**[Serializable]**。
10.  要创建用户定义的属性，必须从**系统派生。 属性**类型，并遵循在类型后面加上单词**属性**的命名约定。

# 第十二章

1.  当您需要执行一些长时间运行的 cpu 密集型代码时，手动创建一个专用线程是首选。 另一个选项是用**TaskCreationOptions 创建一个任务。 或者，在大多数高级场景中，编写一个自定义的任务调度程序。**
2.  大多数的性能同步技术是那些不使用内核对象而是使用用户模式对象的技术。 为了在内存中原子地写入一个文件和一些值，临界区是最合适的技术，它可以通过 C# 语言的**lock**关键字获得。
3.  **任务 延迟**API 是最合适的延迟，因为它*调度*代码在指定的毫秒数之后继续执行，让线程在此期间被重用。 相反，操作系统**Sleep**API 在.NET 中被暴露为**Thread。 Sleep**，这将在给定的毫秒数内暂停线程的执行，但它将使线程无法被重用。
4.  Task 库提供了**WaitHandle。 WaitAny**和**waitthandle。 WaitAll**方法，当*任何*或*所有*操作完成时，分别调用延续代码。 返回的任务完成后，即可访问任务结果。
5.  **TaskCompletionSource**是一个用于创建和控制**Task**的类。 它可以用于在基于任务的操作中转换任何异步行为，例如 CLR 事件。 因此，客户端代码可以等待从**TaskCompletionSource**获得的任务，而不是订阅事件。
6.  **Task**库提供了预构建的**Task。 CompletedTask**返回一个空的**Task**，而方法**Task。 从结果**，**任务。 从取消的**和**任务。 FromException**来创建返回结果、报告取消或抛出异常的任务。
7.  指定**TaskCreationOptions 可以创建长时间运行的任务。 在**任务**构造器中的 LongRunning**。
8.  需要使用**控件。 调用**(或**Dispatcher)。 在 WPF 中调用**可以通过**Control 进行验证。 InvokeRequired**(或者 WPF 中的**Dispatcher.CheckAccess()】**)，取决于用于访问资源的库是否已经在主线程中封送了结果。 如果图书馆已经接受了任务,图书馆不叫【显示】作者 Task.ConfigureAwait(假),您可以直接使用结果,因为延续执行**后等待调用**字在主 UI 线程由于同步上下文提供的框架。
9.  **ConfigureAwait**方法对于避免在进程中使用同步上下文时可能发生的无用封送操作非常有用。 这通常由 UI 框架和 ASP 创建。 网络应用。 ConfigureAwait 的主要用户是库开发人员，他们不需要访问只能从主线程使用的应用对象。
10.  您必须首先验证异步操作是否在主线程中完成(例如，通过使用**Control)。 在 Windows 窗体中调用**或在 WPF 中调用**Dispatcher.CheckAccess()**。 如果在不同的线程中完成，则需要通过**Control 访问 UI。 调用**或**Dispatcher。 调用**。

# 第十三章

1.  系统中最重要的类。 IO**名称空间处理系统对象为路径,路径****文件**和**FileInfo【T7 文件】,【显示】目录**和**DirectoryInfo**目录。
2.  连接路径的首选方法是使用**Path.Combine()**静态方法。
3.  当前用户的临时文件夹路径可以通过**path . gettemppath()**静态方法获取。
4.  **File**和**FileInfo**类提供了类似的功能，但是**File**是一个静态类，**FileInfo**是一个非静态类。 同样，**Directory**是一个静态类，而**DirectoryInfo**是一个非静态类，尽管它们的功能是相似的。
5.  要创建目录，可以使用**create()**和**CreateSubdirectory()**方法。 前者在其直接父目录存在时创建一个目录。 后者创建一个子目录以及层次结构中直到根的所有其他子目录(如果必要的话)。 要枚举目录，请使用**EnumerateDirectories()**方法，该方法在返回整个集合之前检索可以枚举的目录集合。 对于各种搜索选项有多个重载。
6.  .NET 中的流有三种类型:后备存储(表示字节序列的源或目的地的流)、装饰器(从另一个流读取或写入数据，以某种方式转换数据的流)和适配器(实际上不是流， 但是包装器帮助我们在比字节更高的级别上处理数据源)。
7.  . net 中流的基类是**System.IO.Stream**类。 这是一个抽象类，它提供了从流中读取和写入流的方法和属性。 其中许多是抽象的，在派生类中实现。
8.  默认情况下，**BinaryReader**和**BinaryWriter**都使用 UTF-8 编码处理字符串。 但是，它们都有重载的构造函数，允许使用**System.Text.Encoding**类指定另一种编码。
9.  来自**System.Xml.Serialization**命名空间的**XmlSerializer**类可以用来序列化和反序列化数据。 **XmlSerializer**通过将类型的所有公共属性和字段序列化为 XML 来工作。 它使用一些默认设置，例如类型成为节点，属性和字段成为元素。 类型、属性或字段的名称成为节点或元素的名称以及字段或属性的值及其文本。
10.  . net Core 附带的 JSON 序列化器称为**System.Text.Json**。 对于.NET Framework 和.NET Standard 项目，它可以作为一个 NuGet 包使用，名称相同。 您可以使用**JsonSerializer. serialize()**静态方法来序列化数据和**JsonSerializer。 反序列化<T>()**static 方法来反序列化数据。 您可以使用特定的属性来控制序列化过程。 另一方面，如果您想对写入或读取的内容进行更多的控制，可以使用**Utf8JsonWriter**和**Utf8JsonReader**类。

# 第十四章

1.  可能抛出异常的代码必须放在**try**块中。
2.  在**catch**块中，您可能主要想尝试恢复错误。 恢复策略可能非常不同，从向用户报告友好的错误到使用不同的参数重复操作。 日志记录是在**catch**块中完成的另一个典型操作。
3.  在**catch**块中指定的异常类型捕获匹配相同类型或任何派生类型的异常。 由于这个原因，层次结构中较低的那些必须最后指定。 在任何情况下，只要顺序不正确，C# 编译器就会生成一个错误。
4.  通过在**catch**语句中指定变量名，您可以访问异常对象。 它提供了重要的信息，比如消息和其他在记录错误时非常宝贵的信息。 在创建一个新的、更具体的异常时，异常对象也可以用作内部异常参数。
5.  在检查异常对象之后，您可能会意识到您无法做任何事情来恢复操作。 在这种情况下，更合适的做法是让异常继续反弹到调用方。 这可以通过使用无参数的**throw**语句来实现，或者通过在构造函数中传递异常对象来创建并抛出一个新的异常。
6.  **finally**块用于声明必须执行的代码块，无论**try**块中指定的代码是失败还是成功完成。
7.  当您不需要通知**try**块中代码的失败时，您可以指定一个**最后**块而不需要**catch**块。 **最后**代码将在任何情况下执行。
8.  第一次机会异常表示非常早期的异常，即在它们被抛出之后，在跳到它们的处理程序之前(如果有的话)。 调试器可能会在它们处停下来，对潜在的错误给出更准确的指示。
9.  Visual Studio 调试器允许我们选择想要停止的第一次异常。 这可以通过**异常设置**窗口来完成。
10.  在应用即将崩溃之前触发**UnhandledException**事件。 这个事件可以用来为用户提供更好的建议，记录错误，甚至自动重新启动应用。

# 第十五章

1.  通过启用 C# 8 可空引用类型特性并在代码中装饰引用类型，您将显著减少代码中出现**NullReferenceException**异常。
2.  访问数组中最后一项的简洁新语法是**[^1]**，它使用了**系统。 指标**类型。
3.  在 switch 表达式中，丢弃(**_**)字符等价于**默认的**，通常在 switch 语句中使用。
4.  C# 8 引入了异步处理特性，以便在处理资源时提供异步行为。 这样，我们可以从**DisposeAsync**方法等待异步关闭操作，从而避免了使用**任务的危险。 等待**方法内**处置**。
5.  null 合并赋值**?? =**用于避免在左侧(**命令**不为空时执行右边的赋值代码(在我们的示例中，是**GetOrders()**方法)。
6.  为了用**async foreach**迭代，序列必须表现出不能使用**IEnumerable**和**IEnumerator**接口及其通用对应接口实现的异步行为。 新**IAsyncEnumerable【病人】>**和【显示】<IAsyncEnumerator T>接口是专门设计来支持异步行为,使用**异步 foreach 语句。**

 **# 第十六章

1.  **全球。 json**文件用于确定在给定的目录树中使用哪个 SDK。 您可以使用**dotnet new globaljson**命令在解决方案根文件夹(或任何父文件夹)中创建该文件，并手动编辑它，以匹配**dotnet——info**命令返回的版本之一。
2.  **路径。 Combine**方法是在 Windows 和 Linux 上连接路径的最佳方法，因为这两种操作系统都使用不同的路径分隔符。 这种方法也可以很方便地避免连接相对路径和加倍或省略分隔符时的错误。
3.  符合.NET 标准规范的库是二进制兼容任何支持它的框架的。 当您需要在不同的框架之间共享代码时，请验证哪一个是它们所支持的.NET 标准的最新版本，并创建一个使用它的库。 如果所需的.NET Standard 版本不支持您需要使用的 api，您可以更改策略，创建单独的库，并将它们打包在一个 NuGet 包中。 包清单将需要将每个程序集关联到库可以运行的特定框架、平台或体系结构。
4.  由于有了新的项目文件格式，现在可以将所需的**packagerreference**标记从一个项目复制到另一个项目。 这也可以在 Visual Studio 中在解决方案被打开时完成，并且一旦文件被保存，NuGet 包将被自动恢复。
5.  在分析了体系结构的含义之后，第一步是将当前的解决方案升级到最新的.NET Framework 版本，至少是 4.7.2 版本。
6.  为了最小化启动时间，. net Core 3 提供了两个新的发布选项。 第一个是**AOT**编译，它立即生成汇编代码，大大减少了对**JIT**编译器的需求。 第二种方法是启用**快速 JIT**编译器，该编译器在运行时使用，比传统的**JIT**编译器更快，但生成的代码优化程度较低。

# 第十七章

1.  单元测试是一种软件测试，对单个代码单元进行测试，以验证它们是否按照设计的方式工作。 单元测试有助于在开发周期的早期识别和修复错误，因此有助于节省时间和金钱。 它帮助开发人员更好地理解代码，并允许他们更容易地进行更改。 它要求代码更加模块化，以便更好地进行测试，从而有助于代码重用。 它可以作为项目文档。 它还有助于调试，因为当测试失败时，只需要检查和调试最新的更改。
2.  用于单元测试的 Visual Studio 工具有**测试资源管理器**(您可以在其中查看、运行、调试和分析测试)、用于托管代码的 Microsoft 单元测试框架、代码覆盖工具(用于确定单元测试所覆盖的代码量)、 Microsoft Fakes 隔离框架(它允许您创建类和方法的替代品)。
3.  Visual Studio 中的**测试资源管理器**允许您查看按不同级别(项目、类等)分组的可用单元测试。 您可以从**测试资源管理器**运行和调试单元测试，并且可以查看它们的执行结果。
4.  要指定类包含单元测试，您必须使用**TestClass**属性装饰它。 包含单元测试的方法必须用**TestMethod**属性装饰。
5.  用于执行断言的类称为**Assert**，可以在**Microsoft.VisualStudio.TestTools.UnitTesting**命名空间中找到。 它包含许多静态方法,比如**AreEqual()**,**AreNotEqual()**,【显示】IsTrue(),**IsFalse()**,【病人】AreSame(),**AreNotSame()**,【t16.1】IsNull()和**IsNotNull()**。
6.  可以根据**测试资源管理器**或**Test**顶级菜单中的可用单元测试来确定代码覆盖率。 结果可以在**代码覆盖结果**窗格中找到。
7.  您可以通过提供使用**ClassInitialize**和**clascleanup**属性装饰的方法，为每个类提供一次执行的 fixture。 前者在所有测试执行之前对每个类执行一次，后者在所有测试执行之后执行一次。 对于在每个单元测试之前和之后执行的 fixture，必须提供使用**TestInitialize**和**TestCleanup**属性装饰的方法。
8.  数据驱动单元测试意味着编写从外部源(例如文件或数据库)获取测试数据的单元测试。 然后对数据源中的每一行执行一次测试方法。
9.  **DynamicData**属性允许您指定单元测试类的方法或属性作为数据源。 **DataSource**属性允许您指定外部数据源。
10.  Microsoft 单元测试框架支持的数据驱动测试的外部数据源是 SQL 数据库、CSV 文件、Excel 文档和 XML 文档。****************