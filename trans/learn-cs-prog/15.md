# *第十五章*:C# 8 的新特性

C# 是一种成熟的编程语言，但它仍在不断发展，以满足来自新兴软件架构的新需求。 C# 7 的四个语言版本中的大多数主要关注于提供在使用值类型时提供令人印象深刻的性能的工具。

在最新版本中，C# 8 引入了许多新的重要特性，主要集中在四个方面:使代码更紧凑、更易于阅读，以及性能、健壮性和表达性。 C# 8 的根本变化是它是第一个没有.NET 框架官方支持的版本，因为它的一些特性需要.NET Core 运行时增强。

在本章中，我们将介绍以下新的语言特性:

*   可以为空引用类型
*   接口成员的默认实现
*   范围和指标
*   模式匹配
*   使用声明
*   异步处理
*   结构体和 ref 结构体中的一次性模式
*   异步流
*   只读结构体成员
*   空合并作业
*   静态局部功能
*   更好的逐字插值字符串
*   在嵌套表达式中使用 stackalloc
*   非托管类型构造

在本章结束时，您将了解使用这些特性的用例，并能够在您的清单中逐步采用它们。 与往常一样，你越多地将这些特性付诸实践，你就会越快地掌握它们。

现在我们将从一个语言特性开始，这个特性可以减少基于. net 的应用崩溃的一个主要原因——**NullReferenceException**。

# 可空引用类型

在前一章中，我们了解到 C# 中的类型系统分为**引用类型**和**值类型**。 值类型在堆栈上被分配，并且每次将它们分配给一个新变量时，都会受到内存副本的影响。 另一方面，引用类型是在堆上分配的，而堆是由垃圾收集器管理的。 每次分配一个新的引用类型时，我们都会收到一个引用作为键来标识从垃圾回收器返回的已分配内存。

引用本质上是一个指针，它可以假定为特殊的空值，这是表示没有值的最简单、也是最流行的方法。 记住,而不是使用 null 值,另一个解决方案是采用特殊的体系结构模式,而在其最简单的形式,是该对象的一个实例和一个布尔字段指示对象是否有效,这是**<Nullable T>**工作。 在其他许多情况下，开发人员实际上不需要使用空值，因为对空值的验证需要大量的代码，而这些代码也会影响运行时性能。

空引用的问题是编译器不能讨论潜在的问题,因为它在句法上是正确的,但非关联化,它在运行时将导致**【得到 NullReferenceException T1】,这是第一个在世界.NET 应用崩溃的可能原因。**

让我们考虑一下有两个构造函数的简单类，其中只有第二个构造函数初始化了**_name**字段:

```cs
public class SomeClass
{
    private string _name;
    public SomeClass() { }
    public SomeClass(string name) { _name = name; }
    public int NameLength
    {
        get { return _name.Length; }
    }
}
```

当使用第一个构造函数时，**NameLength**属性将导致**NullReferenceException**。

在测试方面，这段代码突出显示了以下两种情况:

```cs
Assert.ThrowsException<NullReferenceException>(() => new SomeClass().NameLength);
Assert.IsTrue(new SomeClass("Raf").NameLength >= 0);
```

根本的问题是，我们的代码行为取决于运行时假定的值，显然，编译器无法知道我们是否会在调用默认构造函数后初始化**_name**字段。

信息框

空引用是 Tony Hoare 爵士在 1965 年发明的一个概念。 然而，在 2009 年，他后悔自己的发明，称其为*我数十亿美元的错误*[*e*(https://en.wikipedia.org/wiki/Tony_Ho](https://en.wikipedia.org/wiki/Tony_Hoare)是)。 由于不容易从框架中删除空值，可空引用类型旨在使用代码分析方法解决这个问题。

这个概念在大多数编程语言中都很普遍，包括.NET 生态系统中的所有语言。 这意味着从框架中删除空概念的任何努力都将是一个巨大的改变，可能会破坏当前的应用。 编译器可以做什么来解决这个问题? 答案是进行*静态代码分析*，这种技术用于在不运行源代码的情况下理解源代码的运行时行为。

信息框

2011 年，微软开始了一个革命性的项目，叫做**Roslyn**，几年后，这个项目成为了.NET sdk 中官方的、当前的 C# 编译器。 Roslyn 编译器的创新(其 NuGet 包被正式命名为**Microsoft。 代码分析(T3)是为通常由编译器完成的所有处理公开 api 的能力。**

传统上，编译器是黑盒，但 Roslyn 使以编程方式解析源代码、获取语法和语义树、使用访问器检索或重写特定节点以及分析源代码的语义成为可能。

您可能已经在 Visual Studio 中看到过静态代码分析，当一些代码下面的黄色灯泡或波浪符号表明某些重构或编辑器中存在潜在问题时。 这些功能可以通过编写定制的分析器来进一步扩展，这些分析器可以作为 Visual Studio 扩展或在 NuGet 包中分发。

由于静态代码分析无法知道运行时引用假定的值，它只检查所有可能的使用路径，并试图判断其中一个路径是否可能解引用(使用圆点或方括号)为空引用。 但是分析可以提出两种不同的策略，这取决于引用是否需要假设空值:

*   我们可能想要阻止引用假设空值。 在这种情况下，分析人员会建议在声明或构造时以及在任何其他赋值时进行初始化。
*   我们可能需要引用来假定空值。 在另一种情况下，分析器将验证是否有足够的空检查代码(一个**if**语句或类似的语句)，以避免任何可能对空进行解引用的路径。

这两种策略之间的选择是开发人员的选择，开发人员被要求提供额外的信息，以便编译器知道应该提供哪些反馈。

C# 8 的可空引用类型特性提供了支持这两种策略的高级静态代码分析特性，这是由于能够对引用进行注释，从而将预期的引用用法告知编译器。 为此，C# 语法得到了扩展，以提供将引用类型修饰为可能为空的能力。 在这个新规则下，前面示例类中声明的 string 字段假设引用不能为空，必须在构造时初始化:

```cs
private string _name;	// must be initialized at construction time
```

当开发人员想给编译器提示**_name**引用可能为空时，他们必须用一个问号修饰来声明:

```cs
private string? _name;
```

使用问号字符作为修饰符并不新鲜; 在 C# 2 中引入了将**可 Nullable<T>**声明缩短为**T? 由一个布尔字段将一个*值类型*包装到一个结构中，以知道一个值类型是否被设置为空。**

引用类型的问号修饰在 C# 8 中是新出现的，其含义类似，但没有涉及到包装器。 相反，这种修饰只是告知代码分析引用的预期用途的一种方式。

默认情况下，代码分析被关闭*，因为现有应用总是假定任何引用都可能是空的，并且在现有代码上默认启用它将导致代码中到处都是大量的曲线和编译器消息。*

 *请注意

当引用被修饰为问号且可为空的引用类型特性还未启用时，Visual Studio 将用绿色标记标记，提示问号功能没有生效，因为该特性还未激活。

除了问号,C# 添加**宽容运算符**,*由一个感叹号*,用于通知代码分析*原谅*声明特定的情况下。 很少使用原谅操作符，因为这意味着分析没有识别出开发人员自己知道引用不能为空的情况。 使用它的一个实际示例是，一些不安全/本机代码在托管代码中没有任何证据的情况下更改引用所指向的内存值。 在其他非常边缘的情况下，纯托管代码可能非常复杂，以至于编译器无法识别它。 我个人会选择简化代码，而不是使用宽容的操作符。

记住，在声明*引用*时要使用*问号*，而在*取消*引用时要使用*感叹号*。 下面的例子显示了一个不会从静态代码分析中进行分析的语句，并且不会提供任何反馈，因为开发人员正在做出一个强烈的承诺，即引用永远不会为空:

```cs
var len = _name!.Length;
```

值得重复的是，它应该只在极其罕见的情况下使用。

## 启用可空引用类型特性

有多种选项可以启用此功能; 这样做的原因是能够逐步适应现有代码的特性，而不会被阻塞或接收大量的消息。 每次开始新项目时，您可能希望完全启用此功能，以避免过多的麻烦，方法是打开 Visual Studio 解决方案资源管理器，双击项目节点，并编辑**.csproj**文件。 或者，您可以右键单击项目节点并从上下文菜单中选择**编辑项目文件**。

通过添加可为空的 XML 标签，该特性将在整个项目中启用，这是启动新项目时的最佳选择:

```cs
<PropertyGroup>
  <TargetFramework>netcoreapp3.0</TargetFramework>
  <Nullable>enable</Nullable>
</PropertyGroup>
```

您可以在现有的项目上做同样的事情，但编译器提供的反馈可能过多，会分散开发人员的注意力。 出于这个原因，C# 编译器提供了四个新的 pragma 指令，从而可以为选定的代码部分启用和禁用该特性。 有趣的是，restore pragma 会恢复之前定义的设置，以允许嵌套 pragma 指令:

```cs
# nullable enable
public class SomeClass
{
    private string? _name;
    public SomeClass() { }
    public SomeClass(string name) { _name = name; }
    public int NameLength
    {
        // you should see a green squiggle below _name
        get { return _name.Length; }
    }
}
# nullable restore
```

可能的范围设置该特性使其他一些细微差别,取决于你想要能够使用的装饰品(问题和感叹号)和/或得到警告的代码可能会引起一个**【T2 得到 NullReferenceException】:**

*   **同时启用警告和注释**:正如我们前面提到的，这是通过启用该特性来实现的。 在此规则下，可以用问题标记注释代码，以提示编译器有关引用的预期用法。 代码编辑器将显示任何潜在的问题，编译器将为这些问题生成警告:

    ```cs
    Csproj: <Nullable>enable</Nullable>
    Code: # nullable enable
    ```

*   **禁用警告和注释:这是默认设置,但可以用来明确禁用**Nullable**功能在整个项目或选定的部分代码:

    ```cs
    Csproj: <Nullable>disable</Nullable>
    Code: # nullable disable
    ```** 
***   **只启用注释，而不启用编译器警告**:当您在现有项目中采用此特性时，在开始注释代码时不需要在 IDE 或编译器输出中接收任何警告，这将非常有用。 值得记住的是，许多公司执行封闭式签入，拒绝任何产生警告的代码。 在这种情况下，在整个项目范围内启用注释，并逐个文件启用警告，以逐步迁移代码:

    ```cs
    Csproj: <Nullable>annotations</Nullable>
    Code: # nullable enable annotations
    ```

    *   **在编辑器中只启用警告而不启用注释**:当启用警告时，IDE 将开始在有潜在危险的解引用代码和问号装饰器上生成绿色波浪线，因为没有启用注释。 当您在现有项目中采用此特性，并且不愿意启用装饰器时(例如，因为代码需要用旧的编译器编译)，此设置非常有用。 在这种情况下，您可以在 IDE 和编译器输出中获得非常有用的建议，这些建议是关于可能导致**NullReferenceException**:

    ```cs
    Csproj: <Nullable>warnings</Nullable>
    Code: # nullable enable warnings
    ```

    的代码的。*   **恢复之前的设置在代码(只有在代码文件)**:当使用语法总是更好结束一个给定的地区使用恢复编译指示,而不是一个启用/禁用,使嵌套区域表现正确:

    ```cs
    # nullable restore annotations
    # nullable restore warnings
    ```

    *   **选择性禁用设置(仅在代码文件中)**:最后一个设置用于选择性禁用给定代码区域中的注释或警告。 当您想要应用逆逻辑时，它是很有用的，也就是说，为整个项目启用该特性，而只禁用选定的代码部分:**

 **在现有项目中采用该特性时，这种控制可空引用类型特性的细粒度能力非常重要。 除此之外，您可能会发现在整个项目范围内启用它更简单。

## 使用可空引用类型

一旦启用，代码分析将在代码编辑器中提供反馈，这取决于引用是否使用了问号装饰。 开发人员可以选择不修饰变量，这意味着引用永远不应该假定为空值。 在这种情况下，声明看起来非常熟悉:

```cs
private string _name;
```

在这里，代码分析将修改构造函数代码，该构造函数代码负责不初始化字符串，在没有问号的情况下，该字符串不能为空。 在这种情况下，补救方法很简单:您可以将**_name**变量初始化为一个空字符串，或者删除默认构造函数，强制所有调用者在创建对象时提供一个不可为空的字符串。

另一种策略是声明**_name**变量为空:

```cs
private string? _name;
```

代码分析将在解引用**Length**属性时显示绿色曲线。 在本例中，解决方案是显式检查**_name**是否为空，并返回一个适当的值(或抛出一个异常)。 这是该属性的一个可能实现:

```cs
public int NameLength2
{
    get
    {
        if (_name == null) return 0; else return _name.Length;
    }
}
```

下面是同一代码的另一种更优雅的实现:

```cs
public int NameLength2 => _name?.Length ?? 0;
```

注释代码很简单，因为它类似于已经在可为空类型中使用的策略，但对于数组，装饰就稍微复杂一些，因为在游戏中有两种可能的引用类型:数组本身和数组中包含的项目。

字符串数组可以这样声明:

```cs
private string[]?  _names; // array can be null
private string?[]  _names; // items in the array can be null
private string?[]? _names; // both the array and its items can
                           // be null
private string[]   _names; // neither of the two can be null
```

但是请记住，我们使用的问号越多，我们需要做的检查就越多。 让我们考虑这个简单的类:

```cs
public class OtherClass
{
    private string?[]? _names;
    public OtherClass() { }
    public int Count => _names?.Length ?? 0;
    public string GetItemLength(int index)
    {
        if (_names == null) return string.Empty;
        var name = _names[index];
        if (name == null) return string.Empty;
        return name;
    }
}
```

**Count**属性之所以短，只是因为我们使用了现代紧凑的语法，但它仍然包含一个空检查。 **GetItemLength**返回数组中包含的*n*项的长度，由于数组和项都可能为 null，因此需要进行两种不同的 null 检查。

如果您正在考虑只返回**字符串?** 作为**GetItemLength**方法的返回类型，此解决方案将使实现代码短一些，但所有调用者将被迫检查是否为空，需要进行更多的代码更改。

## 将现有代码迁移到可空引用类型

每个项目都有自己的特性，但是根据我的个人经验，在将现有项目迁移到这个强大的特性时，我已经设法确定了几个最佳实践。

第一个建议是从位于依赖树底部的项目开始启用该特性。 在项目上下文中，您可能希望使用 pragma 指令来启用分析，从最常用的代码文件开始，例如帮助程序、扩展方法等等。

第二个建议是尽量避免问号:每次你装修问号的参考,代码分析将要求您编写一些代码来提供证明一个空非关联化不能发生,递增样板代码的数量,从而影响热路径的性能。

最后，当您使用此特性编译库时，编译器将应用两个隐藏属性，在元数据中留下关于代码中公开使用的引用的可空性的跟踪。 每次编译引用库的代码时，编译器将知道库方法是否接受可为空的引用，只有当属性明确宣布时，才假定一个不可为空的引用参数。 因此，最佳实践是在公共图书馆中使用该特性，以便其他人可以从该元数据中受益。

可空引用类型对于减少运行时**NullReferenceException**异常的数量非常有用，而这些异常是导致应用崩溃的主要原因。

虽然这个特性是可选的，但是使用 pragma 指令来逐步应用代码为防空所需要的小更改是非常方便的。 这是一个典型的任务，任何团队都应该添加到它的技术债务中来提高代码质量。 除此之外，采用该特性的库作者会自动在其库中提供可空元数据，从而使整个引用链更加稳定。

# 接口成员默认实现

我们已经了解到，接口用于定义每个实现类型都必须履行的契约。 每个接口成员通过指定名称及其签名(输入和输出参数)来定义契约的一部分。 然后由实现接口的具体类型提供所定义成员的实现(或主体)。

通过接口成员的*默认实现，C# 8 扩展了接口类型语法，包括以下特性:*

*   接口现在可以为*方法*、*属性*、*索引器*和*事件*定义主体。
*   接口可以声明*静态成员*，包括*静态构造函数*和*嵌套类型*。
*   它们可以显式地指定可见性修饰符，例如*private*、*protected*、*internal*和*public*(这仍然是默认值)。
*   它们还可以指定其他修饰词，如*virtual*，*abstract*，*sealed*，*extern*，以及*partial*。

这个新特性的语法很简单，就像向成员添加一个实现一样简单:

```cs
public interface ICalc
{
    int Add(int x, int y) => x + y;
    int Mul(int x, int y) => x * y;
}
```

乍一看，向接口成员添加实现看起来很矛盾。 实际上，前面的示例很好地演示了语法，但它肯定不是一个好的设计策略。 您可能想知道在接口成员上定义默认实现的好用例是什么。 第一个原因是*接口版本*，这在传统上是很难管理的。

## 接口版本控制

例如，让我们从经典接口**IWelcome**开始，声明两个简单的属性和一个**Person**类来实现它:

```cs
public interface IWelcome
{
    string FirstName { get; }
    string LastName { get; }
}
public class Person : IWelcome
{
    public Person(string firstName, string lastName)
    {
        this.FirstName = firstName;
        this.LastName = lastName;
    }
    public string FirstName { get; }
    public string LastName { get; }
}
```

现在可以添加一个带有默认实现的新方法:

```cs
public interface IWelcome
{
    string FirstName { get; }
    string LastName { get; }
    string Greet() => $"Welcome {FirstName}";
}
```

实现类不需要更新。 它甚至可以驻留在不同的程序集中，而不会对接口更改产生任何影响。

由于实现是由接口提供的，并且类没有为**Greet**方法提供实现，因此仍然不能从**Person**引用访问该方法。 换句话说，以下声明是不合法的:

```cs
var p = new Person("John", "Doe");
p.Greet(); // Wrong, Greet() is not available in Person
```

为了调用默认的实现，我们需要一个**IWelcome**引用:

```cs
IWelcome p = new Person("John", "Doe");
Assert.AreEqual("Welcome John", p.Greet()); // valid code
```

这个特性的影响在一个历史悠久的接口是非常重要的:例如,**列表【T6 T】>**类暴露了**AddRange**方法,不幸的是没有在【显示】**IList T>**界面。 在应用依赖于这个接口将近 20 年之后，任何改变都将是一个巨大的突破性的改变。

在界面上有哪些改变是有意义的? 删除一个成员可以避免抑制其用法通过**ObsoleteAttribute**也许,几个版本后,它将开始把**NotImplementedException**,不需要删除成员的接口。

更改成员总是一种糟糕的实践，因为接口是契约; 通常，更改的需要可以由具有不同名称和签名的新成员建模。

因此，添加新成员是唯一真正的挑战，因为它破坏了二进制兼容性，并迫使每个接口实现者进行需求更改。 如果接口非常流行，例如**IList<T>**，几乎不可能添加新成员，因为这会破坏每个人的代码。

传统上,接口版本控制问题已经得到解决通过创建一个新的接口,扩展了前一个,但是这个解决方案并不实用,从采用新界面要求实现者取代旧的与新的接口对象继承声明和,当然, 实现新成员。

C# 8 中的默认实现与普通类实现的行为方式不同，因为它定义了该层次结构的*基线*实现。 让我们假设你有一个接口层次结构和一个定义如下的类:

```cs
public interface IDog // defined in Assembly1
{
    string Name { get; }
    string Noise => "barks";
}
public interface ILabrador : IDog // defined in Assembly1
{
    int RetrieverAbility { get; }
}
public class Labrador : ILabrador // defined in Assembly2
{
    public Labrador(string name)
    {
        this.Name = name;
    }
    public string Name { get; }
    public int RetrieverAbility { get; set; }
}
```

在当前情况下，以下断言为真:

```cs
IDog archie = new Labrador("Archie");
Assert.AreEqual("barks", archie.Noise);
```

现在，修复**ILabrador**的默认实现，修改接口如下:

```cs
public interface ILabrador : IDog
{
    int RetrieverAbility { get; }
    string IDog.Noise => "woofs"; // Version 2
}
```

值得注意的是，必须通过指定完整路径**IDog 来重新定义**Noise**方法。 噪声**。 这是因为.NET 允许接口的多重继承; 因此，在一个更复杂的遗传结构中，可能有不止一条路径通向**Noise**方法。

因此，该语法需要指定完整路径，以克服这种潜在的歧义。 如果编译器发现任何仅通过指定完整路径无法解决的歧义，它将生成一个显式错误。

**ILabrador**的默认实现重新定义了**IDog**中**Noise**的基线实现。 这意味着，即使我们使用的是**iddog**，**ILabrador**的变化也会影响结果，如下:

```cs
IDog archie = new Labrador("Archie");
Assert.AreEqual("woofs", archie.Noise); 
```

此外，您可能已经注意到，在前面示例的注释中，接口和类位于两个不同的程序集中。 如果包含**ILabrador**的第一个组件被新成员重新编译，而第二个组件没有被修改，你仍然会看到**Noise**被更新为**woofs**。 这意味着修补第一个程序集将使所有应用从更新中受益，甚至不需要重新编译整个代码。

## 接口重新抽象

从派生接口重新定义默认实现的能力是理解重抽象的基础。 原理是相同的，但是派生接口可能决定*删除*默认接口实现，将成员标记为抽象。

继续前面的例子，我们可以定义以下接口:

```cs
public interface IYellowLabrador : ILabrador
{
    abstract string IDog.Noise { get; }
}
```

但这一次，新接口的实现者还需要实现**Noise**方法:

```cs
public class YellowLabrador : IYellowLabrador
{
    public YellowLabrador(string name)
    {
        this.Name = name;
    }
    public string Name { get; }
    public int RetrieverAbility { get; set; }
    public string Noise { get; set; }
}
```

此功能非常有用，因为编写默认实现是为了提供层次结构中所有类型通常使用的最佳实现。 但是，这些类型的分支可能不适合该实现，您希望在接口级别删除它，以避免任何不当行为。

## 接口作为性状

详细治疗的概念特征成分需要整整一个章节,但值得注意的是,C # 8特征才刚刚打开门,离开语言的未来版本的机会以填补空白,你可以阅读在设计指出 C# 语言的公共存储库。

Trait composition**Trait composition**是其他语言(如 c++)中众所周知的概念。 它涉及为定义一组成员以确定已知行为的能力。 目标是定义不同的类型(特征)，目标是让任何类能够通过继承特征组成自己的行为。

在该语言发布之前，我们通常创建静态助手类来定义一组可重用行为。 在 C# 8 中，我们可以在接口内部定义这些成员，这样就可以通过继承接口来重用它们。 接口的选择非常方便，因为. net 只支持接口上的多个继承，允许在一个新类中继承多个特征。

如果你打算试验特性，试着在不考虑经典接口用法的情况下对它们进行建模; 相反，要查看它们的内在能力，即对多个继承开放，从而组成一组方法。

当你需要构建的行为的可用性非常依赖于你将要定义的每个类时，特征通常是非常有用的。 从设计的角度来看，这可以转化为一个非常长的接口列表，每个接口定义一个单独的行为，或者一个接口包含多个对象，通过抛出**NotImplementedException**来实现其部分方法。

让我们看看一个非常简单的示例，在这个示例中，您希望向您的应用公开一个字母音译服务。 有多种方法可以实现这一点:要么使用 Windows 本地 api，要么使用 NuGet 库，要么使用云服务。 我们可能会试图定义一个接口，其中包含一长串方法，支持从一个字母到另一个字母的所有可能排列，但这不是很实际，因为每个库或服务只支持所有可能的音译的一部分。 这将导致许多实现抛出**NotImplementedException**。

另一种方法是为每个可能的音译定义一个接口，但是实现这些接口的类需要将成员实现重定向到某个调用适当库的外部助手类。

性状解看起来更简单因为它只是模拟了我们能做什么。 例如，这里有两种可能的音译接口:

```cs
public interface ICyrillicToLatin
{
  public string Convert(string input)
  {
    return Transliteration.CyrillicToLatin(input, Language.Russian);
  }
}
public interface ILatinToCyrillic
{
  public string Convert(string input)
  {
    return Transliteration.LatinToCyrillic(input, Language.Russian);
  }
}
```

它们仍然是接口，但是需要通用实现的类可以将接口添加到继承列表中，而不需要其他任何东西:

```cs
class CompositeTransliterator : ICyrillicToLatin, ILatinToCyrillic
{
  // ...
}
```

最后，为了让使用者的工作更轻松，类可以使用模式公开一个开关表达式，以调用对给定字母/的 try 转写，并返回计算结果:

```cs
public string TransliterateCyrillic(string input)
{
    string result;
    return this switch
    {
        ICyrillicToLatin c when (result = c.Convert(input)) != input => result,
        ILatinToCyrillic l when (result = l.Convert(input)) != input => result,
        _ => throw new NotImplementedException("N/A"),
    };
}
```

这段代码试图用所有可用的服务转译文本，如果类实现了其中一个服务，则尝试进行转换。 一旦可以对短语进行转换(即转换结果与输入不同)，就将其返回给调用者。

接口中的默认接口实现对所有实用主义者来说都是一个有价值的特性。 Java 和 Swift 是已经支持这一特性的编程语言的例子。 如果您是一个需要跨多种语言移植代码的库开发人员，这将使您的工作更轻松，并避免重新设计代码部分，以克服该语言的以前版本中没有的问题。

与往常一样，建议明智地使用默认实现。 如果用例已经很好地适应了以前的工具和模式，那么它就没有用了。

默认实现的一个有趣的边缘情况是，你现在可以用下面的代码定义你的应用的入口点:

```cs
interface IProgram
{
    static void Main() => Console.WriteLine("Hello, world");
}
```

默认接口成员是一个有争议的特性，它利用了. net 接口的固有功能来支持多重继承。 实用主义者应该欣赏证明这个小革命的实际用例，而其他人可以像以前一样继续使用接口。

现在我们可以转向下一个特性，它应该有助于避免一些头痛问题和在切片数组和列表时的**IndexOutOfRangeException**异常。

# 范围和指标

C# 8 中引入的另一个方便的功能是识别序列中单个元素或范围的新语法。 语言已经提供的能力获取或设置元素数组中使用方括号和一个数字索引,但这个概念已经被添加扩展两个运营商确定一个项目从一个序列和提取两个指标之间的范围。

除了上述操作符之外，基类库现在提供了两种新的系统类型**system。 指标**和**系统。 范围**，我们将立即看到行动。 让我们考虑一个包含六个国家名的字符串数组:

```cs
var countries = new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" };
var length = countries.Length;
```

我们已经知道如何使用数字索引器来获取对第一项的引用:

```cs
Assert.IsTrue(countries[0] == "Italy");
```

新的**系统。 Index**类型只是可以直接在数组上使用的数字索引的方便包装:

```cs
var italyIndex = new Index(0);
Assert.IsTrue(countries[0] == countries[italyIndex]);
```

有趣的部分是当我们需要处理从序列末尾开始的项时:

```cs
// first item from the end is length - 1
Assert.IsTrue(countries[length - 1] == "England");
var englandIndex = new Index(1, true);
Assert.IsTrue(countries[length - 1] == countries[englandIndex]);
```

新的**^**运算符为我们提供了一个简洁有效的方法来获取最后一项:

```cs
Assert.IsTrue(countries[^1] == countries[englandIndex]);
```

值得注意的是，当从开始计数时，0 是第一个索引，而当从结束计数时，它的指向总长度之外的一个条目。 这意味着**[^0]**表达式将始终抛出**IndexOutOfRangeException**:

```cs
Assert.ThrowsException<IndexOutOfRangeException>(() => countries[^0]);
```

当涉及范围时，新语法的价值更加明显，因为它是一个全新的概念，以前在语言或基类库中从未存在过。 新的**.. 操作符分隔用于标识一个范围的两个索引。 当应该跳过边界上的项时，操作符左边和右边的分隔符也可以省略。**

下面的例子展示了三种指定数组中所有项的方法:

```cs
var countries = new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" };
var expected = countries.ToArray();
var all1 = countries[..];
var all2 = countries[0..^0];
var allRange = new Range(0, new Index(0, true));
var all3 = countries[allRange];
Assert.IsTrue(expected.SequenceEqual(all1));
Assert.IsTrue(expected.SequenceEqual(all2));
Assert.IsTrue(expected.SequenceEqual(all3));
```

期望的**变量**只获得国家数组的克隆，而方便的**SequenceEqual**Linq 扩展方法在两个序列中的项相同且顺序相同时返回 true。 前面的例子不是很有用,但强调语义边界:*左边界总是【显示】的*,在*对*边界总是【病人】。

下面的例子更加真实，展示了三种不同的方法来指定一个范围，只跳过序列的第一项:

```cs
var countries = new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" };
var expected = new[] { "Romania", "Switzerland", "Germany", "France", "England" };
var skipFirst1 = countries[1..];
var skipFirst2 = countries[1..^0];
var skipFirstRange = new Range(1, new Index(0, true));
var skipFirst3 = countries[skipFirstRange];
Assert.IsTrue(expected.SequenceEqual(skipFirst1));
Assert.IsTrue(expected.SequenceEqual(skipFirst2));
Assert.IsTrue(expected.SequenceEqual(skipFirst3));
```

类似地，下面的例子展示了如何跳过序列中的最后一项:

```cs
var countries = new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" };
var expected = new[] { "Italy", "Romania", "Switzerland", "Germany", "France" };
var skipLast1 = countries[..^1];
var skipLast2 = countries[0..^1];
var skipLastRange = new Range(0, new Index(1, true));
var skipLast3 = countries[skipLastRange];
Assert.IsTrue(expected.SequenceEqual(skipLast1));
Assert.IsTrue(expected.SequenceEqual(skipLast2));
Assert.IsTrue(expected.SequenceEqual(skipLast3));
```

把所有东西放在一起很简单，下面的例子展示了如何跳过序列的第一个和最后一个元素:

```cs
var countries = new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" };
var expected = new[] { "Romania", "Switzerland", "Germany", "France" };
var skipFirstAndLast1 = countries[1..^1];
var skipFirstAndLastRange = new Range(1, new Index(1, true));
var skipFirstAndLast2 = countries[skipFirstAndLastRange];
Assert.IsTrue(expected.SequenceEqual(skipFirstAndLast1));
Assert.IsTrue(expected.SequenceEqual(skipFirstAndLast2));
```

用于指定开始索引和结束索引的范围语法可以从开始或结束开始计数。 在下面的例子中，被切片的数组将只返回第二个和第三个元素，都是从一开始计算的:

```cs
var countries = new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" };
var expected = new[] { "Romania", "Switzerland" };
var skipSecondAndThird1 = countries[1..3];
var skipSecondAndThirdRange = new Range(1, 3);
var skipSecondAndThird2 = countries[skipSecondAndThirdRange];
Assert.IsTrue(expected.SequenceEqual(skipSecondAndThird1));
Assert.IsTrue(expected.SequenceEqual(skipSecondAndThird2));
```

当然，从末尾开始计数也是有效的，这也是下面例子的目的:

```cs
var countries = new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" };
var expected = new[] { "Germany", "France" };
var fromEnd1 = countries[^3..^1];
var fromEndRange = new Range(new Index(3, true), new Index(1, true));
var fromEnd2 = countries[fromEndRange];
Assert.IsTrue(expected.SequenceEqual(fromEnd1));
Assert.IsTrue(expected.SequenceEqual(fromEnd2));
```

这个语法非常简单，但您可能已经注意到，我们只使用了数组，它和字符串一样，在 C# 中被认为是特殊的。 事实上,如果我们试图使用相同的语法<**列表 T>**,它不会工作,因为没有成员知道**指数**和**:**

 **```cs
var countries = new MyList<string>(new[] { "Italy", "Romania", "Switzerland", "Germany", "France", "England" });
var expected = new[] { "Romania", "Switzerland", "Germany", "France" };
MyList<string> sliced = countries[1..^1];
Assert.IsTrue(expected.SequenceEqual(sliced));
```

现在的问题是，我们如何使下面的测试通过? 有三种不同的方法可以使编译并工作。 第一种方法很简单，包括提供一个采用**系统的索引器。 范围**作为参数:

```cs
public class MyList<T> : List<T>
{
  public MyList() { }
  public MyList(IEnumerable<T> items) : base(items) { }
  public MyList<T> this[Range range]
  {
    get
    {
      (var from, var count) = range.GetOffsetAndLength(this.Count);
      return new MyList<T>(this.GetRange(from, count));
    }
  }
}
```

**列表<T>**基类提供了索引器将一个整数,而**【t16.1】MyList T>**添加一个过载采取一系列**类型,用于从 C # 8 的别名**. .** 语法。 在新的索引器中，我们使用了**Range。 GetOffsetAndLength**，一个非常方便的方法，它返回一个具有初始索引和要切片的序列长度的元组。 最后，**List<T>. getrange**base 方法提供了用于创建新的**MyList<T>**集合的切片序列。**

 **另一个可能的解决方案是利用特殊的**Slice**方法，C# 8 编译器使用该方法通过模式搜索*。 没有我们之前写的索引器,如果编译器发现一个名为**片的方法,两个整数,它*重新映射语法来调用范围【显示】****切片方法。 因此，下面的代码更整洁、更容易阅读:**

```cs
public class MyList<T> : List<T>
{
    public MyList() { }
    public MyList(IEnumerable<T> items) : base(items) { }
    public MyList<T> Slice(int offset, int count)
    {
        return new MyList<T>(this.GetRange(offset, count));
    }
}
```

请注意，任何具有范围语法的调用，如**countries[1..] ^1]**将调用**Slice**方法。

这个解决方案很好但不能解决问题流行的**【病人】列表 T>**类,一个类可以发现代码中几乎无处不在,尤其是因为 Linq 扩展方法称为**ToList**()返回一个**IList<>**。 编写一个**Slice**扩展方法不能工作，因为编译器会在实例方法中寻找**Slice**，而扩展方法是静态的。

解决方案是编写一个扩展方法，取**范围**，如下例所示。 这一次，country 引用是继承了**ICollection<T>**的任何集合，并且支持使用**countries 的良好语法进行切片。**

```cs
public static class CollectionExtensions
{
    public static IEnumerable<T> Slice<T>(this ICollection<T> items, Range range)
    {
        (var offset, var count) = range.GetOffsetAndLength(items.Count);
        return items.Skip(offset).Take(count);
    }
}
```

在所有前面的例子,我们显式地创建**指数**和**使用构造函数,但我建议采取一些时间来探索方便静态工厂提供的**指数**和**范围类,如【显示】Range.All()或**Index.FromEnd()**。****

 ****范围和索引提供了强大且具有表现力的操作符和类型，以简化序列中单个或多个项的选择。 其主要目的是在不影响性能的情况下提高代码的可读性，减少出错的可能性。

关于范围最重要的建议是要记住，边界只包含在范围的左边。

# 模式匹配

模式匹配是在 C# 7 中引入的，但是该语言规范的第 8 版通过平滑语法并使其更加紧凑和可读而扩大了它的使用范围。 本章将避免重复之前版本中已经看到的特性，而只关注新概念。

流行的**switch**语句已经在 C# 中发展成为具有非常流畅的语法的*表达式*。 例如，假设您正在使用**控制台读取应用中的控制台键。 用 ReadKey**方法得到与**R**、**G**、**B**字符匹配的颜色:

```cs
public Color ToColor(ConsoleKey key) 
{
    return key switch
    {
        ConsoleKey.R => Color.Red,
        ConsoleKey.G => Color.Green,
        ConsoleKey.B => Color.Blue,
        _ => throw new ArgumentException($"Invalid {nameof(key)}"),
    };
}
```

或者，如果你喜欢更简洁的版本，我们可以这样写:

```cs
public Color ToColor(ConsoleKey key) => key switch
    {
        ConsoleKey.R => Color.Red,
        ConsoleKey.G => Color.Green,
        ConsoleKey.B => Color.Blue,
        _ => throw new ArgumentException($"Invalid {nameof(key)}"),
    };
```

**开关**的表达与以往 C# 7 模式匹配的创新没有语义上的改变; 相反，它变得更简单、更紧凑，突出了一些重要的东西:

*   作为一个表达式，**switch**语句必须返回一个值(我们的示例中的**Color**枚举)。
*   丢弃字符**(_)**替换经典**switch**语句中的**默认**关键字。
*   将键映射到颜色的子表达式按顺序计算，其中第一个匹配胜出并退出。

当使用 switch 表达式匹配类型时，事情会变得更加有趣，如下面的例子所示:

```cs
string GetString(object o) => o switch
   {
     string s   => $"string '{s}'",
     int i      => $"integer {i:d4}",
     double d   => $"double {d:n}",
     Derived d  => $"Derived: {d.Other}",
     Base b     => $"Base: {b.Name}",
     null       =>  "null",
     _          => $"Fallback: {o}",
   };
```

此方法接受一个未知对象作为输入，并返回一个根据其运行时类型不同而格式化的字符串，该字符串必须与确切的类型匹配。 例如，**GetString((Int16)1)**将不匹配也不返回字符串**Fallback: 1**。 另一个失败的匹配是**GetString(10.6m)**，因为字面量是小数，返回的字符串将是**Fallback: 10.6**。

在 C# 7 之前，测试值或引用类型的类型标识相当麻烦，因为它需要第二步将值类型转换为所需的类型，或者对引用类型进行空检查条件操作。 多亏了 C# 7，我们学会了使用**is**pattern匹配，这在检查单个类型时非常完美。

使用新的 C# 8 语法，生成的代码更简洁，更不容易出错，具有以下几个优点:

*   不必关心空引用在任何情况下,它的积极作用是一个更好的候选人的方法**即时编译器内联的**(**JIT),从而可以获得更好的性能。**
*   评估遵循顺序，这在测试类型层次结构时非常有用。 在我们的例子中，在**碱基**之前计算**派生的**类是很重要的，因为否则**开关**表达式将始终匹配**碱基**。
*   在*null case*中显式捕获空值，避免任何条件表达式。

**开关**表达式非常强大，但是对模式匹配的改进还没有结束。

## 递归模式匹配

模式匹配已经扩展到允许深入到对象属性和元组中。 此改进的基础语法包含了在模式后面的花括号之间指定表达式的能力:

```cs
var weekDays = Enum.GetNames(typeof(DayOfWeek));
var expected = new[] { "Sunday", "Monday", "Friday", };
var six = weekDays
    .Where(w => w is string { Length: 6 })
    .ToArray();
Assert.IsTrue(six.SequenceEqual(expected));
```

花括号内的表达式只能指定属性，并且必须使用常量文字。 这允许我们匹配类型，同时，计算它的属性可能在子表达式上循环。

真正的力量发挥作用,当我们需要评估对象结构图表,在以下两个普通 CLR 对象**(**略)类,通过**客户引用**的**【显示】类:******

 **```cs
public class Order
{
    public Guid Id { get; set; }
    public bool IsMadeOnWeb { get; set; }
    public Customer Customer { get; set; }
    public decimal Quantity { get; set; }
}
public class Customer
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Country { get; set; }
}
```

现在，让我们假设我们正在处理一个电子商务应用，其中折扣取决于订单属性:

```cs
public decimal GetDiscount(Order order) => order switch
{
    var o when o.Quantity > 100 => 7.5m,
    { IsMadeOnWeb: true } => 5.0m,
    { Customer: { Country: "Italy" } } => 2.0m,
    _ => 0,
};
```

这里，第一个子表达式将对**o**变量的引用重新赋值，然后计算其**Quantity**属性，这多亏了子句时的**。 如果数量>100**令人满意，可给予 7.5%的折扣。

在第二种情况下，当**Order。 IsMadeOnWeb**是真实的，5%的优惠将被退回。 第三个案例评估通过浏览**order . customer . country**获得的财产，返回 2%的折扣，仅仅因为订单来自意大利。 最后，discard 字符表示回退到零折扣。

带有属性的语法非常好，但是当涉及到元组时，事情就变得有点复杂了，因为您可能需要匹配单个元组项，也可能需要匹配多个元组项，而且它们的位置也是基本的。

例如，让我们考虑一个简单的**Point**结构体，毫无疑问，它具有**X**和**Y**两个整数属性:

```cs
struct Point
{
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
    public int X { get; set; }
    public int Y { get; set; }
}
```

我们如何编写一个方法来返回点是在水平轴上还是在垂直轴上? 当**X**或**Y**为零时，满足条件; 因此，一种可能的方法是:

```cs
bool IsOnAxis(Point p) => (p.X, p.Y) switch
{
    (0, _) => true,
    (_, 0) => true,
    (_, _) => false,
};
```

传统上，如果使用**或**操作符，我们将使用一个**来编写此方法，但是参数越多，代码就变得越难以阅读。 前面的例子的一个有趣的一点是,我们建立了一个元组动态评估它在**切换表达式,匹配参数的位置和丢弃(**_**字符)那些不相关的评估。****

 **当在**Point**结构中编写特殊的**解构**方法时，事情变得更加有趣，因为它简化了元组的创建:

```cs
public struct Point
{
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
    public int X { get; set; }
    public int Y { get; set; }
    public void Deconstruct(out int x, out int y)
    {
        x = X;
        y = Y;
    }
}
public bool IsOnAnyAxis(Point p) => p switch
{
    (0, _) => true,
    (_, 0) => true,
    _ => false,
};
```

当在**开关**表达式中使用元组时，可以使用**When**子句计算其值，从而获得更大的权限。

在下面的例子中，我们使用**when**子句来标识轴之外的对角线位置。 为了实现的目的，我们定义了**SpecialPosition**枚举数，并使用**switch**表达式和**when**子句匹配对角线:

```cs
enum SpecialPosition
{
    None,
    Origin,
    XAxis,
    YAxis,
    MainDiagonal,
    AntiDiagonal,
}
SpecialPosition GetSpecialPosition(Point p) => p switch
{
    (0, 0) => SpecialPosition.Origin,
    (0, _) => SpecialPosition.YAxis,
    (_, 0) => SpecialPosition.XAxis,
    var (x, y) when x ==  y => SpecialPosition.MainDiagonal,
    var (x, y) when x == -y => SpecialPosition.AntiDiagonal,
    _ => SpecialPosition.None,
};
```

模式匹配在该语言的前两个版本中获得了很大的优势，现在它允许开发人员专注于代码的重要部分，而不会被之前的语言规则所需的样板代码分散注意力。

如果计算需要深入到对象图或计算元组，那么**开关**表达式特别适合于所有结果可以从多个选择导出的表达式。 强大的丢弃字符允许部分求值，避免了通常复杂且容易出错的代码。

# 使用声明

使用声明的**是一种非常方便的语法，相当于**try/finally**块，并为**Dispose**方法提供了确定性调用。 该声明可用于实现**可删除**接口的所有对象:**

```cs
class DisposableClass : IDisposable
{
    public void Dispose() => Console.WriteLine("Dispose!");
}
```

我们已经知道，使用声明的**在遇到**的右花括号时，就会确定性地调用**Dispose**方法:****

```cs
void SomeMethod()
{
    using (var x = new DisposableClass())
    {
        //...
    }	// Dispose is called
}
```

每次需要在同一范围内使用多个可丢弃对象时，使用声明的嵌套**就会被嵌套，从而导致恼人的三角形代码对齐:**

```cs
using (var x = new Disposable1())
{
    using (var y = new Disposable2())
    {
        using (var z = new Disposable3())
        {
            //...
        }
    }
}
```

这个烦恼可以最后删除如果天气好**处理方法被称为当前块的末尾(封闭的大括号),无论是否块声明(如**/**如果**/…)或当前的方法。****

 **C# 8 中的新语法允许我们使用声明完全删除**中的花括号，将前面的例子转换为如下:**

```cs
void SomeMethod()
{
    using (var x = new Disposable1());
    using (var y = new Disposable2());
    using (var z = new Disposable3());
    //...
} // Dispose methods are called
```

关闭当前块的第一个花括号将自动触发三个**Dispose**方法，这些方法与声明的顺序相反。 但关于**Dispose**还有更多内容要讲; 实际上，这种紧凑语法也适用于使用声明的**异步，这将在下一节中讨论。**

# 异步处理

在.NET 中出现 Tasks 之后，大多数管理 I/O 操作的库逐渐转向异步行为。 例如，**System.Net.Websocket**类成员采用了基于任务的编程策略，提供了更好的开发人员体验和更有效的行为。

每次开发人员需要编写一个 C# 客户端来访问基于 WebSocket 协议的服务时，他们通常会编写一个包装器类，公开专门的*send*方法，并实现 dispose 模式来调用**WebSocket。 closeassync**方法。 我们也知道,任何一个异步方法应该返回**的任务,但 Dispose 方法被定义为无效【显示】**任务之前的时代,因此不适合在****任务链。****

 **Websocket 的例子是非常现实的，因为我在一段时间前就遇到了这个问题，阻塞当前线程来等待 Dispose 中 CloseAsync 完成，这会导致死锁。

从 C# 8 和.NET Core 3.0 开始，我们现在有两个重要的工具:

*   .NET Core 3 中定义的**IAsyncDisposable**接口，返回一个轻量级的**ValueTask**类型
*   使用构造的**await 利用了新的**AsyncDisposable**接口**

让我们看看如何在代码中使用它们:

```cs
public class AsyncDisposableClass : IAsyncDisposable
{
    public ValueTask DisposeAsync()
    {
        Console.WriteLine("Dispose called");
        return new ValueTask();
    }
}
private async Task SomeMethodAsync()
{
    await using (var x = new AsyncDisposableClass())
    {
        // ...
    }
}
```

值得记住的是，使用声明的**await 受益于简洁的单行语法，正如我们之前讨论的:**

```cs
private async Task SomeMethodAsync()
{
    await using (var x = new AsyncDisposableClass());
}
```

如果您是公开一次性类型的库作者，则可以实现这两个接口中的任何一个，或者甚至同时实现**可一次性**和**IAsyncDisposable**接口。

# struct 和 ref struct 中的可丢弃模式

随着时间的推移，C# 引入了一些基于模式的结构来解决由不能应用于所有情况的规则所产生的问题。 这一切发生的时候,例如,与**foreach 语句不需要对象实现**IEnumerable【t16.1】>【显示】界面,而不是仅仅依赖的存在**GetEnumerator**的方法, 同样的，由**GetEnumerator**返回的对象不需要实现**IEnumerator**，而只是暴露所需的成员。****

这种变化是由最近引入的**ref 结构**驱动的，它对于减少垃圾收集器的压力非常重要，因为它们保证只存在于堆栈上，而不允许实现接口。

基于模式的方法现在已经扩展到我们现在将要讨论的特定条件下的**Dispose**和**DisposeAsync**方法。

从 C# 8 开始，开发者可以定义**Dispose**或**DisposeAsync**，而无需实现**IDisposable**或**IAsyncDisposable**。 实现【显示】处理方法模式已经*有限【病人】ref struct 类型,因为它扩展到其他类型可能最终导致断裂变化类型已经定义一个**处理方法没有宣布【t16.1】IDisposable 在继承列表中。***

 ***下面的定义是**Dispose**和**DisposeAsync**方法的有效实现:

```cs
ref struct MyRefStruct
{
    public void Dispose() => Debug.WriteLine("Dispose");
    public ValueTask DisposeAsync()
    {
        Debug.WriteLine("DisposeAsync");
        return default(ValueTask);
    }
}
```

**Dispose**方法可以照常使用:

```cs
public void TestMethod1()
{
    using var s1 = new MyRefStruct();
}
```

但是这个其他的声明是不允许的，因为不能在异步方法中使用**ref**:

```cs
public async Task TestMethod2()
{
    //await using var s2 = new MyRefStruct(); // Error!
}
```

解决方法是使用声明扩展**await，使用完整的**try**/**finally**:**

```cs
public Task TestMethod3()
{
    var s2 = new MyRefStruct();
    Task result;
    try { /*...*/ }
    finally
    {
        result = s2.DisposeAsync().AsTask();
    }
    return result;
}
```

这段代码当然不是很好读，但是我们应该考虑声明**Dispose**的异步版本(在其生命周期仅限于堆栈的类型中)可能不是一个好主意。

而的**处理模式一直预防性**限于 ref 结构**,**DisposeAsync【显示】的模式没有限制,这是完全合法的声明**DisposeAsync**在一个老式的类并使用它使用**与【病人】等待语句。**

# 异步流

异步流是几年前首次引入**task**类、**async**和**await**时开始的任务故事中最后一个缺失的部分。 未解决的用例的一个例子是在下载数据块时对来自互联网的数据块的处理。 这里的基本要点是，我们不想等待整个数据流，而是每次取单个块，处理它，然后等待下一个。 因此，这种处理可以在其他数据仍在下载的情况下进行，而未使用的线程时间也可以用于服务其他用户，从而增加应用的总可伸缩性。

在深入研究 C# 的新特性之前，让我们快速回顾一下在同步环境中是如何生成枚举的。 下面的例子展示了可以在**foreach**语句中使用的可枚举序列; 您可能注意到枚举类型是一个整数，而不是组成从互联网上下载的块的假想字节数组，但这并不是真正相关的。

最简单的实现是利用 C# 迭代器，它是通过**yield**关键字实现的:

```cs
static IEnumerable<int> SyncIterator()
{
    foreach (var item in Enumerable.Range(0, 10))
    {
        Thread.Sleep(500);
        yield return item;
    }
}
```

当然，它的主要消费者是一个**对每一个**的声明:

```cs
foreach (var item in SyncIterator())
{
    // ...
}
```

在引擎盖下,编译器生成代码,暴露一个**【病人】IEnumerable T>**的责任是提供枚举器,一个类的当前**,**重置**,**MoveNext**成员展开序列。 这段代码的相关部分是**Thread。 在**MoveNext**方法中休眠**，这模拟了一个缓慢的迭代。**

下面的代码是等效的，但是手动实现了**IEnumerable**和**IEnumerator**接口:

```cs
public class SyncSequence : IEnumerable<int>
{
    private int[] _data = Enumerable.Range(0, 10).ToArray();
    public IEnumerator<int> GetEnumerator() => new SyncSequenceEnumerator<int>(_data);
    IEnumerator IEnumerable.GetEnumerator() => new SyncSequenceEnumerator<int>(_data);
    private class SyncSequenceEnumerator<T> : IEnumerator<T>, IEnumerator, IDisposable
    {
        private T[] _sequence;
        private int _index;
        public SyncSequenceEnumerator(T[] sequence)
        {
            _sequence = sequence;
            _index = -1;
        }
        object IEnumerator.Current => _sequence[_index];
        public T Current => _sequence[_index];
        public void Dispose() { }
        public void Reset() => _index = -1;
        public bool MoveNext()
        {
            Thread.Sleep(500);
            _index++;
            if (_sequence.Length <= _index) return false;
            return true;
        }
    }
}
```

同样，**foreach**语句可以轻松地使用该序列，从而共享**thread 导致的阻塞线程问题。 Sleep**，这在现实生活中是操作系统的网络栈中正在进行的 I/O 操作:

```cs
foreach (var item in new SyncSequence())
{
    // ...
}
```

为了解决这个问题,C # 8 介绍了非常方便的**等待 foreach**,用于迭代异步枚举,反过来需要两个新的接口:**IAsyncEnumerable<【显示】**和**IAsyncEnumerator<>**。

新的异步流的最简单的生产者和消费者与前面的非常相似:

```cs
async IAsyncEnumerable<int> AsyncIterator()
{
    foreach (var item in Enumerable.Range(0, 10))
    {
        await Task.Delay(500);
        yield return item;
    }
}
await foreach (var item in AsyncIterator())
{
    // ...
}
```

如果我们需要实现这两个接口(手动)，它将与同步实现没有太大不同，在同步实现中，我们必须实现**MoveNext**的异步版本**MoveNextAsync**:

```cs
public class AsyncSequence : IAsyncEnumerable<int>
{
    private int[] _data = Enumerable.Range(0, 10).ToArray();
    public IAsyncEnumerator<int> GetAsyncEnumerator(CancellationToken cancellationToken = default)
    {
        return new MyAsyncEnumerator<int>(_data);
    }
    private class MyAsyncEnumerator<T> : IAsyncEnumerator<T>
    {
        private T[] _sequence;
        private int _index;
        public MyAsyncEnumerator(T[] sequence)
        {
            _sequence = sequence;
            _index = -1;
        }
        public T Current => _sequence[_index];
        public ValueTask DisposeAsync() => default(ValueTask);
        public async ValueTask<bool> MoveNextAsync()
        {
            await Task.Delay(500);
            _index++;
            if (_sequence.Length <= _index) return false;
            return true;
        }
    }
}
```

同样的,**<IEnumerator T>**来源于**IDisposable<【病人】**,**<IAsyncEnumerator T>**界面来源于**IAsyncDisposable<【t16.1】【显示】,我们已经讨论过的。**

**MoveNextAsync**和**当前**是唯一所需的其他成员**【病人】IAsyncEnumerator T>**界面,其方法返回*轻量级*【显示】ValueTask 类型已经在**DisposeAsync**。

请注意

在撰写本文时,只有基类库中的类实现**IAsyncEnumerable<>**是**System.Threading.Channel**,为了充分利用异步流的力量,你应该采用外部库或实现这两个接口,这是很简单的。

使用新的异步序列的代码在结构上是相同的:

```cs
await foreach (var item in new AsyncSequence())
{
    // ...
} 
```

为了完整起见，消费代码等价如下:

```cs
var sequence = new AsyncSequence();
IAsyncEnumerator<int> enumerator = sequence.GetAsyncEnumerator();
try
{
    while (await enumerator.MoveNextAsync())
    {
        // some code using enumerator.Current
    }
}
finally { await enumerator.DisposeAsync(); }
```

静态的**TaskAsyncEnumerableExtensions**类包含了一些扩展方法，这些方法允许配置**iasyncenumable**对象，就像其他**Task**对象一样。

第一个扩展方法是**ConfigureAwait**，我们已经在[*第十二章*](12.html# _idTextAnchor215)，*多线程和异步编程*中检查过了。 另一个是**withcancel**，它带有一个**CancellationToken**值，可以用来取消正在进行的任务。

异步流非常强大，因为它们简化了开发人员的代码，同时使其更加强大。 在生产方面,实现所需的接口(**IAsyncEnumerable**和**IAsyncEnumerator)很简单,和在消费者方面,很容易列举异步序列由于新**异步 foreach【5】。****

 **一个缺点是，当前的图书馆生态系统与新的界面不兼容。 由于这个原因，社区已经编写了一组新的 linq 风格的扩展方法，提供了与基类库中相同的*外观和感觉*。

为每个用例使用正确的工具也很重要。 换句话说，没有必要仅仅因为语言已经被扩展，就把所有东西都转换成异步的东西。 这是每个开发人员都可以使用的重要工具。

# 只读结构成员

在 C# 7 中引入了**readonly**结构之后，现在可以在其成员上单独指定**readonly**修饰符。 对于不能将结构类型完全标记为只读，但只有一个或多个成员可以保证不修改实例状态的情况，添加了此特性。

我喜欢这个特性的主要原因是，从维护和可用性方面来说，明确地表达意图是一种最佳实践。

从性能的角度来看，这也很重要，因为**只读**结构为编译器提供了一种*提示*，可以应用更好的优化。 修饰符可以应用于字段、属性和方法，以保证它不会改变结构实例，但不会对所引用的对象提供任何保证。

在处理属性时，修饰符可以应用在属性上，也可以只应用在其中一个访问器上:

```cs
public readonly int Num0
{
    get => _i;
    set { } // not useful but valid
}
public readonly int Num1
{
    get => _i;
    //set => _i = value; // not valid
}
public int Num2
{
    readonly get => _i;
    set => _i = value; // ok
}
public int Num3
{
    get => ++_i;     // strongly discouraged but it works
    readonly set { } // does not make sense but it works
}
```

例如，让我们定义一个**Vector 结构**暴露两个返回 Vector 长度的方法，其中只有其中一个被标记为**只读**:

```cs
public struct Vector
{
    public float x;
    public float y;
    private readonly float SquaredRo => (x * x) + (y * y);
    public readonly float GetLengthRo() => MathF.Sqrt(SquaredRo);
    public float GetLength() => MathF.Sqrt(SquaredRo);
}
```

从值类型,如**向量受到被复制作为参数传递时,一个常见的解决方案是应用**修饰符(这意味着一个**只读的****ref**),像下面的例子:****

 **```cs
public static float SomeMethod(in Vector vector)
{
    // a local copy is done because GetLength is not readonly
    return vector.GetLength();
}
```

不幸的是，中的**不能保证引用所指向的其他数据的不变性。 因此,当编译器看到了**GetLength**正在调用的方法,它假定一个潜在改变向量实例,导致防守隐藏的本地副本****向量,不管事实已经通过的参考。**

如果我们更换电话**与只读 GetLength****GetLengthRo**方法,编译器理解没有风险修改**向量内容和可以避免生成本地副本,为应用提供更好的性能:**

```cs
public static float ReadonlyBehavior(in Vector vector)
{
    // no local copy is done because GetLengthRo is readonly
    return vector.GetLengthRo();
}
```

值得指出的是，编译器足够聪明，可以提供一些自动优化。 例如，自动生成的属性 getter 已经被标记为只读，但要记住对所有其他成员应用**只读**修饰符，不要改变实例状态，为编译器提供重要提示，并在更改中获得最好的优化。

请注意

编译器经过一个又一个版本的改进，以检测潜在的副作用(如本地拷贝)。 您可以自己使用反编译器(如**ildasm**或**ILSpy**工具来验证生成的 IL 代码，但是要注意，这些优化会随着时间的推移而发生变化。

如果你将一个方法标记为只读，即使它正在修改其实例的状态，编译器也会根据情况生成错误或警告:

*   如果**只读**方法试图修改结构体的任何字段，编译器将报错**CS1604**错误。
*   编译器将生成一个**CS8656 警告每次访问的代码不是只读属性getter 建议所需的生成代码来创建一个防守隐藏的本地副本结构、所描述的消息。**

 **在 CS8656 警告消息中，编译器建议它将生成一个**'this'**的副本，以避免改变当前实例:

```cs
"Call to a non readonly member '...' from a 'readonly' member results in an implicit copy of 'this'".
```

关于编译器识别不希望出现的情况的能力，有一个重要的副作用。 它无法检测任何修改被引用对象的更改的尝试，如下代码所示:

```cs
struct Undetected
{
    private IDictionary<string, object> _bag;
    public Undetected(IDictionary<string, object> bag)
    {
        _bag = bag;
    }
    public readonly string Description
    {
        get => (string)_bag["Description"];
        set => _bag["Description"] = value;
    }
}
```

虽然我们显然看不出不对不修改值类型状态的结构成员应用**只读**修饰符有什么缺点，但还是要非常小心，因为这可能会对热路径的性能产生很大影响。

# Null 合并赋值

null 合并运算符**??** ，已经在 C# 8 中得到扩展，以支持赋值。 null合并操作符的一种常见用法是在方法开始时进行参数检查，如下例所示:

```cs
class Person
{
    public Person(string firstName, string lastName, int age)
    {
        this.FirstName = firstName ?? throw new ArgumentNullException(nameof(firstName));
        this.LastName = lastName ?? throw new ArgumentNullException(nameof(lastName));
        this.Age = age;
    }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int Age { get; set; }
}
```

新的赋值允许我们在引用为空时重新赋值，如下面的例子所示:

```cs
void Accumulate(ref List<string> list, params string[] words)
{
    list ??= new List<string>();
    list.AddRange(words);
}
```

参数列表最初可以为空，在这种情况下，它将被重新赋值给一个新的实例，但接下来的几次，赋值将不再发生:

```cs
List<string> x = null;
Accumulate(ref x, "one", "two");
Accumulate(ref x, "three");
Assert.IsTrue(x.Count == 3);
```

null 合并赋值看起来不是很重要，但是它执行最右边表达式的能力是一个你不应该低估的大值。

# 静态局部函数

引入了局部函数，通过将特定代码片段的可见性限制为单个方法，使代码更具可读性:

```cs
void PrintName(Person person)
{
    var p = person ?? throw new ArgumentNullException(nameof(person));
    Console.WriteLine(Obfuscated());
    string Obfuscated()
    {
        if (p.Age < 18) return $"{p.FirstName[0]}. {p.LastName[0]}.";
        return $"{p.FirstName} {p.LastName}"; 
    }
}
```

在这个例子中,**混淆方法只能使用**PrintName**和的优点是能够忽略任何参数检查,因为上下文捕获的**p 参数是不允许使用它的值是 null。 这可以在复杂的场景中提供性能优势，但它捕获本地变量(包括**This**)的能力可能令人困惑。****

 **在 C# 8 中，现在可以通过将本地函数标记为 static 来避免任何捕获:

```cs
private void PrintName(Person person)
{
    var p = person ?? throw new ArgumentNullException(nameof(person));
    Console.WriteLine(Obfuscated(p));
    static string Obfuscated(Person p)
    {
        if (p.Age < 18) return $"{p.FirstName[0]}. {p.LastName[0]}.";
        return $"{p.FirstName} {p.LastName}";
    }
}
```

该方法的新版本增强了其自我描述的能力，同时仍然具有由于已知上下文而忽略任何参数-检查的优势。 值得注意的是，捕获通常不是性能方面的问题，但会严重影响可读性，因为与 c++ lambdas 等其他语言相比，C# 在默认情况下允许自动捕获。

# 更好地插入了逐字字符串

我们已经知道了字符串字面量支持一些*变体*以避免转义字符:

```cs
string s1 = "c:\\temp";
string s2 = @"c:\temp";
Assert.AreEqual(s1, s2);
```

由于插值，它们也可以用来改进格式:

```cs
var s3 = $"The path for {folder} is c:\\{folder}";
```

自从引入内插字符串以来，我们一直能够混合这两种格式风格:

```cs
var s4 = $@"The path for {folder} is c:\{folder}";
Assert.AreEqual(s3, s4);
```

但是在 C# 8 之前，不可能将**$**和**@**字符倒置:

```cs
var s5 = @$"The path for {folder} is c:\{folder}";
Assert.AreEqual(s3, s5);
```

有了这个小小的改进，您就不必为前缀的顺序操心了。

# 在嵌套表达式中使用 stackalloc

C # 7,我们开始使用**跨度<>**,**ReadOnlySpan<>**,<和**记忆 T>**,因为是【显示】ref 结构保证实例分配在堆栈上,因此不会影响垃圾收集器。 多亏了**Span**，也可以避免将直接赋给**Span**或**ReadOnlySpan**的**stackalloc**语句声明为不安全的:

```cs
Span<int> nums = stackalloc int[10];
```

从 C# 8 开始，编译器将**stackalloc**的使用扩展到期望**Span**或**ReadOnlySpan**的任何表达式。 在下面的示例中，测试从三个特殊字符中裁剪出**输入**字符串，得到**期望的**变量中指定的字符串:

```cs
string input = " this string can be trimmed \r\n";
var expected = "this string can be trimmed";
ReadOnlySpan<char> trimmedSpan = input.AsSpan()
    .Trim(stackalloc[] { ' ', '\r', '\n' });
string result = trimmedSpan.ToString();
Assert.AreEqual(expected, result);
```

上述示例的操作如下:

*   **AsSpan**扩展方法将字符串转换为**ReadOnlySpan<char>**。
*   **Trim**扩展方法将**ReadOnlySpan<char>**的边界缩小为**stackalloc**数组指定的字符。 这个**Trim**方法不需要任何分配。
*   最后，调用**ToString**方法从**ReadOnlySpan<char>**中创建一个新字符串。

这段代码的优点是，除了新的**int[]**表达式(用于验证测试)和**ToString**方法(用于创建结果)之外，不执行其他堆分配。

# 非托管构造类型

在深入研究这个新的 C# 特性之前，有必要通过分析语言规范中引用的**非托管**和**构造类型**的定义来理解这个主题:**** 

***   如果类型是泛型且类型参数已经定义，则称为构造的类型。 例如，**List<string>**是构造类型，而**List<T>**不是构造类型。**
*   **如果类型可以在不安全的上下文中使用，则称为**非托管**。 许多内置基本类型都是如此。 官方文件包括这些类型的列表: **sbyte**,**字节**,**【显示】,**ushort**,**int【病人】,**使用 uint**,**【t16.1】,**ulong**,**char**,**,**双**,**小数**,**bool**,**枚举**,**指针**,**结构**。**********

一个在 C# 8 之前无法声明的非托管构造类型的示例如下:

```cs
struct Header<T>
{
    T Word1;
    T Word2;
    T Word3;
}
```

允许非管理泛型结构的两个主要优点如下:

*   可以使用**stackalloc**在堆栈上分配它们。
*   我们可以将这些类型与指针和不安全代码一起使用，以便与本地代码进行互操作。 这在处理字段可能是 32 位或 64 位的本地块时很有用:

```cs
Span<Header<int>> records1 = stackalloc Header<int>[10];
Span<Header<long>> records2 = stackalloc Header<long>[10];
```

有了这个特性，语言规范正朝着简化本机互操作性的方向发展，而不会造成过去需要使用 C 或 c++语言才能达到的性能损失。

# 总结

毫无疑问，C# 8 的新特性在代码的健壮性和清晰度方面是一个重要的里程碑。 一种语言(一个版本接着一个版本)变得越来越复杂和难以阅读，这并不罕见，但 C# 引入了模式匹配和范围等特性，允许任何开发人员用更简洁和明确的代码表达他们的意图。

尽管存在争议，但默认接口成员将 Traits 范例引入了.NET 世界，并解决了诸如接口版本控制等问题，这让开发人员苦苦挣扎了数年。

我们了解了一个关键特性，即内置的可空引用静态代码分析，它允许我们逐步检查代码，并显著减少由于解引用空引用而导致的错误数量。

这还不是为提高生产力而对语言进行调调的结束，因为我们继续 C# 7 的性能之路，使用异步流、只读结构成员、对**stackalloc**和非托管构造类型的更新， 所有这些结合在一起使 C# 成为本地语言中令人瞩目的竞争对手，同时仍然加强了代码安全性。

其他较小的特性，如使用声明的简洁**、异步**Dispose**、可处理模式、静态局部函数、插入字符串的固定以及 null 合并赋值，都非常容易记住，并且具有实际的优点。**

新的语言特性不仅是开发人员的瑞士军刀上的额外工具，而且是一个改进代码库的巨大机会。 如果我们回到过去，回想一下 C# 2.0 中引入的泛型类型，它们将生产力和性能提高了好几个数量级。 后来，该语言引入了 LINQ 查询、lambda 表达式和扩展方法，从而带来了更多的表达性，并开辟了新的设计策略，这在之前是非常困难的。 编程语言的整个历史，不仅仅是 C#，其特点是针对现代开发需求的改进。 现在，通过采用**持续集成/持续交付**(**CI/CD**)管道，应用开发明显地面向更短的开发生命周期，这带来了对代码质量和生产力的强烈要求。 从更广泛的角度来看，毫无疑问，任何开发人员都必须了解最新的语言特性。

在下一章中，我们将学习.NET Core 3 如何将语言形式转化为运行代码，无论是在 Windows 上还是在 Linux 上。 我们将创建一个可以从任何.NET 运行时版本中使用的库; 消费包装，这才是这个生态系统真正丰富的地方; 最后，发布应用，将我们所有的工作转化为对最终用户的巨大价值。

# 测试你所学的内容

1.  如何最小化代码中**NullReferenceException**异常的数量?
2.  读取数组中最后一项的最佳语法是什么?
3.  当使用**switch**表达式时，哪个关键字等同于使用丢弃字符(_)?
4.  如何在**Dispose**方法中等待异步调用关闭一个文件?
5.  当在下面的语句中分配**orders**变量时，是否每次执行都调用方法调用?

    ```cs
    var orders ??= GetOrders();
    ```

6.  定义一个序列为**IAsyncEnumerable**是必须的吗?它需要用新的**async foreach**语句来迭代?

# 进一步阅读

如果你想了解 C# 的发展，你可以在 GitHub 的 https://github.com/dotnet/csharplang 上查看关于该语言下一个版本的建议和对话[。](https://github.com/dotnet/csharplang)***************************