# 07

# 打包和分发.NET 类型

本章介绍 C#关键字与.NET 类型的关系，以及名称空间和程序集之间的关系。您还将熟悉如何打包和发布.NET 应用程序和库以供跨平台使用，如何在.NET 库中使用遗留.NET Framework 库，以及将遗留.NET Framework 代码库移植到现代.NET 的可能性。

本章涵盖以下主题：

*   通往.NET 6 的道路
*   了解.NET 组件
*   发布应用程序以进行部署
*   反编译.NET 程序集
*   为 NuGet 发行版打包库
*   从.NET Framework 移植到现代.NET
*   使用预览功能

# 通往.NET 6 的道路

本书的这一部分是关于.NET 提供的**基类库**（**BCL**API 中的功能以及如何使用.NET 标准在所有不同的.NET 平台上重用功能的。

首先，我们将回顾到这一点的路线，以及为什么理解过去很重要。

.NET Core 2.0 及更高版本对最低限度的.NET 标准 2.0 的支持非常重要，因为它提供了许多在.NET Core 的第一个版本中缺失的 API。.NET Framework 开发人员提供给他们的与现代开发相关的 15 年库和应用程序现在已经迁移到.NET，可以在 macOS 和 Linux 变体以及 Windows 上跨平台运行。

.NET 标准 2.1 增加了大约 3000 个新 API。其中一些 API 需要运行时更改，这会破坏向后兼容性，因此.NET Framework 4.8 只实现.NET 标准 2.0。NET 核心 3.0、Xamarin、Mono 和 Unity 实现.NET 标准 2.1。

如果所有项目都可以使用.NET 6，则.NET 6 不再需要.NET 标准。由于您可能仍然需要为旧式.NET Framework 项目或旧式 Xamarin 移动应用程序创建类库，因此仍然需要创建.NET 标准 2.0 和 2.1 类库。2021 年 3 月，我调查了专业开发人员，其中一半仍然需要创建符合.NET 标准 2.0 的类库。

既然.NET 6已经发布了对使用.NET MAUI 构建的移动和桌面应用程序的预览支持，对.NET 标准的需求已经进一步减少。

为了总结.NET 在过去五年中取得的进展，我将主要的.NET 核心版本和现代.NET 版本与下表中的等效.NET Framework 版本进行了比较：

*   **.NET Core 1.x**：与 2016 年 3 月的当前版本.NET Framework 4.6.1 相比，API 要小得多。
*   **.NET Core 2.x**：对于现代 API，达到了与.NET Framework 4.7.1 的API 平价，因为它们都实现了.NET 标准 2.0。
*   **.NET Core 3.x**：与现代 API 的.NET Framework 相比，更大的API，因为.NET Framework 4.8 没有实现.NET 标准 2.1。
*   **.NET 5**：与现代 API 的.NET Framework 4.8 相比，更大的API，性能大大提高。
*   **.NET 6**：最终统一，支持.NET 毛伊岛的移动应用，预计 2022 年 5 月实现。

## .NET 核心 1.0

.NET Core 1.0 于 2016 年 6 月发布，专注于实现适用于构建现代跨平台应用程序的 API，包括使用 ASP.NET Core 的 Linux web 和云应用程序及服务。

## .NET 核心 1.1

.NET Core 1.1 于 2016 年 11 月发布，专注于修复漏洞、增加支持的 Linux 发行版数量、支持.NET 标准 1.6 和提高性能，特别是针对 web 应用和服务的 ASP.NET Core。

## .NET 核心 2.0

.NET Core 2.0 于 2017 年 8 月发布，专注于实施.NET 标准 2.0、引用.NET Framework 库的能力以及更多性能改进。

本书第三版于 2017 年 11 月出版，涵盖了**通用 Windows 平台**（**UWP**应用的.NET Core 2.0 和.NET Core。

## .NET 核心 2.1

.NET Core 2.1 于 2018 年 5 月发布，专注于可扩展的工具系统，添加了新类型，如用于加密和压缩的`Span<T>`，新 API，一个 Windows 兼容包，包含额外 20000 个 API，以帮助移植旧 Windows 应用程序，实体框架核心值转换，LINQ`GroupBy`转换，数据种子设定、查询类型以及更多性能改进，包括下表中列出的主题：

<colgroup><col> <col> <col></colgroup> 
| 特色 | 章 | 话题 |
| 跨度 | 8. | 使用跨距、索引和范围 |
| 布罗特利压缩 | 9 | Brotli 算法的压缩 |
| 密码学 | 20 | 密码学的新功能是什么？ |
| EF 内核延迟加载 | 10 | 启用延迟加载 |
| EF 核心数据种子 | 10 | 理解数据播种 |

## .NET 核心 2.2

.NET Core 2.2 于 2018 年 12 月发布，重点关注运行时的诊断改进、可选的分层编译，以及使用**NetTopologySuite**（**NTS**库中的类型、查询标记、，以及所有实体的集合。

## .NET 核心 3.0

NET 核心 3 在 2019 年 9 月发布并专注于添加支持使用 Windows 窗体（2001）、Windows Type Foundation Posiy T2（Advutt3，WPF Po.T4；2006）和实体框架 6.3、并排和 App 本地部署、支持 JSON 阅读器的 Windows 应用程序 T0 桌面应用程序的构建。**物联网**（**物联网**解决方案）串口接入和其他引脚接入，默认分层编译，包括下表所列主题：

<colgroup><col> <col> <col></colgroup> 
| 特色 | 章 | 话题 |
| 在应用程序中嵌入.NET | 7. | 发布应用程序以进行部署 |
| `Index`和`Range` | 8. | 使用跨距、索引和范围 |
| `System.Text.Json` | 9 | 高性能 JSON 处理 |
| 异步流 | 12 | 使用异步流 |

本书第四版于 2019 年 10 月出版，因此涵盖了在.NET Core 3.0 之前的更高版本中添加的一些新 API。

## .NET 核心 3.1

.NET Core 3.1 于 2019 年 12 月发布，专注于缺陷修复和改进，因此它可以成为**长期支持**（**LTS**版本），直到 2022 年 12 月才失去支持。

## .NET 5.0

.NET 5.0 于 2020 年 11 月发布，专注于统一除移动平台以外的各种.NET 平台，完善平台，提高性能，包括下表所列主题：

<colgroup><col> <col> <col></colgroup> 
| 特色 | 章 | 话题 |
| `Half`型 | 8. | 与数字打交道 |
| 正则表达式性能改进 | 8. | 正则表达式性能改进 |
| `System.Text.Json`改进 | 9 | 高性能 JSON 处理 |
| EF 核心生成的 SQL | 10 | 获取生成的 SQL |
| EF 核心过滤包括 | 10 | 筛选包含的实体 |
| EF 核心脚手架 DbContext 现在使用 Humanizer 实现奇异化 | 10 | 使用现有数据库构建模型 |

## .NET6.0

.NET 6.0 于 2021 年 11 月发布，专注于与移动平台的统一，为 EF Core 添加更多数据管理功能，提高性能，包括下表所列主题：

<colgroup><col> <col> <col></colgroup> 
| 特色 | 章 | 话题 |
| 检查.NET SDK 状态 | 7. | 正在检查.NET SDK 的更新 |
| 对苹果硅的支持 | 7. | 创建要发布的控制台应用程序 |
| 默认为链接修剪模式 | 7. | 使用应用程序修剪减少应用程序的大小 |
| `DateOnly`和`TimeOnly` | 8. | 指定日期和时间值 |
| `EnsureCapacity`用于`List<T>` | 8. | 通过确保集合的容量提高性能 |
| EF 核心配置约定 | 10 | 配置预约模型 |
| 新的 LINQ 方法 | 11 | 使用可枚举类构建 LINQ 表达式 |

## 将性能从.NET Core 2.0 提高到.NET 5

在过去几年中，微软在性能方面取得了显著的改进。您可以通过以下链接阅读详细的博客帖子：[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/) 。

## 正在检查.NET SDK 的更新

在.NET 6 中，Microsoft 添加了一个命令来检查您安装的.NET SDK 和运行时版本，并在需要更新时警告您。例如，输入以下命令：

```
dotnet sdk check 
```

然后，您将看到结果，包括可用更新的状态，如以下部分输出所示：

```
.NET SDKs:
Version                         Status
-----------------------------------------------------------------------------
3.1.412                         Up to date.
5.0.202                         Patch 5.0.206 is available.
... 
```

# 了解.NET 组件

.NET 由几部分组成，如下表所示：

*   **语言编译器**：这些编译器将使用 C、F 和 VisualBasic 等语言编写的源代码转换为**中间语言**（**IL**代码存储在程序集中。随着 C#6.0 及更高版本的出现，微软转而使用开源的重写编译器 Roslyn，该编译器也被 VisualBasic 使用。
*   **公共语言运行时（CORECRL）**：此运行时加载程序集，将其中存储的 IL 代码编译为计算机 CPU 的本机代码指令，并在管理线程和内存等资源的环境中执行代码。
*   **基类库（BCL 或 CoreFX）**：这些是预构建的程序集，类型为打包和分发的，在构建应用程序时使用 NuGet 执行常见任务。您可以使用它们快速构建您想要的任何东西，就像组合乐高一样™ 碎片。NET Core 2.0 实现了.NET 标准 2.0，它是所有早期版本的.NET 标准的超集，并将.NET Core 提升到与.NET Framework 和 Xamarin 对等的水平。NET Core 3.0 实现了.NET 标准 2.1，该标准增加了新的功能，并实现了超出.NET Framework 中可用功能的性能改进。NET6 在所有类型的应用程序（包括移动应用程序）中实现统一的 BCL。

## 了解程序集、NuGet 包和名称空间

**程序集**是文件系统中存储类型的地方。程序集是部署代码的机制。例如，`System.Data.dll`程序集包含用于管理数据的类型。若要在其他程序集中使用类型，必须引用它们。程序集可以是静态（预创建）或动态（在运行时生成）。动态程序集是一个高级功能，我们在本书中将不介绍它。程序集可以作为 DLL（类库）或 EXE（控制台应用程序）编译成单个文件。

程序集作为**NuGet 程序包**分发，这些程序包是可从公共在线订阅源下载的文件，可以包含多个程序集和其他资源。您还将了解到**项目 SDK**、**工作负载**和**平台**，它们是 NuGet 软件包的组合。

Microsoft 的 NuGet 提要可在此处找到：[https://www.nuget.org/](https://www.nuget.org/) 。

### 什么是名称空间？

名称空间是类型的地址。名称空间是一种通过要求完整地址而不仅仅是短名称来唯一标识类型的机制。在现实世界中，桑树街 34 号的*鲍勃与柳路 12 号*的*鲍勃不同。*

在.NET 中，`System.Web.Mvc`命名空间的`IActionFilter`接口与`System.Web.Http.Filters`命名空间的`IActionFilter`接口不同。

### 理解依赖程序集

如果一个程序集被编译为类库，并提供类型供其他程序集使用，则该程序集具有文件扩展名`.dll`（**动态链接库**），不能独立执行。

同样，如果程序集被编译为应用程序，那么它具有文件扩展名`.exe`（**可执行文件**），并且可以独立执行。在.NET Core 3.0 之前，控制台应用程序被编译成`.dll`文件，必须通过`dotnet run`命令或主机可执行文件执行。

任何程序集都可以作为依赖项引用一个或多个类库程序集，但不能具有循环引用。因此，如果组件*A*已经引用组件*B*，那么组件*B*就不能引用组件*A*。如果您试图添加会导致循环引用的依赖项引用，编译器将发出警告。循环引用通常是糟糕代码设计的警告标志。如果确定需要循环引用，请使用接口来解决它。

## 了解 Microsoft.NET project SDK

默认情况下，控制台应用程序在 Microsoft.NET project SDK 上具有依赖项引用。这个平台包含几乎所有应用程序都需要的 NuGet 包中的数千种类型，例如`System.Int32`和`System.String`类型。

使用.NET 时，在项目文件中引用应用程序所需的依赖程序集、NuGet 包和平台。

让我们探讨程序集和名称空间之间的关系：

1.  使用您首选的代码编辑器创建名为`Chapter07`的新解决方案/工作区。
2.  添加控制台应用程序项目，如以下列表中所定义：
    1.  项目模板：**控制台应用**/`console`
    2.  工作区/解决方案文件和文件夹：`Chapter07`
    3.  项目文件和文件夹：`AssembliesAndNamespaces`
3.  打开`AssembliesAndNamespaces.csproj`并注意它是.NET 6 应用程序的典型项目文件，如以下标记所示：

    ```
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
      </PropertyGroup>
    </Project> 
    ```

## 了解程序集中的名称空间和类型

`System.Runtime.dll`程序集中有许多常见的.NET 类型。程序集和名称空间之间并不总是存在一对一的映射。单个程序集可以包含许多名称空间，并且可以在许多程序集中定义名称空间。您可以看到某些程序集与其提供类型的名称空间之间的关系，如下表所示：

<colgroup><col> <col> <col></colgroup> 
| 装配 | 示例名称空间 | 示例类型 |
| `System.Runtime.dll` | `System`、`System.Collections`、`System.Collections.Generic` | `Int32`、`String`、`IEnumerable<T>` |
| `System.Console.dll` | `System` | `Console` |
| `System.Threading.dll` | `System.Threading` | `Interlocked`、`Monitor`、`Mutex` |
| `System.Xml.XDocument.dll` | `System.Xml.Linq` | `XDocument`、`XElement`、`XNode` |

## 理解 NuGet 包

NET 被分成一组包，使用 Microsoft 支持的名为 NuGet 的包管理技术分发。这些包中的每一个都代表一个同名的程序集。例如，`System.Collections`包包含`System.Collections.dll`程序集。

以下是套餐的好处：

*   包可以很容易地在公共提要上分发。
*   包可以重用。
*   包裹可以按照自己的时间表发货。
*   软件包可以独立于其他软件包进行测试。
*   通过包含为不同操作系统和 CPU 构建的同一程序集的多个版本，软件包可以支持不同的操作系统和 CPU。
*   包只能具有特定于一个库的依赖项。
*   应用程序较小，因为未引用的软件包不属于发行版的一部分。下表列出了一些更重要的软件包及其重要类型：

<colgroup><col> <col></colgroup> 
| 包裹 | 重要类型 |
| `System.Runtime` | `Object`、`String`、`Int32`、`Array` |
| `System.Collections` | `List<T>`、`Dictionary<TKey, TValue>` |
| `System.Net.Http` | `HttpClient`、`HttpResponseMessage` |
| `System.IO.FileSystem` | `File`、`Directory` |
| `System.Reflection` | `Assembly`、`TypeInfo`、`MethodInfo` |

## 理解框架

框架和包之间存在双向关系。包定义 API，而框架对包进行分组。没有任何包的框架不会定义任何 API。

.NET 包每个都支持一组框架。例如，`System.IO.FileSystem`包版本 4.3.0 支持以下框架：

*   .NET 标准，1.3 版或更高版本。
*   .NET Framework，版本 4.6 或更高版本。
*   Six Mono and Xamarin platforms (for example, Xamarin.iOS 1.0).

    **更多信息**：您可以通过以下链接阅读详细信息：[https://www.nuget.org/packages/System.IO.FileSystem/](https://www.nuget.org/packages/System.IO.FileSystem/) 。

## 导入命名空间以使用类型

让我们探讨名称空间与程序集和类型的关系：

1.  在`AssembliesAndNamespaces`项目中，在`Program.cs`中输入以下代码：

    ```
    XDocument doc = new(); 
    ```

2.  Build the project and note the compiler error message, as shown in the following output:

    ```
    The type or namespace name 'XDocument' could not be found (are you missing a using directive or an assembly reference?) 
    ```

    无法识别`XDocument`类型，因为我们没有告诉编译器该类型的名称空间是什么。尽管此项目已经有了对包含该类型的程序集的引用，但我们还需要在类型名称前面加上名称空间，或者导入名称空间。

3.  在`XDocument`类名内单击。您的代码编辑器显示一个灯泡，表明它可以识别该类型并自动为您解决问题。
4.  点击灯泡，从菜单中选择`using System.Xml.Linq;`。

这将*通过在文件顶部添加`using`语句来导入名称空间*。一旦在代码文件的顶部导入了名称空间，那么名称空间中的所有类型都可以在该代码文件中使用，只需键入它们的名称，而不需要使用名称空间作为前缀来完全限定类型名称。

有时，我喜欢在导入名称空间后添加类型名称的注释，以提醒我为什么需要导入该名称空间，如以下代码所示：

```
using System.Xml.Linq; // XDocument 
```

## 将 C#关键字与.NET 类型关联

我从新的 C#程序员那里得到的一个常见问题是，“带小写 s 的`string`和带大写 s 的`String`有什么区别？”

简短的答案很简单：没有。很长的答案是，所有 C#type 关键字，如`string`或`int`都是类库程序集中.NET 类型的别名。

当您使用`string`关键字时，编译器会将其识别为`System.String`类型。当您使用`int`类型时，编译器会将其识别为`System.Int32`类型。

让我们通过一些代码来了解这一点：

1.  在`Program.cs`中，声明两个变量来保存`string`值，一个使用小写`string`，一个使用大写`String`，如下代码所示：

    ```
    string s1 = "Hello"; 
    String s2 = "World";
    WriteLine($"{s1} {s2}"); 
    ```

2.  运行代码，注意到目前，它们都工作得同样好，字面意思是相同的。
3.  在`AssembliesAndNamespaces.csproj`中，添加条目以防止`System`名称空间被全局导入，如下标记所示：

    ```
    <ItemGroup>
      <Using Remove="System" />
    </ItemGroup> 
    ```

4.  在`Program.cs`中注意编译器错误消息，如以下输出所示：

    ```
    The type or namespace name 'String' could not be found (are you missing a using directive or an assembly reference?) 
    ```

5.  在`Program.cs`的顶部，导入带有`using`语句的`System`名称空间，该语句将修复错误，如下代码所示：

    ```
    using System; // String 
    ```

**良好实践**：当您有选择时，请使用 C#关键字而不是实际类型，因为这些关键字不需要导入名称空间。

### 将 C#别名映射到.NET 类型

下面的表显示了 18 个 C#type 关键字以及它们的实际.NET 类型：

<colgroup><col> <col> <col> <col></colgroup> 
| 关键词 | .NET 类型 | 关键词 | .NET 类型 |
| `string` | `System.String` | `char` | `System.Char` |
| `sbyte` | `System.SByte` | `byte` | `System.Byte` |
| `short` | `System.Int16` | `ushort` | `System.UInt16` |
| `int` | `System.Int32` | `uint` | `System.UInt32` |
| `long` | `System.Int64` | `ulong` | `System.UInt64` |
| `nint` | `System.IntPtr` | `nuint` | `System.UIntPtr` |
| `float` | `System.Single` | `double` | `System.Double` |
| `decimal` | `System.Decimal` | `bool` | `System.Boolean` |
| `object` | `System.Object` | `dynamic` | `System.Dynamic.DynamicObject` |

其他.NET 编程语言编译器也可以做同样的事情。对于示例，VisualBasic.NET 语言有一个名为`Integer`的类型，它是`System.Int32`的别名。

#### 理解本机大小的整数

C#9 为**本机大小的整数**引入了`nint`和`nuint`关键字别名，这意味着整数值的存储大小是特定于平台的。在 32 位进程中存储 32 位整数，`sizeof()`返回 4 字节；它们在 64 位进程中存储一个 64 位整数，`sizeof()`返回 8 个字节。别名表示指向内存中整数值的指针，这就是为什么它们的.NET 名称为`IntPtr`和`UIntPtr`。实际存储类型为`System.Int32`或`System.Int64`，具体取决于流程。

在 64 位进程中，以下代码：

```
WriteLine($"int.MaxValue = {int.MaxValue:N0}");
WriteLine($"nint.MaxValue = {nint.MaxValue:N0}"); 
```

生成此输出：

```
int.MaxValue = 2,147,483,647
nint.MaxValue = 9,223,372,036,854,775,807 
```

### 显示类型的位置

代码编辑器为.NET 类型提供内置文档。让我们探讨一下：

1.  在`XDocument`内点击鼠标右键，选择**进入定义**。
2.  Navigate to the top of the code file and note the assembly filename is `System.Xml.XDocument.dll`, but the class is in the `System.Xml.Linq` namespace, as shown in *Figure 7.1*:

    <figure class="mediaobject">![Graphical user interface, text, application, email  Description automatically generated](../Images/B17442_07_01.png)</figure>

    图 7.1：包含 XDocument 类型的程序集和命名空间

3.  关闭**XDocument【来自元数据】**选项卡。
4.  在`string`或`String`内点击鼠标右键，选择**进入定义**。
5.  导航到代码文件的顶部，注意程序集文件名为`System.Runtime.dll`，但类位于`System`命名空间中。

实际上，你的代码编辑器在技术上对你撒谎。如果您还记得我们在*第 2 章*中编写代码时，*说的是 C#*，当我们揭示 C#词汇表的范围时，我们发现`System.Runtime.dll`程序集包含零类型。

它包含的是类型转发器。这些是看起来存在于程序集中但实际上在其他地方实现的特殊类型。在本例中，它们是使用高度优化的代码在.NET 运行时的深处实现的。

## 使用.NET 标准与旧版平台共享代码

在.NET 标准之前，有**可移植类库**（**PCLs**）。使用 PCLs，您可以创建一个代码库，并明确指定希望库支持哪些平台，如 Xamarin、Silverlight 和 Windows 8。然后，您的库可以使用指定平台支持的API 的交叉点。

微软意识到这是不可持续的，所以他们创建了.NET 标准—一个未来所有.NET 平台都支持的单一 API。有较旧版本的.NET 标准，但.NET 标准 2.0 试图统一最近所有重要的.NET 平台。NET 标准 2.1 于 2019 年底发布，但只有.NET Core 3.0 和当年的 Xamarin 版本支持其新功能。在本书的其余部分，我将使用术语.NET 标准来表示.NET 标准 2.0。

.NET 标准与 HTML5 相似，因为它们都是平台应该支持的标准。正如谷歌的 Chrome 浏览器和微软的 Edge 浏览器实现 HTML5 标准一样，.NET 核心、.NET 框架和 Xamarin 都实现.NET 标准。如果您想创建一个可以跨遗留.NET 变体工作的类型库，可以使用.NET 标准轻松地创建。

**良好实践**：由于.NET 标准 2.1 中添加的许多 API 需要运行时更改，并且.NET Framework 是 Microsoft 的遗留平台，需要尽可能保持不变，.NET Framework 4.8 保留在.NET 标准 2.0 上，而不是实现.NET 标准 2.1。如果您需要支持.NET Framework 客户，那么您应该在.NET Standard 2.0 上创建类库，即使它不是最新的，也不支持所有最新的语言和新功能。

您选择哪个.NET 标准版本作为目标，这取决于最大化平台支持和可用功能之间的平衡。较低版本支持更多平台，但 API 集较小。更高的版本支持更少的平台，但具有更大的 API 集。通常，您应该选择支持所需所有 API 的最低版本。

## 了解具有不同 SDK 的类库的默认值

当使用`dotnet`SDK 工具创建类库时，了解默认使用哪个目标框架可能会很有用，如下表所示：

<colgroup><col> <col></colgroup> 
| SDK | 新类库的默认目标框架 |
| .NET 核心 3.1 | `netstandard2.0` |
| .NET 5 | `net5.0` |
| .NET 6 | `net6.0` |

当然，仅仅因为默认情况下类库以特定版本的.NET 为目标并不意味着您在使用默认模板创建类库项目后无法对其进行更改。

您可以手动将目标框架设置为支持需要引用该库的项目的值，如下表所示：

<colgroup><col> <col></colgroup> 
| 类库目标框架 | 可由目标为的项目使用 |
| `netstandard2.0` | .NET Framework 4.6.1 或更高版本、.NET Core 2.0 或更高版本、.NET 5.0 或更高版本、Mono 5.4 或更高版本、Xamarin.Android 8.0 或更高版本、Xamarin.iOS 10.14 或更高版本 |
| `netstandard2.1` | .NET Core 3.0 或更高版本、.NET 5.0 或更高版本、Mono 6.4 或更高版本、Xamarin.Android 10.0 或更高版本、Xamarin.iOS 12.16 或更高版本 |
| `net5.0` | .NET 5.0 或更高版本 |
| `net6.0` | .NET 6.0 或更高版本 |

**良好实践**：始终检查类库的目标框架，必要时手动将其更改为更合适的框架。有意识地决定它应该是什么，而不是接受默认值。

## 创建.NET 标准 2.0 类库

我们将使用.NET 标准 2.0 创建一个类库，以便它可以在所有重要的.NET 遗留平台和 Windows、macOS 和 Linux 操作系统上的跨平台上使用，同时还可以访问一系列广泛的.NET API：

1.  使用您首选的代码编辑器将名为`SharedLibrary`的新类库添加到`Chapter07`解决方案/工作区。
2.  如果使用 Visual Studio 2022，当提示输入**目标框架**时，选择**.NET 标准 2.0**，然后将解决方案的启动项目设置为当前选择。
3.  如果使用 Visual Studio 代码，请包括一个到目标.NET Standard 2.0 的开关，如以下命令所示：

    ```
    dotnet new classlib -f netstandard2.0 
    ```

4.  如果使用 Visual Studio 代码，请选择`SharedLibrary`作为活动的 OmniSharp 项目。

**良好实践**：如果您需要创建使用.NET 6.0 中新功能的类型，以及只使用.NET 标准 2.0 功能的类型，那么您可以创建两个单独的类库：一个目标.NET 标准 2.0 和一个目标.NET 6.0。您将在*第 10 章*中看到这一点，*使用实体框架核心*处理数据。

手动创建两个类库的替代方法是创建一个支持多目标的类库。如果你想让我在下一版中增加一个关于多重目标的部分，请告诉我。您可以在这里阅读关于多目标的信息：[https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-目标](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting)。

## 控制.NETSDK

默认情况下，执行`dotnet`命令使用最新安装的.NET SDK。有时您可能想要控制使用哪个 SDK。

例如，第四版的一位读者希望他们的体验与使用.NET Core 3.1 SDK 的书籍步骤相匹配。但他们也安装了.NET5.0SDK，默认情况下使用该 SDK。如前一节所述，创建新类库时的行为更改为目标.NET 5.0 而不是.NET 标准 2.0，这让读者感到困惑。

您可以通过`global.json`文件控制默认使用的.NET SDK。`dotnet`命令在当前文件夹和上级文件夹中搜索`global.json`文件。

1.  在名为`ControlSDK`的`Chapter07`文件夹中创建一个子目录/文件夹。
2.  在 Windows 上，启动**命令提示符**或**Windows 终端**。在 macOS 上，启动**终端**。如果您使用的是 Visual Studio 代码，则可以使用集成终端。
3.  在`ControlSDK`文件夹中，在命令提示符或终端输入命令，创建一个`global.json`文件，强制使用最新的.NET Core 3.1 SDK，如下命令所示：

    ```
    dotnet new globaljson --sdk-version 3.1.412 
    ```

4.  Open the `global.json` file and review its contents, as shown in the following markup:

    ```
    {
      "sdk": {
        "version": "3.1.412"
      }
    } 
    ```

    您可以通过以下链接在表中找到最新.NET SDK 的版本号：[https://dotnet.microsoft.com/download/visual-studio-sdks](https://dotnet.microsoft.com/download/visual-studio-sdks)

5.  在`ControlSDK`文件夹中，在命令提示符或终端输入创建类库项目的命令，如下命令所示：

    ```
    dotnet new classlib 
    ```

6.  如果您没有安装.NET Core 3.1 SDK，那么您将看到一个错误，如以下输出所示：

    ```
    Could not execute because the application was not found or a compatible .NET SDK is not installed. 
    ```

7.  如果您确实安装了.NET Core 3.1 SDK，那么将创建一个默认以.NET Standard 2.0 为目标的类库项目。

您不需要完成上述步骤，但如果您想尝试并且尚未安装.NET Core 3.1 SDK，则可以通过以下链接进行安装：

[https://dotnet.microsoft.com/download/dotnet/3.1](https://dotnet.microsoft.com/download/dotnet/3.1)

# 发布用于部署的代码

如果你写了一本小说，你想让别人读，你必须出版它。

大多数开发人员编写代码供其他开发人员在自己的代码中使用，或供用户作为应用程序运行。为此，必须将代码发布为打包类库或可执行应用程序。

发布和部署.NET 应用程序有三种方法。他们是：

1.  **框架依赖部署**（**FDD**）。
2.  **框架相关可执行文件**（**FDEs**）。
3.  自给自足的。

如果您选择部署应用程序及其包依赖项，而不是部署.NET 本身，那么您依赖的是目标计算机上已经存在的.NET。这对于部署到服务器上的 web 应用程序非常有效，因为.NET 和许多其他 web 应用程序可能已经在服务器上。

**依赖于框架的部署**（**FDD**表示您部署一个必须由`dotnet`命令行工具执行的 DLL。**依赖于框架的可执行文件**（**FDE**表示您部署了一个可直接从命令行运行的 EXE。两者都要求系统上已安装.NET。

有时，您希望能够给某人一个包含您的应用程序的 U 盘，并知道它可以在他们的计算机上执行。您希望执行自包含部署。虽然部署文件的大小会更大，但您会知道它会起作用。

## 创建要发布的控制台应用程序

让我们探讨如何发布控制台应用程序：

1.  使用您首选的代码编辑器将名为`DotNetEverywhere`的新控制台应用程序添加到`Chapter07`解决方案/工作区。
2.  在 Visual Studio 代码中，选择`DotNetEverywhere`作为活动的 OmniSharp 项目。当您看到弹出警告消息说所需资产丢失时，单击**是**添加它们。
3.  在`Program.cs`中，删除注释并静态导入`Console`类。
4.  在`Program.cs`中，添加一条语句，输出控制台应用可以到处运行的消息，以及一些操作系统的信息，如下代码所示：

    ```
    WriteLine("I can run everywhere!");
    WriteLine($"OS Version is {Environment.OSVersion}.");
    if (OperatingSystem.IsMacOS())
    {
      WriteLine("I am macOS.");
    }
    else if (OperatingSystem.IsWindowsVersionAtLeast(major: 10))
    {
      WriteLine("I am Windows 10 or 11.");
    }
    else
    {
      WriteLine("I am some other mysterious OS.");
    }
    WriteLine("Press ENTER to stop me.");
    ReadLine(); 
    ```

5.  打开`DotNetEverywhere.csproj`并将运行时标识符添加到`<PropertyGroup>`元素内的目标三个操作系统，如以下标记中突出显示的：

    ```
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
     **<RuntimeIdentifiers>**
     **win10-x64;osx-x64;osx****.11.0****-arm64;linux-x64;linux-arm64**
     **</RuntimeIdentifiers>**
      </PropertyGroup>
    </Project> 
    ```

    *   `win10-x64`RID 值表示 Windows 10 或 Windows Server 2016 64 位。您还可以使用`win10-arm64`RID 值部署到 Microsoft Surface Pro X。
    *   `osx-x64`RID 值表示 macOS Sierra 10.12 或更高版本。您还可以指定特定于版本的 RID 值，如`osx.10.15-x64`（Catalina）、`osx.11.0-x64`（英特尔上的大苏尔）或`osx.11.0-arm64`（苹果硅上的大苏尔）。
    *   `linux-x64`RID 值表示大多数 Linux 桌面发行版，如 Ubuntu、CentOS、Debian 或 Fedora。将`linux-arm`用于 Raspbian 或 Raspberry Pi OS 32 位。对于运行 Ubuntu 64 位的 Raspberry Pi，请使用`linux-arm64`。

## 理解 dotnet 命令

当您安装NET SDK 时，它包含一个名为`dotnet`的**命令行界面（CLI）**。

### 创建新项目

.NET CLI 具有在当前文件夹上工作的命令，用于使用模板创建新项目：

1.  在 Windows 上，启动**命令提示符**或**Windows 终端**。在 macOS 上，启动**终端**。如果您使用的是 Visual Studio 代码，则可以使用集成终端。
2.  输入`dotnet new --list`或`dotnet new -l`命令，列出您当前安装的模板，如*图 7.2*：

    <figure class="mediaobject">![A picture containing text  Description automatically generated](../Images/B17442_07_02.png)</figure>

    所示

图 7.2：已安装的 dotnet 新项目模板列表

大多数`dotnet`命令行开关有长版本和短版本。例如，`--list`或`-l`。短字体打字更快，但更容易被你或其他人误解。有时打字越多越清晰。

## 获取有关.NET 及其环境的信息

查看当前安装的.NET SDK 和运行时以及有关操作系统的信息非常有用，如下命令所示：

```
dotnet --info 
```

注意结果，如以下部分输出所示：

```
.NET SDK (reflecting any global.json):
 Version:   6.0.100
 Commit:    22d70b47bc
Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.19043
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\6.0.100\
Host (useful for support):
  Version: 6.0.0
  Commit:  91ba01788d
.NET SDKs installed:
  3.1.412 [C:\Program Files\dotnet\sdk]
  5.0.400 [C:\Program Files\dotnet\sdk]
  6.0.100 [C:\Program Files\dotnet\sdk]
.NET runtimes installed:
  Microsoft.AspNetCore.All 2.1.29 [...\dotnet\shared\Microsoft.AspNetCore.All]
... 
```

## 管理项目

.NET CLI 具有以下命令，用于管理当前文件夹中的项目：

*   `dotnet restore`：下载项目的依赖项。
*   `dotnet build`：这个构建，也就是编译，这个项目。
*   `dotnet test`：为项目构建并运行单元测试。
*   `dotnet run`：构建并运行项目。
*   `dotnet pack`：这将为项目创建一个 NuGet 包。
*   `dotnet publish`：这将构建并发布项目，或者使用依赖项，或者作为一个自包含的应用程序。
*   `dotnet add`：将对包或类库的引用添加到项目中。
*   `dotnet remove`：这将从项目中删除对包或类库的引用。
*   `dotnet list`：列出项目的包或类库引用。

## 发布自包含的应用程序

现在您已经看到了一些`dotnet`工具命令示例，我们可以发布我们的跨平台控制台应用程序：

1.  在命令行中，确保您位于`DotNetEverywhere`文件夹中。
2.  输入命令以生成并发布 Windows 10 控制台应用程序的发布版本，如以下命令所示：

    ```
    dotnet publish -c Release -r win10-x64 
    ```

3.  注意：构建引擎恢复所有需要的包，将项目源代码编译成程序集 DLL，并创建一个`publish`文件夹，如以下输出所示：

    ```
    Microsoft (R) Build Engine version 17.0.0+073022eb4 for .NET
    Copyright (C) Microsoft Corporation. All rights reserved.
      Determining projects to restore...
      Restored C:\Code\Chapter07\DotNetEverywhere\DotNetEverywhere.csproj (in 46.89 sec).
      DotNetEverywhere -> C:\Code\Chapter07\DotNetEverywhere\bin\Release\net6.0\win10-x64\DotNetEverywhere.dll
      DotNetEverywhere -> C:\Code\Chapter07\DotNetEverywhere\bin\Release\net6.0\win10-x64\publish\ 
    ```

4.  Enter the commands to build and publish the release versions for macOS and Linux variants, as shown in the following commands:

    ```
    dotnet publish -c Release -r osx-x64
    dotnet publish -c Release -r osx.11.0-arm64
    dotnet publish -c Release -r linux-x64
    dotnet publish -c Release -r linux-arm64 
    ```

    **良好实践**：您可以使用 PowerShell 之类的脚本语言自动执行这些命令，并使用跨平台 PowerShell 内核在任何操作系统上执行。只需创建一个扩展名为`.ps1`的文件，上面有五条命令。然后执行该文件。通过以下链接了解有关 PowerShell 的更多信息：[https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell](https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell)

5.  打开 macOS**Finder**窗口或 Windows**文件管理器**，导航至`DotNetEverywhere\bin\Release\net6.0`，并记录各种操作系统的输出文件夹。
6.  在`win10-x64`文件夹中，选择`publish`文件夹，记录所有支撑组件，如`Microsoft.CSharp.dll`。
7.  Select the `DotNetEverywhere` executable file, and note it is 161 KB, as shown in *Figure 7.3*:

    <figure class="mediaobject">![Graphical user interface  Description automatically generated](../Images/B17442_07_03.png)</figure>

    图 7.3:64 位 Windows 10 的 DotNetEverywhere 可执行文件

8.  如果您在 Windows 上，则双击执行程序并记录结果，如以下输出所示：

    ```
    I can run everywhere!
    OS Version is Microsoft Windows NT 10.0.19042.0.
    I am Windows 10.
    Press ENTER to stop me. 
    ```

9.  请注意，`publish`文件夹及其所有文件的总大小为 64.8MB。
10.  在`osx.11.0-arm64`文件夹中，选择`publish`文件夹，记录所有支持组件，然后选择`DotNetEverywhere`可执行文件，注意可执行文件为 126KB，`publish`文件夹为 71.8MB。

如果您将这些`publish`文件夹中的任何一个复制到相应的操作系统，控制台应用程序将运行；这是因为它是一个自包含的可部署.NET 应用程序。例如，在使用 Intel 的 macOS 上，如以下输出所示：

```
I can run everywhere!
OS Version is Unix 11.2.3
I am macOS.
Press ENTER to stop me. 
```

本例使用了控制台应用程序，但您也可以轻松创建 ASP.NET 核心网站或 web 服务，或 Windows 窗体或 WPF 应用程序。当然，您只能将 Windows 桌面应用程序部署到 Windows 计算机，而不能部署到 Linux 或 macOS。

## 发布单个文件应用程序

要发布为“单个”文件，可以在发布时指定标志。在.NET5 中，单文件应用程序主要集中在 Linux 上，因为 Windows 和 macOS 都有限制，这意味着真正的单文件发布在技术上是不可能的。使用.NET 6，您现在可以在 Windows 上创建适当的单文件应用程序。

如果您可以假设.NET 6 已安装在您要运行应用程序的计算机上，则可以在发布应用程序以供发布时使用额外的标志，表示它不需要是自包含的，并且希望将其发布为单个文件（如果可能），如以下命令所示（必须在单行中输入）：

```
dotnet publish -r win10-x64 -c Release --self-contained=false
/p:PublishSingleFile=true 
```

这将生成两个文件：`DotNetEverywhere.exe`和`DotNetEverywhere.pdb`。`.exe`是可执行文件。`.pdb`文件是存储调试信息的**程序调试数据库**文件。

macOS 上已发布的应用程序没有`.exe`文件扩展名，因此如果在上面的命令中使用`osx-x64`，文件名将没有扩展名。

如果您希望在`.exe`文件中嵌入`.pdb`文件，则在`.csproj`文件的`<PropertyGroup>`元素中添加一个`<DebugType>`元素，并将其设置为`embedded`，如下标记所示：

```
<PropertyGroup>
  <OutputType>Exe</OutputType>
  <TargetFramework>net6.0</TargetFramework>
  <Nullable>enable</Nullable>
  <ImplicitUsings>enable</ImplicitUsings>
  <RuntimeIdentifiers>
    win10-x64;osx-x64;osx.11.0-arm64;linux-x64;linux-arm64
  </RuntimeIdentifiers>
 **<DebugType>embedded</DebugType>**
</PropertyGroup> 
```

如果您不能假定.NET 6 已经安装在计算机上，那么尽管 Linux 也只生成这两个文件，但 Windows 需要以下附加文件：`coreclr.dll`、`clrjit.dll`、`clrcompression.dll`和`mscordaccore.dll`。

让我们看看Windows 的一个示例：

1.  在命令行中，输入用于构建 Windows 10 控制台应用程序发布版本的命令，如以下命令所示：

    ```
    dotnet publish -c Release -r win10-x64 /p:PublishSingleFile=true 
    ```

2.  导航到`DotNetEverywhere\bin\Release\net6.0\win10-x64\publish`文件夹，选择`DotNetEverywhere`可执行文件，注意可执行文件现在是 58.3MB，还有一个`.pdb`文件是 10KB。系统上的大小会有所不同。

## 使用应用程序修剪减少应用程序的大小

将.NET 应用程序部署为自包含应用程序的问题之一是.NET 库占用大量空间。减小尺寸的最大需求之一是 Blazor WebAssembly 组件，因为所有的.NET 库都需要下载到浏览器中。

幸运的是，您可以通过不在部署中打包未使用的程序集来减少此大小。随着.NET Core 3.0 的推出，应用程序裁剪系统可以识别代码所需的程序集，并删除不需要的程序集。

在.NET5 中，通过从程序集中删除单个类型，甚至删除不使用的类似成员的方法，修剪工作更进一步。例如，使用 Hello World 控制台应用程序，`System.Console.dll`程序集从 61.5 KB 缩减到 31.5 KB。对于.NET5，这是一个实验性功能，因此在默认情况下是禁用的。

在.NET6 中，Microsoft 向其库中添加了注释，以指示如何安全地修剪它们，因此类型和成员的修剪成为默认设置。这称为**链路微调模式**。

关键在于修剪如何识别未使用的程序集、类型和成员。如果您的代码是动态的，可能使用反射，那么它可能无法正常工作，因此 Microsoft 也允许手动控制。

### 启用部件级修剪

有两种方法可以启用部件级修剪。

第一种方式是在项目文件中添加一个元素，如下图所示：

```
<PublishTrimmed>true</PublishTrimmed> 
```

第二种方法是在发布时添加标志，如以下命令中突出显示的：

```
dotnet publish ... **-p:PublishTrimmed=True** 
```

### 启用类型级别和成员级别修剪

有两种方式可以启用类型级别和成员级别修剪。

第一种方式是在项目文件中添加两个元素，如下图所示：

```
<PublishTrimmed>true</PublishTrimmed>
<TrimMode>Link</TrimMode> 
```

第二种方法是在发布时添加两个标志，如以下命令中突出显示的：

```
dotnet publish ... **-p:PublishTrimmed=True -p:TrimMode=Link** 
```

对于.NET 6，链接修剪模式是默认模式，因此如果要设置类似于`copyused`的替代修剪模式，则只需指定开关，这意味着部件级修剪。

# 反编译.NET 程序集

学习如何为.NET 编写代码的最佳方法之一就是看看专业人士是如何编写的。

**良好实践**：您可以出于非学习目的对其他人的程序集进行反编译，例如复制他们的代码供您自己的产品库或应用程序使用，但请记住，您正在查看他们的知识产权，因此请尊重这一点。

## 使用 VisualStudio2022 的 ILSpy 扩展进行反编译

出于学习目的，您可以使用 ILSpy 之类的工具反编译任何.NET 程序集。

1.  在 Visual Studio 2022 for Windows 中，导航到**扩展****管理扩展**。
2.  在搜索框中，输入`ilspy`。
3.  对于**ILSpy**扩展，请点击**下载**。
4.  点击**关闭**。
5.  关闭 Visual Studio 以允许安装扩展。
6.  重新启动 Visual Studio 并重新打开`Chapter07`解决方案。
7.  在**解决方案资源管理器**中，右键点击**DotNetEverywhere**项目，在 ILSpy 中选择**打开输出。**
8.  导航到**文件****打开…**。
9.  导航到以下文件夹：

    ```
    Code/Chapter07/DotNetEverywhere/bin/Release/net6.0/linux-x64 
    ```

10.  选择`System.IO.FileSystem.dll`组件，点击**打开**。
11.  在的**程序集**树中，展开**System.IO.FileSystem**程序集，展开**System.IO**命名空间，选择**目录**类，等待反编译。
12.  In the `Directory` class, click the **[+]** to expand the `GetParent` method, as shown in *Figure 7.4*:

    <figure class="mediaobject">![Graphical user interface, text, application  Description automatically generated](../Images/B17442_07_04.png)</figure>

    图 7.4:Windows 上目录类的反编译 GetParent 方法

13.  注意检查`path`参数并在`null`时抛出`ArgumentNullException`或在长度为零时抛出`ArgumentException`的良好实践。
14.  近距离侦察。

## 使用 VisualStudio 代码的 ILSpy 扩展进行反编译

一个类似的功能可以跨平台作为 VisualStudio 代码的扩展。

1.  如果您尚未安装 Visual Studio 代码的**ILSpy.NET 反编译器**扩展，请立即搜索并安装它。
2.  在 macOS 或 Linux 上，该扩展依赖于 Mono，因此您还需要从以下链接安装 Mono:[https://www.mono-project.com/download/stable/](https://www.mono-project.com/download/stable/) 。
3.  在 Visual Studio 代码中，导航到**视图**|**命令调色板……**。
4.  键入`ilspy`，然后选择**ILSpy:反编译 IL 程序集（拾取文件）**。
5.  导航到以下文件夹：

    ```
    Code/Chapter07/DotNetEverywhere/bin/Release/net6.0/linux-x64 
    ```

6.  Select the `System.IO.FileSystem.dll` assembly and click **Select assembly**. Nothing will appear to happen, but you can confirm that ILSpy is working by viewing the **Output** window, selecting **ilspy-vscode** in the dropdown list, and seeing the processing, as shown in *Figure 7.5*:

    <figure class="mediaobject">![Graphical user interface, text, application, email  Description automatically generated](../Images/B17442_07_05.png)</figure>

    图 7.5：选择要反编译的程序集时的 ILSpy 扩展输出

7.  In **EXPLORER**, expand **ILSPY DECOMPILED MEMBERS**, select the assembly, close the **Output** window, and note the two edit windows that open showing assembly attributes using C# code and external DLL and assembly references using IL code, as shown in *Figure 7.6*:

    <figure class="mediaobject">![Graphical user interface, text, application  Description automatically generated](../Images/B17442_07_06.png)</figure>

    图 7.6：扩展 ILSPY 反编译成员

8.  In the IL code on the right side, note the reference to the `System.Runtime` assembly, including the version number, as shown in the following code:

    ```
    .module extern libSystem.Native
    .assembly extern System.Runtime
    {
      .publickeytoken = (
        b0 3f 5f 7f 11 d5 0a 3a
      )
      .ver 6:0:0:0
    } 
    ```

    `.module extern libSystem.Native`表示此程序集对 Linux 系统 API 进行函数调用，正如您从与文件系统交互的代码中所期望的那样。如果我们反编译了这个程序集的 Windows 等价物，它将使用`.module extern kernel32.dll`，这是一个 Win32 API。

9.  In **EXPLORER**, in **ILSPY DECOMPILED MEMBERS**, expand the assembly, expand the **System.IO** namespace, select **Directory**, and note the two edit windows that open showing the decompiled `Directory` class using C# code on the left and IL code on the right, as shown in *Figure 7.7*:

    <figure class="mediaobject">![](../Images/B17442_07_07.png)</figure>

    图 7.7:C#和 IL 代码中的反编译目录类

10.  比较与`GetParent`方法的 C#源代码，如下代码所示：

    ```
    public static DirectoryInfo? GetParent(string path)
    {
      if (path == null)
      {
        throw new ArgumentNullException("path");
      }
      if (path.Length == 0)
      {
        throw new ArgumentException(SR.Argument_PathEmpty, "path");
      }
      string fullPath = Path.GetFullPath(path);
      string directoryName = Path.GetDirectoryName(fullPath);
      if (directoryName == null)
      {
        return null;
      }
      return new DirectoryInfo(directoryName);
    } 
    ```

11.  With the equivalent IL source code of the `GetParent` method, as shown in the following code:

    ```
    .method /* 06000067 */ public hidebysig static 
      class System.IO.DirectoryInfo GetParent (
        string path
      ) cil managed
    {
      .param [0]
        .custom instance void System.Runtime.CompilerServices
        .NullableAttribute::.ctor(uint8) = ( 
          01 00 02 00 00
        )
      // Method begins at RVA 0x62d4
      // Code size 64 (0x40)
      .maxstack 2
      .locals /* 1100000E */ (
        [0] string,
        [1] string
      )
      IL_0000: ldarg.0
      IL_0001: brtrue.s IL_000e
      IL_0003: ldstr "path" /* 700005CB */
      IL_0008: newobj instance void [System.Runtime]
        System.ArgumentNullException::.ctor(string) /* 0A000035 */
      IL_000d: throw
      IL_000e: ldarg.0
      IL_000f: callvirt instance int32 [System.Runtime]
        System.String::get_Length() /* 0A000022 */
      IL_0014: brtrue.s IL_0026
      IL_0016: call string System.SR::get_Argument_PathEmpty() /* 0600004C */
      IL_001b: ldstr "path" /* 700005CB */
      IL_0020: newobj instance void [System.Runtime]
        System.ArgumentException::.ctor(string, string) /* 0A000036 */
      IL_0025: throw IL_0026: ldarg.0
      IL_0027: call string [System.Runtime.Extensions]
        System.IO.Path::GetFullPath(string) /* 0A000037 */
      IL_002c: stloc.0 IL_002d: ldloc.0
      IL_002e: call string [System.Runtime.Extensions]
        System.IO.Path::GetDirectoryName(string) /* 0A000038 */
      IL_0033: stloc.1
      IL_0034: ldloc.1
      IL_0035: brtrue.s IL_0039 IL_0037: ldnull
      IL_0038: ret IL_0039: ldloc.1
      IL_003a: newobj instance void 
        System.IO.DirectoryInfo::.ctor(string) /* 06000097 */
      IL_003f: ret
    } // end of method Directory::GetParent 
    ```

    **良好实践**：如果你不了解 C#编译器如何将源代码翻译成 IL 代码，那么 IL 代码编辑窗口就不是特别有用，除非你在 C#和.NET 开发方面非常精通。更有用的编辑窗口包含由微软专家编写的等效 C#源代码。通过了解专业人员如何实现类型，您可以学到很多好的实践。例如，`GetParent`方法显示了如何检查`null`和其他参数异常的参数。

12.  关闭编辑窗口，不保存更改。
13.  在**资源管理器**中的**ILSPY 反编译成员**中，右键点击组件，选择**卸载组件**。

## 不，您不能从技术上阻止反编译

有时会有人问我是否有办法保护已编译代码以防止反编译。答案是否定的，如果你仔细想想，你就会明白为什么会这样。您可以使用模糊处理工具（如**Dotfuscator**）使其变得更加困难，但最终您无法完全阻止它。

所有编译后的应用程序都包含运行它的平台、操作系统和硬件的指令。这些指令在功能上必须与原始源代码相同，但对人来说更难阅读。这些指令必须可读，才能执行代码；因此，它们必须可读才能反编译。如果您使用一些自定义技术保护代码不被反编译，那么您还将阻止代码运行！

虚拟机模拟硬件，因此可以捕获正在运行的应用程序与其认为正在运行的软件和硬件之间的所有交互。

如果您可以保护您的代码，那么您还可以防止使用调试器附加到代码并单步执行它。如果编译的应用程序有一个`pdb`文件，那么您可以附加一个调试器并逐行遍历语句。即使没有`pdb`文件，您仍然可以附加调试器，了解代码的工作原理。

所有编程语言都是如此。不仅仅是.NET 语言，如 C++语言、Visual Basic 和 F 语言，还包括 C 语言、C++语言、Delphi 语言、汇编语言：它们都可以附加到调试或解体或反编译中。专业人员使用的一些工具如下表所示：

<colgroup><col> <col> <col></colgroup> 
| 类型 | 产品 | 描述 |
| 虚拟机 | VMware | 像恶意软件分析师这样的专业人士总是在虚拟机中运行软件。 |
| 调试器 | 软冰 | 在操作系统下运行，通常在 VM 中运行。 |
| 调试器 | WinDbg | 对于理解 Windows 内部结构非常有用，因为它比其他调试器更了解 Windows 数据结构。 |
| 拆卸器 | 艾达专业 | 由专业恶意软件分析师使用。 |
| 反编译器 | 六射线 | 反编译 C 应用程序。IDA Pro 的插件。 |
| 反编译器 | 戴德 | 反编译 Delphi 应用程序。 |
| 反编译器 | 多特皮克 | 来自 JetBrains 的.NET 反编译器。 |

**良好实践**：调试、反汇编和反编译他人的软件可能违反其许可协议，在许多司法管辖区是非法的。法律有时不是试图用技术解决方案来保护你的知识产权，而是你唯一的求助手段。

# 为 NuGet 发行版打包库

在我们学习如何创建和打包我们自己的库之前，我们将回顾一个项目如何使用现有的包。

## 引用 NuGet 包

假设您想要添加一个由第三方开发人员创建的包，例如`Newtonsoft.Json`，一个用于使用 JavaScript 对象表示法（JSON）序列化格式的流行包：

1.  在`AssembliesAndNamespaces`项目中，使用 Visual Studio 2022 的 GUI 或 Visual Studio 代码的`dotnet add package`命令，添加对`Newtonsoft.Json`NuGet 包的引用。
2.  打开`AssembliesAndNamespaces.csproj`文件，注意已经添加了一个包引用，如下标记所示：

    ```
    <ItemGroup>
      <PackageReference Include="newtonsoft.json" Version="13.0.1" />
    </ItemGroup> 
    ```

如果您有一个更新版本的`newtonsoft.json`包，那么它在本章编写之后已经更新。

### 修复依赖项

为了一致地恢复包并编写可靠的代码，您**修复依赖项**非常重要。修复依赖项意味着您正在使用为特定版本的.NET 发布的同一系列软件包，例如.NET 6.0 的 SQLite，如以下标记中突出显示的：

```
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
 **<PackageReference**
 **Include=****"Microsoft.EntityFrameworkCore.Sqlite"**
 **Version=****"6.0.0"** **/>**
  </ItemGroup>
</Project> 
```

要修复依赖关系，每个包都应该有一个没有附加限定符的单一版本。其他限定符包括 beta（`beta1`）、发行候选（`rc4`）和通配符（`*`）。

通配符允许自动引用和使用未来版本，因为它们始终表示最新版本。但是通配符因此是危险的，因为它们可能导致将来使用不兼容的包来破坏代码。

在编写一本每月都会发布新预览版本的书时，这是值得冒险的，您不希望像我在 2021 年所做的那样，继续更新包引用，如以下标记所示：

```
<PackageReference
  Include="Microsoft.EntityFrameworkCore.Sqlite" 
  Version="6.0.0-preview.*" /> 
```

如果您使用`dotnet add package`命令或 Visual Studio 的**Manage NuGet Packages**，则默认情况下它将使用包的最新特定版本。但如果您从博客文章中复制并粘贴配置，或者自己手动添加引用，则可能会包含通配符限定符。

以下依赖关系是 NuGet 包引用的示例，这些引用是*不*固定的，因此除非您知道其含义，否则应避免使用：

```
<PackageReference Include="System.Net.Http" Version="4.1.0-*" />
<PackageReference Include="Newtonsoft.Json" Version="12.0.3-beta1" /> 
```

**良好实践**：Microsoft 保证，如果您将依赖项修复为特定版本的.NET 附带的内容，例如 6.0.0，那么这些包将一起工作。几乎总是修复您的依赖关系。

## 为 NuGet 打包库

现在，让我们对您之前创建的`SharedLibrary`项目进行打包：

1.  在`SharedLibrary`项目中，将`Class1.cs`文件重命名为`StringExtensions.cs`。
2.  Modify its contents to provide some useful extension methods for validating various text values using regular expressions, as shown in the following code:

    ```
    using System.Text.RegularExpressions;
    namespace Packt.Shared
    {
      public static class StringExtensions
      {
        public static bool IsValidXmlTag(this string input)
        {
          return Regex.IsMatch(input,
            @"^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$");
        }
        public static bool IsValidPassword(this string input)
        {
          // minimum of eight valid characters
          return Regex.IsMatch(input, "^[a-zA-Z0-9_-]{8,}$");
        }
        public static bool IsValidHex(this string input)
        {
          // three or six valid hex number characters
          return Regex.IsMatch(input,
            "^#?([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$");
        }
      }
    } 
    ```

    您将在*第 8 章**中学习如何编写正则表达式，使用常见的.NET 类型*。

3.  In `SharedLibrary.csproj`, modify its contents, as shown highlighted in the following markup, and note the following:
    *   `PackageId`必须是全局唯一的，因此如果要将此 NuGet 包发布到[中，则必须使用其他值 https://www.nuget.org/](https://www.nuget.org/) 供他人参考和下载的公共提要。
    *   `PackageLicenseExpression`必须是来自以下链接的值：[https://spdx.org/licenses/](https://spdx.org/licenses/) 或者您可以指定自定义许可证。
    *   所有其他元素都是不言自明的：

    ```
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
        <TargetFramework>netstandard2.0</TargetFramework>
     **<GeneratePackageOnBuild>****true****</GeneratePackageOnBuild>**
     **<PackageId>Packt.CSdotnet.SharedLibrary</PackageId>**
     **<PackageVersion>****6.0.0.0****</PackageVersion>**
     **<Title>C****# 10 and .NET 6 Shared Library</Title>**
     **<Authors>Mark J Price</Authors>**
     **<PackageLicenseExpression>**
     **MS-PL**
     **</PackageLicenseExpression>**
     **<PackageProjectUrl>**
     **https:****//github.com/markjprice/cs10dotnet6**
     **</PackageProjectUrl>**
     **<PackageIcon>packt-csdotnet-sharedlibrary.png</PackageIcon>**
     **<PackageRequireLicenseAcceptance>****true****</PackageRequireLicenseAcceptance>**
     **<PackageReleaseNotes>**
     **Example shared library packaged** **for** **NuGet.**
     **</PackageReleaseNotes>**
     **<Description>**
     **Three extension methods to validate a** **string****value****.**
     **</Description>**
     **<Copyright>**
     **Copyright ©** **2016-2021** **Packt Publishing Limited**
     **</Copyright>**
     **<PackageTags>****string** **extensions packt csharp dotnet</PackageTags>**
      </PropertyGroup>
     **<ItemGroup>**
     **<None Include=****"packt-csdotnet-sharedlibrary.png"****>**
     **<Pack>True</Pack>**
     **<PackagePath></PackagePath>**
     **</None>**
     **</ItemGroup>**
    </Project> 
    ```

    **良好实践**：为`true`或`false`值的配置属性值不能有任何空格，因此`<PackageRequireLicenseAcceptance>`条目不能有回车符和缩进，如前面的标记所示。

4.  从以下链接下载图标文件并保存在`SharedLibrary`文件夹中：[https://github.com/markjprice/cs10dotnet6/blob/main/vs4win/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png](https://github.com/markjprice/cs10dotnet6/blob/main/vs4win/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png) 。
5.  构建发布程序集：
    1.  在 Visual Studio 中，选择工具栏中的**发布**，然后导航到**构建****构建共享库**。
    2.  在 Visual Studio 代码中，在**终端**中输入`dotnet build -c Release`
6.  如果我们没有在项目文件中将`<GeneratePackageOnBuild>`设置为`true`，那么我们必须使用以下附加步骤手动创建 NuGet 包：
    1.  在 Visual Studio 中，导航到**构建****包共享库**。
    2.  在 Visual Studio 代码中，在**终端**中输入`dotnet pack -c Release`。

### 将包发布到公共 NuGet 源

如果您希望所有人都能下载并使用您的 NuGet 软件包，那么您必须将其上传到公共 NuGet 订阅源，如 Microsoft 的：

1.  启动您喜爱的浏览器并导航到以下链接：[https://www.nuget.org/packages/manage/upload](https://www.nuget.org/packages/manage/upload) 。
2.  您需要使用 Microsoft 帐户登录[https://www.nuget.org/](https://www.nuget.org/) 如果你想上传一个 NuGet 包供其他开发者作为依赖包参考。
3.  点击**浏览。。。**并选择通过生成 NuGet 包创建的`.nupkg`文件。文件夹路径应为`Code\Chapter07\SharedLibrary\bin\Release`，文件名为`Packt.CSdotnet.SharedLibrary.6.0.0.nupkg`。
4.  确认您在`SharedLibrary.csproj`文件中输入的信息已正确填写，然后点击**提交**。
5.  等待几秒钟，您将看到一条成功消息，显示您的包已上传，如*图 7.8*：

    <figure class="mediaobject">![](../Images/B17442_07_08.png)</figure>

    所示

图 7.8:NuGet 包上载消息

**良好实践**：如果出现错误，请查看项目文件中的错误，或在[阅读更多关于`PackageReference`格式的信息 https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets](https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets) 。

### 将包发布到私有 NuGet 源

组织可以托管自己的私有 NuGet 提要。对于许多开发团队来说，这是一种共享工作的便捷方式。您可以通过以下链接阅读更多内容：

[https://docs.microsoft.com/en-us/nuget/hosting-packages/overview](https://docs.microsoft.com/en-us/nuget/hosting-packages/overview)

## 使用工具探索 NuGet 包

Uno 平台创建了一个名为**NuGet Package Explorer**的便捷工具，用于打开和查看 NuGet软件包的更多详细信息。除了作为一个网站，它还可以作为一个跨平台应用程序安装。让我们看看它能做什么：

1.  启动您喜爱的浏览器并导航到以下链接：[https://nuget.info](https://nuget.info) 。
2.  在搜索框中，输入`Packt.CSdotnet.SharedLibrary`。
3.  选择**Mark J Price**发布的**v6.0.0**包，点击**打开**按钮。
4.  在**目录**部分，展开**lib**文件夹和**netstandard2.0**文件夹。
5.  Select **SharedLibrary.dll**, and note the details, as shown in *Figure 7.9*:

    <figure class="mediaobject">![](../Images/B17442_07_09.png)</figure>

    图 7.9：从 Uno 平台使用 NuGet package Explorer 探索我的包

6.  如果您希望将来在本地使用此工具，请单击浏览器中的“安装”按钮。
7.  关闭浏览器。

并非所有浏览器都支持这样安装 web 应用。我推荐 Chrome 用于测试和开发。

## 测试类库包

您将现在通过在`AssembliesAndNamespaces`项目中引用您上传的包来测试它：

1.  在`AssembliesAndNamespaces`项目中，添加对您（或我的）包的引用，如以下标记中突出显示的：

    ```
    <ItemGroup>
      <PackageReference Include="newtonsoft.json" Version="13.0.1" />
     **<PackageReference Include=****"packt.csdotnet.sharedlibrary"**
     **Version=****"6.0.0"** **/>**
    </ItemGroup> 
    ```

2.  构建控制台应用程序。
3.  在`Program.cs`中，导入`Packt.Shared`名称空间。
4.  在`Program.cs`中，提示用户输入一些`string`值，然后使用包中的扩展方法进行验证，如下代码所示：

    ```
    Write("Enter a color value in hex: "); 
    string? hex = ReadLine(); // or "00ffc8"
    WriteLine("Is {0} a valid color value? {1}",
      arg0: hex, arg1: hex.IsValidHex());
    Write("Enter a XML element: "); 
    string? xmlTag = ReadLine(); // or "<h1 class=\"<\" />"
    WriteLine("Is {0} a valid XML element? {1}", 
      arg0: xmlTag, arg1: xmlTag.IsValidXmlTag());
    Write("Enter a password: "); 
    string? password = ReadLine(); // or "secretsauce"
    WriteLine("Is {0} a valid password? {1}",
      arg0: password, arg1: password.IsValidPassword()); 
    ```

5.  运行代码，根据提示输入一些值，并查看结果，如以下输出所示：

    ```
    Enter a color value in hex: 00ffc8 
    Is 00ffc8 a valid color value? True
    Enter an XML element: <h1 class="<" />
    Is <h1 class="<" /> a valid XML element? False 
    Enter a password: secretsauce
    Is secretsauce a valid password? True 
    ```

# 从.NET Framework 移植到现代.NET

如果你是一名现有的.NET Framework 开发人员，那么你可能有一些你认为应该移植到现代.NET 的现有应用程序。但是你应该仔细考虑移植是否适合你的代码，因为有时候，最好的选择不是端口。

例如，您可能有一个在.NET Framework 4.8 上运行的复杂网站项目，但只被少数用户访问。如果它能在最小的硬件上工作并处理访问者流量，那么花几个月的时间将其移植到.NET6 可能是浪费时间。但是，如果网站目前需要许多昂贵的 Windows 服务器，那么如果您可以迁移到更少、更便宜的 Linux 服务器，那么移植成本最终可能会得到回报。

## 你能帮我转转吗？

现代.NET 在 Windows、macOS 和 Linux 上对以下类型的应用程序具有强大的支持，因此它们是很好的移植候选者：

*   **ASP.NET 核心 MVC**网站。
*   **ASP.NET 核心 Web API**Web 服务（REST/HTTP）。
*   **ASP.NET 核心信令**服务。
*   **控制台应用**命令行界面。

现代.NET 在 Windows 上对以下类型的应用程序提供了良好的支持，因此它们是移植的潜在候选对象：

*   **Windows 窗体**应用程序。
*   Po.T0\. Windows 演示基金会 T1 T1（Po.T2。WPF OutT3）应用程序。

现代.NET 在跨平台桌面和移动设备上对以下类型的应用程序提供了良好的支持：

*   **Xamarin**适用于移动 iOS 和 Android 的应用程序。
*   **.NET 毛伊岛**用于桌面 Windows 和 macOS，或移动 iOS 和 Android。

现代.NET 不支持以下类型的旧版 Microsoft 项目：

*   **ASP.NET Web 表单**网站。这些可能最好使用**ASP.NET 核心剃须刀页面**或**Blazor**重新实现。
*   To.T0\. Windows 通信基金会 T1 T1（Po.T2A.WCF OutT3）服务（但有一个开源项目名为 AuthT4，CordeWCF，Ty5），您可以根据需求使用它。使用**ASP.NET 核心 gRPC**服务可以更好地重新实现 WCF 服务。
*   **Silverlight**应用。最好使用**.NET 毛伊岛**重新实现这些功能。

Silverlight 和 ASP.NET Web 表单应用程序将永远无法移植到现代.NET，但现有的 Windows 表单和 WPF 应用程序可以移植到 Windows 上的.NET，以受益于新的 API 和更快的性能。

现有.NET Framework 上的旧 ASP.NET MVC web 应用程序和 ASP.NET web API web 服务可以移植到现代.NET，然后托管在 Windows、Linux 或 macOS 上。

## 你应该去港口吗？

即使你*可以*端口，*应该*你吗？您获得了哪些好处？一些常见的好处包括：

*   **针对网站和 web 服务部署到 Linux、Docker 或 Kubernetes**：这些操作系统作为网站和 web 服务平台是轻量级且经济高效的，尤其是与成本更高的 Windows 服务器相比。
*   **删除对 IIS 和 System.Web.dll 的依赖**：即使您继续部署到 Windows Server，ASP.NET Core 也可以托管在轻量级、更高性能的 Kestrel（或其他）Web 服务器上。
*   **命令行工具**：开发人员和管理员用于自动化任务的工具通常构建为控制台应用程序。跨平台运行单个工具的能力非常有用。

## .NET 框架与现代.NET 的区别

有三个关键区别，如下表所示：

<colgroup><col> <col></colgroup> 
| 现代.NET | .NET 框架 |
| 作为 NuGet 软件包分发，因此每个应用程序都可以部署自己需要的.NET 版本的应用程序本地副本。 | 作为系统范围的共享程序集分发（确切地说，在全局程序集缓存（GAC）中）。 |
| 分为小的、分层的组件，因此可以执行最小的部署。 | 单一、整体部署。 |
| 删除旧技术（如 ASP.NET Web 窗体）和非跨平台功能（如 AppDomains、.NET 远程处理和二进制序列化）。 | 除了一些与现代.NET 中类似的技术，如 ASP.NET 核心 MVC，它还保留了一些旧技术，如 ASP.NET Web 表单。 |

## 了解.NET 可移植性分析器

Microsoft 有一个有用的工具，您可以对现有应用程序运行该工具，以生成用于移植的报告。您可以通过以下链接观看该工具的演示：[https://channel9.msdn.com/Blogs/Seth-Juarez/A-Brief-Look-at-the-NET-Portability-Analyzer](https://channel9.msdn.com/Blogs/Seth-Juarez/A-Brief-Look-at-the-NET-Portability-Analyzer) 。

## 了解.NET 升级助手

Microsoft 将旧项目升级到现代.NET 的最新工具是.NET 升级助手。

为了我的日常工作，我为一家名为 Optimizely 的公司工作。我们有一个基于.NET Framework 的企业级数字体验平台（DXP），包括一个内容管理系统（CMS），用于构建数字商务网站。Microsoft 需要一个具有挑战性的迁移项目来设计和测试.NET 升级助手，因此我们与他们合作构建了一个很棒的工具。

目前，它支持以下.NET Framework 项目类型，稍后将添加更多：

*   ASP.NETMVC
*   Windows 窗体
*   WPF
*   控制台应用程序
*   类库

作为全局`dotnet`工具安装，如下命令所示：

```
dotnet tool install -g upgrade-assistant 
```

您可以通过以下链接了解有关此工具以及如何使用它的更多信息：

[https://docs.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview](https://docs.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview)

## 使用非.NET 标准库

大多数现有的 NuGet 软件包都可以与现代的.NET 一起使用，即使它们不是按照.NET 标准或像.NET 6 这样的现代版本编译的。如果你发现一个包没有官方支持.NET 标准，正如它的[nuget.org](https://www.nuget.org/)网页所示，你不必放弃。你应该试试看它是否管用。

例如，方言软件有限责任公司创建了一套用于处理矩阵的自定义集合，记录在以下链接中：

[https://www.nuget.org/packages/DialectSoftware.Collections.Matrix/](https://www.nuget.org/packages/DialectSoftware.Collections.Matrix/)

该软件包上次更新是在 2013 年，比.NET Core 或.NET 6 早了很久，因此该软件包是为.NET Framework 构建的。只要像这样的程序集包只使用.NET 标准中可用的 API，它就可以在现代.NET 项目中使用。

让我们尝试使用它，看看它是否有效：

1.  在`AssembliesAndNamespaces`项目中，为方言软件的包添加一个包引用，如下标记所示：

    ```
    <PackageReference
      Include="dialectsoftware.collections.matrix"
      Version="1.0.0" /> 
    ```

2.  构建`AssembliesAndNamespaces`项目以恢复包。
3.  在`Program.cs`中，添加语句以导入`DialectSoftware.Collections`和`DialectSoftware.Collections.Generics`命名空间。
4.  添加语句创建`Axis`和`Matrix<T>`的实例，用值填充并输出，如下代码所示：

    ```
    Axis x = new("x", 0, 10, 1);
    Axis y = new("y", 0, 4, 1);
    Matrix<long> matrix = new(new[] { x, y });
    for (int i = 0; i < matrix.Axes[0].Points.Length; i++)
    {
      matrix.Axes[0].Points[i].Label = "x" + i.ToString();
    }
    for (int i = 0; i < matrix.Axes[1].Points.Length; i++)
    {
      matrix.Axes[1].Points[i].Label = "y" + i.ToString();
    }
    foreach (long[] c in matrix)
    {
      matrix[c] = c[0] + c[1];
    }
    foreach (long[] c in matrix)
    {
      WriteLine("{0},{1} ({2},{3}) = {4}",
        matrix.Axes[0].Points[c[0]].Label,
        matrix.Axes[1].Points[c[1]].Label,
        c[0], c[1], matrix[c]);
    } 
    ```

5.  运行代码，记录警告消息和结果，如以下输出所示：

    ```
    warning NU1701: Package 'DialectSoftware.Collections.Matrix
    1.0.0' was restored using '.NETFramework,Version=v4.6.1,
    .NETFramework,Version=v4.6.2, .NETFramework,Version=v4.7,
    .NETFramework,Version=v4.7.1, .NETFramework,Version=v4.7.2,
    .NETFramework,Version=v4.8' instead of the project target framework 'net6.0'. This package may not be fully compatible with your project.
    x0,y0 (0,0) = 0
    x0,y1 (0,1) = 1
    x0,y2 (0,2) = 2
    x0,y3 (0,3) = 3
    ... 
    ```

即使这个包是在.NET 6 出现之前创建的，编译器和运行时也无法知道它是否会工作，因此会显示警告，因为它只调用.NET 标准兼容的 API，所以它可以工作。

# 使用预览功能

对于 Microsoft 来说，提供一些跨.NET 许多部分（如运行时、语言编译器和 API 库）具有交叉影响的新功能是一个挑战。这是典型的鸡和蛋的问题。你先做什么？

从实用的角度来看，这意味着尽管微软可能已经完成了一项功能所需的大部分工作，但整个工作可能要到现在每年发布一次的.NET 版本的很晚才能准备好，在“野外”进行适当的测试为时已晚

因此，从.NET6 开始，微软将在**通用**（**GA**版本）中加入预览功能。开发人员可以选择这些预览功能，并向 Microsoft 提供反馈。在以后的 GA 版本中，它们可以为每个人启用。

**良好实践**：生产代码中不支持预览功能。预览功能在最终发布之前可能会有突破性的更改。启用预览功能的风险由您自行承担。

## 需要预览功能

`[RequiresPreviewFeatures]`属性用于指示使用的程序集、类型或成员，因此需要有关预览功能的警告。然后，代码分析器扫描此程序集，在需要时生成警告。如果代码未使用任何预览功能，则不会看到任何警告。如果您使用任何预览功能，那么您的代码应该警告代码的使用者您使用了预览功能。

## 启用预览功能

让我们看一下在.NET 6 中提供的预览功能的一个示例，即使用静态抽象方法定义接口的能力：

1.  使用您首选的代码编辑器将名为`UsingPreviewFeatures`的新控制台应用程序添加到`Chapter07`解决方案/工作区。
2.  在 Visual Studio 代码中，选择`UsingPreviewFeatures`作为活动的 OmniSharp 项目。当您看到弹出警告消息说所需资产丢失时，单击**是**添加它们。
3.  在项目文件中，添加一个元素以启用预览功能和一个元素以启用预览语言功能，如以下标记中突出显示的：

    ```
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net6.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
     **<EnablePreviewFeatures>****true****</EnablePreviewFeatures>**
     **<LangVersion>preview</LangVersion>**
      </PropertyGroup>
    </Project> 
    ```

4.  在`Program.cs`中，删除注释并静态导入`Console`类。
5.  添加语句定义一个带有静态抽象方法的接口，一个实现它的类，然后在顶级程序中调用该方法，如下代码所示：

    ```
    using static System.Console;
    Doer.DoSomething();
    public interface IWithStaticAbstract
    {
      static abstract void DoSomething();
    }
    public class Doer : IWithStaticAbstract
    {
      public static void DoSomething()
      {
        WriteLine("I am an implementation of a static abstract method.");
      }
    } 
    ```

6.  运行 console 应用程序并注意其输出是否正确。

## 一般数学

为什么微软增加了定义静态抽象方法的能力？它们有什么用处？

很长一段时间以来，开发人员一直要求 Microsoft 能够在泛型类型上使用诸如*之类的运算符。这将使开发人员能够定义数学方法来对任何泛型类型执行添加、平均等操作，而不必为他们想要支持的所有数字类型创建几十个重载方法。支持接口中的静态抽象方法是支持通用数学的一个基本特性。

如果您感兴趣，可以通过以下链接了解更多信息：

[https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/](https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/)

# 实践与探索

通过回答一些问题，进行一些实际操作，并对本章的主题进行深入研究，来测试您的知识和理解。

## 练习 7.1–测试您的知识

回答以下问题：

1.  命名空间和程序集之间有什么区别？
2.  您如何引用`.csproj`文件中的另一个项目？
3.  像 ILSpy 这样的工具有什么好处？
4.  C#`float`别名代表哪种.NET 类型？
5.  将应用程序从.NET Framework 移植到.NET 6 时，在移植之前应该运行什么工具，以及可以运行什么工具来执行大部分移植工作？
6.  .NET 应用程序的框架依赖部署和自包含部署之间有什么区别？
7.  什么是 RID？
8.  `dotnet pack`和`dotnet publish`命令之间有什么区别？
9.  为.NET Framework 编写的哪些类型的应用程序可以移植到现代.NET？
10.  您可以将为.NET Framework 编写的包与现代.NET 一起使用吗？

## 练习 7.2–探索主题

使用下页上的链接了解有关本章所涵盖主题的更多详细信息：

[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-7---了解和包装网络类型](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-7---understanding-and-packaging-net-types)

## 练习 7.3–探索 PowerShell

PowerShell 是 Microsoft 的脚本语言，用于在每个操作系统上自动执行任务。Microsoft 建议使用带有 PowerShell 扩展的 Visual Studio 代码来编写 PowerShell 脚本。

由于 PowerShell 是它自己的扩展语言，因此本书中没有篇幅介绍它。相反，我在 books GitHub 存储库上创建了一些补充页面，向您介绍一些关键概念并展示一些示例：

[https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell](https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell)

# 总结

在本章中，我们回顾了到.NET 6 的历程，探讨了程序集和名称空间之间的关系，看到了发布应用程序以分发到多个操作系统的选项，打包并分发了类库，并讨论了移植现有.NET Framework 代码基的选项。

在下一章中，您将了解现代.NET 中包含的一些常见基类库类型。