# 12

# 使用多任务处理提高性能和可扩展性

本章介绍允许同时执行多个操作，以提高所构建应用程序的性能、可伸缩性和用户生产效率。

在本章中，我们将介绍以下主题：

*   了解流程、线程和任务
*   监控性能和资源使用情况
*   异步运行任务
*   同步对共享资源的访问
*   理解`async`和`await`

# 了解流程、线程和任务

一个**进程**，其中一个例子是我们创建的每个控制台应用程序，它拥有内存和分配给它的线程等资源。

一个**线程**逐个语句执行您的代码。默认情况下，每个进程只有一个线程，当我们需要同时执行多个任务时，可能会导致问题。线程还负责跟踪当前经过身份验证的用户以及当前语言和区域应遵循的任何国际化规则。

Windows 和大多数其他现代操作系统使用**抢占式多任务**，模拟任务的并行执行。它在线程之间分配处理器时间，为每个线程依次分配**时间片**。当前线程的时间片结束时将挂起。处理器然后允许另一个线程运行一个时间片。

当 Windows 从一个线程切换到另一个线程时，它会保存该线程的上下文，并在线程队列中重新加载先前保存的下一个线程的上下文。这需要时间和资源来完成。

作为开发人员，如果您有少量复杂的工作，并且希望完全控制它们，那么您可以创建和管理单个`Thread`实例。如果您有一个主线程和多个小任务可以在后台执行，那么您可以使用`ThreadPool`类将指向作为方法实现的那些任务的委托实例添加到队列中，它们将自动分配给线程池中的线程。

在本章中，我们将使用`Task`类型在更高的抽象级别上管理线程。

线程可能必须竞争并等待对共享资源的访问，例如变量、文件和数据库对象。您将在本章后面的操作中看到用于管理此功能的类型。

根据任务的不同，将执行任务的线程（工作线程）数量增加一倍并不会使完成该任务所需的秒数减半。事实上，它可以延长任务的持续时间。

**良好实践**：永远不要认为更多的线程会提高性能！在没有多个线程的基线代码实现上运行性能测试，然后再次在有多个线程的代码实现上运行性能测试。您还应该在尽可能靠近生产环境的暂存环境中执行性能测试。

# 监控性能和资源使用情况

在我们能够改进任何代码的性能之前，我们需要能够监控其速度和效率，以记录基线，然后我们可以根据基线来衡量改进。

## 评估类型的效率

场景中最好使用哪种类型？为了回答这个问题，我们需要仔细考虑我们所说的“最好”的含义，通过这一点，我们应该考虑以下因素：

*   **功能**：这可以通过检查类型是否提供您需要的功能来决定。
*   **内存大小**：这可以由类型占用的内存字节数决定。
*   **性能**：这取决于类型的速度。
*   **未来需求**：这取决于需求和可维护性的变化。

将有场景，例如存储数字时，其中多个类型具有相同的功能，因此我们需要考虑内存和性能来做出选择。

如果我们需要存储数百万个数字，那么最好使用的类型是需要最少字节内存的类型。但是，如果我们只需要存储一些数字，但我们需要对它们执行大量计算，那么最好使用的类型是在特定 CPU 上运行最快的类型。

您已经看到了`sizeof()`函数的使用，它显示了一个类型的单个实例在内存中使用的字节数。当我们在更复杂的数据结构（如数组和列表）中存储大量值时，我们需要一种更好的方法来测量内存使用情况。

您可以在网上和书中阅读大量建议，但要确定代码的最佳类型，唯一的方法是自己比较这些类型。

在下一节中，您将学习如何编写代码来监控使用不同类型时的实际内存需求和性能。

今天，`short`变量可能是最好的选择，但使用`int`变量可能是更好的选择，尽管它在内存中占用的空间是原来的两倍。这是因为我们将来可能需要存储更大范围的值。

开发人员经常忘记一个重要指标：维护。这是衡量另一个程序员在理解和修改您的代码时需要付出多少努力的标准。如果您做出了一个不明显的类型选择，但没有用有用的注释解释该选择，那么它可能会让后来出现的需要修复 bug 或添加功能的程序员感到困惑。

## 使用诊断监控性能和内存

`System.Diagnostics`名称空间有许多有用的类型用于监视代码。我们要看的第一个有用的类型是`Stopwatch`类型：

1.  使用您首选的编码工具创建名为`Chapter12`的新工作区/解决方案。
2.  添加类库项目，如以下列表中所定义：
    1.  项目模板：**类库**/`classlib`
    2.  工作区/解决方案文件和文件夹：`Chapter12`
    3.  项目文件和文件夹：`MonitoringLib`
3.  添加控制台应用程序项目，如以下列表中所定义：
    1.  项目模板：**控制台应用**/`console`
    2.  工作区/解决方案文件和文件夹：`Chapter12`
    3.  项目文件和文件夹：`MonitoringApp`
4.  在 Visual Studio 中，将解决方案的启动项目设置为当前选择。
5.  在 Visual Studio 代码中，选择`MonitoringApp`作为活动的 OmniSharp 项目。
6.  在`MonitoringLib`项目中，将`Class1.cs`文件重命名为`Recorder.cs`。
7.  在`MonitoringApp`项目中，向`MonitoringLib`类库添加一个项目引用，如下标记所示：

    ```cs
    <ItemGroup> 
      <ProjectReference
        Include="..\MonitoringLib\MonitoringLib.csproj" />
    </ItemGroup> 
    ```

8.  建设`MonitoringApp`项目。

### 秒表和进程类型的有用成员

`Stopwatch`类型有一些有用的成员，如下表所示：

<colgroup><col> <col></colgroup> 
| 成员 | 描述 |
| `Restart`方法 | 这会将经过的时间重置为零，然后启动计时器。 |
| `Stop`方法 | 这会停止计时器。 |
| `Elapsed`财产 | 这是以`TimeSpan`格式存储的经过时间（例如，小时：分钟：秒） |
| `ElapsedMilliseconds`财产 | 这是存储为`Int64`值的已用时间（以毫秒为单位）。 |

`Process`类型有一些有用的成员，如下表所示：

<colgroup><col> <col></colgroup> 
| 成员 | 描述 |
| `VirtualMemorySize64` | 这将显示为进程分配的虚拟内存量（以字节为单位）。 |
| `WorkingSet64` | 这将显示为进程分配的物理内存量（以字节为单位）。 |

### 实现记录器类

我们将创建一个`Recorder`类，该类可以轻松监控时间和内存资源的使用情况。为了实现我们的`Recorder`类，我们将使用`Stopwatch`和`Process`类：

1.  In `Recorder.cs`, change its contents to use a `Stopwatch` instance to record timings and the current `Process` instance to record memory usage, as shown in the following code:

    ```cs
    using System.Diagnostics; // Stopwatch
    using static System.Console;
    using static System.Diagnostics.Process; // GetCurrentProcess()
    namespace Packt.Shared;
    public static class Recorder
    {
      private static Stopwatch timer = new();
      private static long bytesPhysicalBefore = 0;
      private static long bytesVirtualBefore = 0;
      public static void Start()
      {
        // force two garbage collections to release memory that is
        // no longer referenced but has not been released yet
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        // store the current physical and virtual memory use 
        bytesPhysicalBefore = GetCurrentProcess().WorkingSet64; 
        bytesVirtualBefore = GetCurrentProcess().VirtualMemorySize64; 
        timer.Restart();
      }
      public static void Stop()
      {
        timer.Stop();
        long bytesPhysicalAfter =
          GetCurrentProcess().WorkingSet64;
        long bytesVirtualAfter =
          GetCurrentProcess().VirtualMemorySize64;
        WriteLine("{0:N0} physical bytes used.",
          bytesPhysicalAfter - bytesPhysicalBefore);
        WriteLine("{0:N0} virtual bytes used.",
          bytesVirtualAfter - bytesVirtualBefore);
        WriteLine("{0} time span ellapsed.", timer.Elapsed);
        WriteLine("{0:N0} total milliseconds ellapsed.",
          timer.ElapsedMilliseconds);
      }
    } 
    ```

    `Recorder`类的`Start`方法使用`GC`类型（垃圾收集器）来确保在记录使用的内存量之前，收集当前分配但未引用的内存。这是一种高级技术，几乎不应该在应用程序代码中使用。

2.  在`Program.cs`中，编写语句启动和停止`Recorder`，同时生成 10000 个整数数组，如下代码所示：

    ```cs
    using Packt.Shared; // Recorder
    using static System.Console;
    WriteLine("Processing. Please wait...");
    Recorder.Start();
    // simulate a process that requires some memory resources...
    int[] largeArrayOfInts = Enumerable.Range(
      start: 1, count: 10_000).ToArray();
    // ...and takes some time to complete
    Thread.Sleep(new Random().Next(5, 10) * 1000);
    Recorder.Stop(); 
    ```

3.  运行代码并查看结果，如以下输出所示：

    ```cs
    Processing. Please wait...
    655,360 physical bytes used.
    536,576 virtual bytes used.
    00:00:09.0038702 time span ellapsed.
    9,003 total milliseconds ellapsed. 
    ```

请记住，经过的时间随机介于 5 到 10 秒之间。你的结果会有所不同。例如，在我的 Mac mini M1 上运行时，使用了更少的物理内存，但使用了更多的虚拟内存，如下输出所示：

```cs
Processing. Please wait...
294,912 physical bytes used.
10,485,760 virtual bytes used.
00:00:06.0074221 time span ellapsed.
6,007 total milliseconds ellapsed. 
```

## 测量处理字符串的效率

现在您已经了解了如何使用`Stopwatch`和`Process`类型来监控代码，我们将使用类型来评估处理`string`变量的最佳方式。

1.  在`Program.cs`中，通过将前面的语句包装成多行注释字符`/* */`来注释掉它们。
2.  编写语句来创建一个包含 50000 个`int`变量的数组，然后使用`string`和`StringBuilder`类将它们用逗号作为分隔符连接起来，如下代码所示：

    ```cs
    int[] numbers = Enumerable.Range(
      start: 1, count: 50_000).ToArray();
    WriteLine("Using string with +");
    Recorder.Start();
    string s = string.Empty; // i.e. ""
    for (int i = 0; i < numbers.Length; i++)
    {
      s += numbers[i] + ", ";
    }
    Recorder.Stop();
    WriteLine("Using StringBuilder");
    Recorder.Start();
    System.Text.StringBuilder builder = new();
    for (int i = 0; i < numbers.Length; i++)
    {
      builder.Append(numbers[i]);
      builder.Append(", ");
    }
    Recorder.Stop(); 
    ```

3.  运行代码并查看结果，如以下输出所示：

    ```cs
    Using string with +
    14,883,072 physical bytes used.
    3,609,728 virtual bytes used.
    00:00:01.6220879 time span ellapsed.
    1,622 total milliseconds ellapsed.
    Using StringBuilder
    12,288 physical bytes used.
    0 virtual bytes used.
    00:00:00.0006038 time span ellapsed.
    0 total milliseconds ellapsed. 
    ```

我们可以将结果总结如下：

*   带有`+`操作符的`string`类使用了约 14MB 的物理内存，1.5MB 的虚拟内存，耗时 1.5 秒。
*   `StringBuilder`类使用了 12KB 的物理内存，零虚拟内存，时间不到 1 毫秒。

在这种情况下，`StringBuilder`在连接文本时速度快 1000 多倍，内存效率高约 10000 倍！这是因为`string`串联在每次使用时都会创建一个新的`string`，因为`string`值是不可变的，因此可以安全地将它们合并以供重用。`StringBuilder`在添加更多字符时创建单个缓冲区。

**良好实践**：避免在回路内使用`String.Concat`方法或`+`操作符。用`StringBuilder`代替。

既然您已经了解了如何使用.NET 中内置的类型来度量代码的性能和资源效率，那么让我们了解一个提供更复杂性能度量的 NuGet 包。

## 使用 Benchmark.NET 监控性能和内存

微软在其博客文章中使用了一个流行的针对.NET 的基准测试 NuGet 软件包，该软件包是关于性能改进的，因此.NET 开发人员了解其工作原理并将其用于自己的性能测试是一件好事。让我们看看如何使用它来比较`string`串联和`StringBuilder`之间的性能：

1.  使用您首选的代码编辑器向名为`Benchmarking`的`Chapter12`解决方案/工作区添加新的控制台应用程序。
2.  在 Visual Studio 代码中，选择`Benchmarking`作为活动的 OmniSharp 项目。
3.  向 Benchmark.NET 添加一个包引用，记住您可以找到最新版本并使用它，而不是我使用的版本，如以下标记所示：

    ```cs
    <ItemGroup>
      <PackageReference Include="BenchmarkDotNet" Version="0.13.1" />
    </ItemGroup> 
    ```

4.  构建项目以恢复包。
5.  在`Program.cs`中，删除已有语句，然后导入运行基准测试的名称空间，如下代码所示：

    ```cs
    using BenchmarkDotNet.Running; 
    ```

6.  添加名为`StringBenchmarks.cs`的新类文件。
7.  在`StringBenchmarks.cs`中，添加语句来定义一个类，该类包含您想要运行的每个基准测试的方法，在本例中，两个方法都使用`string`连接或`StringBuilder`将二十个数字以逗号分隔，如下代码所示：

    ```cs
    using BenchmarkDotNet.Attributes; // [Benchmark]
    public class StringBenchmarks
    {
      int[] numbers;
      public StringBenchmarks()
      {
        numbers = Enumerable.Range(
          start: 1, count: 20).ToArray();
      }
      [Benchmark(Baseline = true)]
      public string StringConcatenationTest()
      {
        string s = string.Empty; // e.g. ""
        for (int i = 0; i < numbers.Length; i++)
        {
          s += numbers[i] + ", ";
        }
        return s;
      }
      [Benchmark]
      public string StringBuilderTest()
      {
        System.Text.StringBuilder builder = new();
        for (int i = 0; i < numbers.Length; i++)
        {
          builder.Append(numbers[i]);
          builder.Append(", ");
        }
        return builder.ToString();
      }
    } 
    ```

8.  在`Program.cs`中，添加一条语句来运行基准测试，如下代码所示：

    ```cs
    BenchmarkRunner.Run<StringBenchmarks>(); 
    ```

9.  在 VisualStudio 2022 的工具栏中，将**解决方案配置**设置为**发布**。
10.  在 VisualStudio 代码中，在终端中使用`dotnet run --configuration Release`命令。
11.  Run the console app and note the results, including some artifacts like report files, and the most important, a summary table that shows that `string` concatenation took a mean of 412.990 ns and `StringBuilder` took a mean of 275.082 ns, as shown in the following partial output and in *Figure 12.1*:

    ```cs
    // ***** BenchmarkRunner: Finish  *****
    // * Export *
      BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.csv
      BenchmarkDotNet.Artifacts\results\StringBenchmarks-report-github.md
      BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.html
    // * Detailed results *
    StringBenchmarks.StringConcatenationTest: DefaultJob
    Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
    Mean = 412.990 ns, StdErr = 2.353 ns (0.57%), N = 46, StdDev = 15.957 ns
    Min = 373.636 ns, Q1 = 413.341 ns, Median = 417.665 ns, Q3 = 420.775 ns, Max = 434.504 ns
    IQR = 7.433 ns, LowerFence = 402.191 ns, UpperFence = 431.925 ns
    ConfidenceInterval = [404.708 ns; 421.273 ns] (CI 99.9%), Margin = 8.282 ns (2.01% of Mean)
    Skewness = -1.51, Kurtosis = 4.09, MValue = 2
    -------------------- Histogram --------------------
    [370.520 ns ; 382.211 ns) | @@@@@@
    [382.211 ns ; 394.583 ns) | @
    [394.583 ns ; 411.300 ns) | @@
    [411.300 ns ; 422.990 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    [422.990 ns ; 436.095 ns) | @@@@@
    ---------------------------------------------------
    StringBenchmarks.StringBuilderTest: DefaultJob
    Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
    Mean = 275.082 ns, StdErr = 0.558 ns (0.20%), N = 15, StdDev = 2.163 ns
    Min = 271.059 ns, Q1 = 274.495 ns, Median = 275.403 ns, Q3 = 276.553 ns, Max = 278.030 ns
    IQR = 2.058 ns, LowerFence = 271.409 ns, UpperFence = 279.639 ns
    ConfidenceInterval = [272.770 ns; 277.394 ns] (CI 99.9%), Margin = 2.312 ns (0.84% of Mean)
    Skewness = -0.69, Kurtosis = 2.2, MValue = 2
    -------------------- Histogram --------------------
    [269.908 ns ; 278.682 ns) | @@@@@@@@@@@@@@@
    ---------------------------------------------------
    // * Summary *
    BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1165 (21H1/May2021Update)
    11th Gen Intel Core i7-1165G7 2.80GHz, 1 CPU, 8 logical and 4 physical cores
    .NET SDK=6.0.100
      [Host]     : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT
      DefaultJob : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT
    |                  Method |     Mean |   Error |   StdDev | Ratio | RatioSD |
    |------------------------ |---------:|--------:|---------:|------:|--------:|
    | StringConcatenationTest | 413.0 ns | 8.28 ns | 15.96 ns |  1.00 |    0.00 |
    |       StringBuilderTest | 275.1 ns | 2.31 ns |  2.16 ns |  0.69 |    0.04 |
    // * Hints *
    Outliers
      StringBenchmarks.StringConcatenationTest: Default -> 7 outliers were removed, 14 outliers were detected (376.78 ns..391.88 ns, 440.79 ns..506.41 ns)
      StringBenchmarks.StringBuilderTest: Default       -> 2 outliers were detected (274.68 ns, 274.69 ns)
    // * Legends *
      Mean    : Arithmetic mean of all measurements
      Error   : Half of 99.9% confidence interval
      StdDev  : Standard deviation of all measurements
      Ratio   : Mean of the ratio distribution ([Current]/[Baseline])
      RatioSD : Standard deviation of the ratio distribution ([Current]/[Baseline])
      1 ns    : 1 Nanosecond (0.000000001 sec)
    // ***** BenchmarkRunner: End *****
    // ** Remained 0 benchmark(s) to run **
    Run time: 00:01:13 (73.35 sec), executed benchmarks: 2
    Global total time: 00:01:29 (89.71 sec), executed benchmarks: 2
    // * Artifacts cleanup * 
    ```

    <figure class="mediaobject">![](../Images/B17442_13_02.png)</figure>

    图 12.1：汇总表显示，与字符串连接相比，StringBuilder 花费了 69%的时间

`Outliers`部分特别有趣，因为它表明`string`串联不仅比`StringBuilder`慢，而且在所需时间上也更不一致。当然，你的结果会有所不同。

现在您已经看到了两种衡量性能的方法。现在，让我们看看如何异步运行任务以潜在地提高性能。

# 异步运行任务

为了理解如何同时运行多个任务，我们将创建一个控制台应用程序，它需要执行三种方法。

需要执行三个方法：第一个需要 3 秒，第二个需要 2 秒，第三个需要 1 秒。为了模拟这种工作，我们可以使用`Thread`类通知当前线程在指定的毫秒数内进入睡眠状态。

## 同步运行多个操作

在我们使任务同时运行之前，我们将同步运行它们，即一个接一个地运行。

1.  使用您首选的代码编辑器向名为`WorkingWithTasks`的`Chapter12`解决方案/工作区添加新的控制台应用程序。
2.  在 Visual Studio 代码中，选择`WorkingWithTasks`作为活动的 OmniSharp 项目。
3.  在`Program.cs`中，导入命名空间以使用秒表（隐式导入用于处理线程和任务的命名空间），然后静态导入`Console`，如下代码所示：

    ```cs
    using System.Diagnostics; // Stopwatch
    using static System.Console; 
    ```

4.  在`Program.cs`的底部，创建一个方法来输出当前线程的信息，如下代码所示：

    ```cs
    static void OutputThreadInfo()
    {
      Thread t = Thread.CurrentThread;
      WriteLine(
        "Thread Id: {0}, Priority: {1}, Background: {2}, Name: {3}",
        t.ManagedThreadId, t.Priority,
        t.IsBackground, t.Name ?? "null");
    } 
    ```

5.  在`Program.cs`的底部增加三种模拟工作的方法，如下代码所示：

    ```cs
    static void MethodA()
    {
      WriteLine("Starting Method A...");
      OutputThreadInfo();
      Thread.Sleep(3000); // simulate three seconds of work
      WriteLine("Finished Method A.");
    }
    static void MethodB()
    {
      WriteLine("Starting Method B...");
      OutputThreadInfo();
      Thread.Sleep(2000); // simulate two seconds of work
      WriteLine("Finished Method B.");
    }
    static void MethodC()
    {
      WriteLine("Starting Method C...");
      OutputThreadInfo();
      Thread.Sleep(1000); // simulate one second of work
      WriteLine("Finished Method C.");
    } 
    ```

6.  在`Program.cs`顶部，添加语句调用该方法输出线程信息，定义并启动秒表，调用三个模拟工作方法，然后输出经过的毫秒数，如下代码所示：

    ```cs
    OutputThreadInfo();
    Stopwatch timer = Stopwatch.StartNew();
    WriteLine("Running methods synchronously on one thread."); 
    MethodA();
    MethodB();
    MethodC();
    WriteLine($"{timer.ElapsedMilliseconds:#,##0}ms elapsed."); 
    ```

7.  运行代码，查看结果，注意当只有一个未命名的前台线程进行工作时，所需的总时间刚刚超过 6 秒，如以下输出所示：

    ```cs
    Thread Id: 1, Priority: Normal, Background: False, Name: null
    Running methods synchronously on one thread.
    Starting Method A...
    Thread Id: 1, Priority: Normal, Background: False, Name: null
    Finished Method A.
    Starting Method B...
    Thread Id: 1, Priority: Normal, Background: False, Name: null
    Finished Method B.
    Starting Method C...
    Thread Id: 1, Priority: Normal, Background: False, Name: null
    Finished Method C.
    6,017ms elapsed. 
    ```

## 使用任务异步运行多个操作

`Thread`类从.NET 的第一个版本开始就可用，可以用来创建新线程和管理它们，但直接使用它可能会很棘手。

.NET Framework 4.0 在 2010 年引入了`Task`类，它是一个围绕线程的包装器，可以更轻松地创建和管理。管理任务中包装的多个线程将允许我们的代码同时执行，也就是异步执行。

每个`Task`都有一个`Status`属性和一个`CreationOptions`属性。一个`Task`有一个`ContinueWith`方法，可以用`TaskContinuationOptions`枚举定制，也可以用`TaskFactory`类管理。

### 开始任务

我们将研究使用`Task`实例启动方法的三种方法。GitHub 存储库中有讨论利弊的文章链接。每个都有一个稍微不同的语法，但它们都定义了一个`Task`并启动它：

1.  注释掉对三个方法的调用及其关联的控制台消息，并添加语句来创建和启动三个任务，每个方法一个，如以下代码中突出显示的：

    ```cs
    OutputThreadInfo();
    Stopwatch timer = Stopwatch.StartNew();
    **/***
    WriteLine("Running methods synchronously on one thread.");
    MethodA();
    MethodB();
    MethodC();
    ***/**
    **WriteLine(****"Running methods asynchronously on multiple threads."****);** 
    **Task taskA =** **new****(MethodA);**
    **taskA.Start();**
    **Task taskB = Task.Factory.StartNew(MethodB);** 
    **Task taskC = Task.Run(MethodC);**
    WriteLine($"{timer.ElapsedMilliseconds:#,##0}ms elapsed."); 
    ```

2.  运行代码，查看结果，并注意已用毫秒几乎立即出现。这是，因为三个方法中的每一个现在都由线程池中分配的三个新的后台工作线程执行，如以下输出所示：

    ```cs
    Thread Id: 1, Priority: Normal, Background: False, Name: null
    Running methods asynchronously on multiple threads.
    Starting Method A...
    Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    Starting Method C...
    Thread Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    Starting Method B...
    Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    6ms elapsed. 
    ```

控制台应用程序甚至可能在一个或多个任务有机会启动并写入控制台之前结束！

## 等待任务

有时，您需要等待任务完成后再继续。为此，您可以在`Task`实例上使用`Wait`方法，或在任务数组上使用`WaitAll`或`WaitAny`静态方法，如下表所述：

<colgroup><col> <col></colgroup> 
| 方法 | 描述 |
| `t.Wait()` | 这将等待名为`t`的任务实例完成执行。 |
| `Task.WaitAny(Task[])` | 这将等待阵列中的任何任务完成执行。 |
| `Task.WaitAll(Task[])` | 这将等待阵列中的所有任务完成执行。 |

### 对任务使用等待方法

让我们看看如何使用这些等待方法来解决控制台应用程序的问题。

1.  在`Program.cs`中，在创建三个任务之后，在输出经过的时间之前，添加语句，将对这三个任务的引用组合成一个数组并传递给`WaitAll`方法，如下代码所示：

    ```cs
    Task[] tasks = { taskA, taskB, taskC };
    Task.WaitAll(tasks); 
    ```

2.  运行代码并查看结果，注意原始线程在调用`WaitAll`时会暂停，等待三个任务全部完成，然后输出经过的时间，大约 3 秒多一点，如以下输出所示：

    ```cs
    Id: 1, Priority: Normal, Background: False, Name: null
    Running methods asynchronously on multiple threads.
    Starting Method A...
    Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    Starting Method B...
    Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    Starting Method C...
    Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    Finished Method C.
    Finished Method B.
    Finished Method A.
    3,013ms elapsed. 
    ```

这三个新线程同时执行它们的代码，它们可能以任何顺序启动。`MethodC`应该先完成，因为只需要 1 秒，然后是`MethodB`，需要 2 秒，最后是`MethodA`，因为需要 3 秒。

然而，实际使用的 CPU 对结果有很大影响。CPU 为每个进程分配时间片，以允许它们执行线程。您无法控制这些方法何时运行。

## 继续另一项任务

如果这三项任务可以同时执行，那么等待所有任务完成就是我们需要做的全部事情。然而，通常一个任务依赖于另一个任务的输出。为了处理这个场景，我们需要定义**延续任务**。

我们将创建一些方法来模拟对 web 服务的调用，该调用返回一个货币金额，然后需要使用该金额来检索数据库中有多少产品的成本高于该金额。第一个方法返回的结果需要输入到第二个方法的输入中。这次，我们将使用`Random`类为每个方法调用等待 2 到 4 秒的随机间隔来模拟工作，而不是等待固定的时间量。

1.  在`Program.cs`的底部，添加两个模拟调用 web 服务和数据库存储过程的方法，如下代码所示：

    ```cs
    static decimal CallWebService()
    {
      WriteLine("Starting call to web service...");
      OutputThreadInfo();
      Thread.Sleep((new Random()).Next(2000, 4000));
      WriteLine("Finished call to web service.");
      return 89.99M;
    }
    static string CallStoredProcedure(decimal amount)
    {
      WriteLine("Starting call to stored procedure...");
      OutputThreadInfo();
      Thread.Sleep((new Random()).Next(2000, 4000));
      WriteLine("Finished call to stored procedure.");
      return $"12 products cost more than {amount:C}.";
    } 
    ```

2.  用多行注释字符`/* */`将对前三个任务的调用注释掉。保留输出已用毫秒数的语句。
3.  在已有语句之前添加语句，输出总时间，如下代码所示：

    ```cs
    WriteLine("Passing the result of one task as an input into another."); 
    Task<string> taskServiceThenSProc = Task.Factory
      .StartNew(CallWebService) // returns Task<decimal>
      .ContinueWith(previousTask => // returns Task<string>
        CallStoredProcedure(previousTask.Result));
    WriteLine($"Result: {taskServiceThenSProc.Result}"); 
    ```

4.  运行代码并查看结果，如以下输出所示：

    ```cs
    Thread Id: 1, Priority: Normal, Background: False, Name: null
    Passing the result of one task as an input into another.
    Starting call to web service...
    Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    Finished call to web service.
    Starting call to stored procedure...
    Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker
    Finished call to stored procedure.
    Result: 12 products cost more than £89.99.
    5,463ms elapsed. 
    ```

您可能会看到不同的线程运行 web 服务和存储过程调用，如上面的输出（线程 4 和 6），或者同一个线程可能会被重用，因为它不再繁忙。

## 嵌套和子任务

除了定义任务之间的依赖关系外，还可以定义嵌套任务和子任务。**嵌套任务**是在另一个任务中创建的任务。**子任务**是嵌套任务，必须在允许父任务完成之前完成。

让我们探讨一下这些类型的任务是如何工作的：

1.  使用您首选的代码编辑器向名为`NestedAndChildTasks`的`Chapter12`解决方案/工作区添加新的控制台应用程序。
2.  在 Visual Studio 代码中，选择`NestedAndChildTasks`作为活动的 OmniSharp 项目。
3.  在`Program.cs`中删除已有语句，静态导入`Console`，然后添加两个方法，一个启动任务运行另一个，如下代码所示：

    ```cs
    static void OuterMethod()
    {
      WriteLine("Outer method starting...");
      Task innerTask = Task.Factory.StartNew(InnerMethod);
      WriteLine("Outer method finished.");
    }
    static void InnerMethod()
    {
      WriteLine("Inner method starting...");
      Thread.Sleep(2000);
      WriteLine("Inner method finished.");
    } 
    ```

4.  在上述方法中，添加语句启动一个任务，运行外部方法，等待任务完成后再停止，如下代码所示：

    ```cs
    Task outerTask = Task.Factory.StartNew(OuterMethod);
    outerTask.Wait();
    WriteLine("Console app is stopping."); 
    ```

5.  Run the code and view the result, as shown in the following output:

    ```cs
    Outer method starting...
    Inner method starting...
    Outer method finished.
    Console app is stopping. 
    ```

    注意，尽管我们等待外部任务完成，但其内部任务也不必完成。事实上，外部任务可能会在内部任务开始之前完成，控制台应用程序可能会结束！

    要将这些嵌套任务链接为父任务和子任务，必须使用特殊选项。

6.  修改定义内部任务的现有代码，增加`AttachedToParent`的`TaskCreationOption`值，如下代码所示：

    ```cs
    Task innerTask = Task.Factory.StartNew(InnerMethod,
      **TaskCreationOptions.AttachedToParent**); 
    ```

7.  运行代码，查看结果，注意内部任务必须在外部任务完成之前完成，如以下输出所示：

    ```cs
    Outer method starting...
    Inner method starting...
    Outer method finished.
    Inner method finished.
    Console app is stopping. 
    ```

`OuterMethod`可以在`InnerMethod`之前完成，如写入控制台所示，但其任务必须等待，如控制台所示，直到外部和内部任务都完成后才停止。

## 围绕其他对象包装任务

有时您可能有一个想要异步的方法，但返回的结果本身并不是任务。您可以使用下表所示的方法之一，将返回值包装在成功完成的任务中，返回异常，或指示该任务已取消：

<colgroup><col> <col></colgroup> 
| 方法 | 描述 |
| `FromResult<TResult>(TResult)` | 创建一个`Task<TResult>`对象，其`Result`属性为非任务结果，其`Status`属性为`RanToCompletion`。 |
| `FromException<TResult>(Exception)` | 创建一个已完成且带有指定异常的`Task<TResult>`。 |
| `FromCanceled<TResult>(CancellationToken)` | 使用指定的取消令牌创建由于取消而完成的`Task<TResult>`。 |

当您需要执行以下操作时，这些方法非常有用：

*   实现具有异步方法的接口，但实现是同步的。这在网站和服务中很常见。
*   单元测试期间模拟异步实现。

在*第 7 章**打包和分发.NET 类型*中，我们创建了一个类库，其中包含检查有效 XML、密码和十六进制代码的函数。

如果我们想使这些方法符合需要返回`Task<T>`的接口，我们可以使用这些有用的方法，如下代码所示：

```cs
using System.Text.RegularExpressions;
namespace Packt.Shared;
public static class StringExtensions
{
  public static Task<bool> IsValidXmlTagAsync(this string input)
  {
    if (input == null)
    {
      return Task.FromException<bool>(
        new ArgumentNullException("Missing input parameter"));
    }
    if (input.Length == 0)
    {
      return Task.FromException<bool>(
        new ArgumentException("input parameter is empty."));
    }
    return Task.FromResult(Regex.IsMatch(input,
      @"^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$"));
  }
  // other methods
} 
```

如果您需要实现的方法返回一个`Task`（相当于同步方法中的`void`，那么您可以返回一个预定义完成的`Task`对象，如下代码所示：

```cs
public Task DeleteCustomerAsync()
{
  // ...
  return Task.CompletedTask;
} 
```

# 同步对共享资源的访问

当您有多个线程同时执行时，两个或多个线程可能会同时访问同一变量或其他资源，因此可能会导致问题。出于这个原因，你应该仔细考虑 T1.考虑如何使你的代码 Ty2 T2 线程安全。

实现线程安全的最简单机制是使用对象变量作为标志或交通灯，以指示何时应用了共享资源的独占锁。

在威廉·戈尔丁（William Golding）的《蝇王》（Lord of the Flys）中，小猪和拉尔夫发现了一个海螺壳，并用它召集会议。男孩们把“海螺规则”强加给自己，决定除非他们拿着海螺，否则任何人都不能说话。

我喜欢将用于实现线程安全代码的对象变量命名为“conch”。当一个线程具有该 conch 时，其他线程不应访问该 conch 表示的共享资源。注意，我说，*应该*。只有尊重海螺的代码才能启用同步访问。海螺不是锁。

我们将探讨可用于同步访问共享资源的几种类型：

*   `Monitor`：多个线程可以使用的对象，用于检查它们是否应该访问同一进程内的共享资源。
*   `Interlocked`：用于在 CPU 级别操作简单数字类型的对象。

## 从多个线程访问资源

1.  使用您首选的代码编辑器向名为`SynchronizingResourceAccess`的`Chapter12`解决方案/工作区添加新的控制台应用程序。
2.  在 VisualStudio 代码中，选择`SynchronizingResourceAccess`作为活动的 OmniSharp 项目。
3.  在`Program.cs`中，删除已有的语句，然后添加语句以执行以下操作：

    ```cs
    static void MethodA()
    {
      for (int i = 0; i < 5; i++)
      {
        Thread.Sleep(SharedObjects.Random.Next(2000));
        SharedObjects.Message += "A";
        Write(".");
      }
    }
    static void MethodB()
    {
      for (int i = 0; i < 5; i++)
      {
        Thread.Sleep(SharedObjects.Random.Next(2000));
        SharedObjects.Message += "B";
        Write(".");
      }
    }
    static class SharedObjects
    {
      public static Random Random = new();
      public static string? Message; // a shared resource
    } 
    ```

    *   导入诊断类型的名称空间，如`Stopwatch`。
    *   静态导入`Console`类型。
    *   在`Program.cs`的底部，创建一个包含两个字段的静态类：
        *   用于生成随机等待时间的字段。
        *   用于存储消息的`string`字段（这是一个共享资源）。
    *   在类的上方，创建两个静态方法，在循环中将字母 a 或 B 添加到共享的`string`中五次，并为每次迭代等待高达 2 秒的随机间隔：
4.  在名称空间导入之后，编写语句，使用一对任务在单独的线程上执行这两个方法，并等待它们完成，然后输出经过的毫秒数，如以下代码所示：

    ```cs
    WriteLine("Please wait for the tasks to complete.");
    Stopwatch watch = Stopwatch.StartNew();
    Task a = Task.Factory.StartNew(MethodA);
    Task b = Task.Factory.StartNew(MethodB);

    Task.WaitAll(new Task[] { a, b });
    WriteLine();
    WriteLine($"Results: {SharedObjects.Message}.");
    WriteLine($"{watch.ElapsedMilliseconds:N0} elapsed milliseconds."); 
    ```

5.  运行代码并查看结果，如以下输出所示：

    ```cs
    Please wait for the tasks to complete.
    ..........
    Results: BABABAABBA.
    5,753 elapsed milliseconds. 
    ```

这表明两个线程同时修改消息。在实际应用中，这可能是一个问题。但是，我们可以通过对一个 conch 对象应用互斥锁并对这两个方法进行编码来防止并发访问，以便在修改共享资源之前自愿检查 conch，我们将在下一节中执行这一操作。

## 对海螺应用互斥锁

现在，让我们使用一个海螺来确保一次只有一个线程访问共享资源。

1.  在`SharedObjects`中，声明并实例化一个`object`变量作为海螺，如下代码所示：

    ```cs
    public static object Conch = new(); 
    ```

2.  In both `MethodA` and `MethodB`, add a `lock` statement for the conch around the `for` statements, as shown highlighted in the following code:

    ```cs
    **lock** **(SharedObjects.Conch)**
    **{**
      for (int i = 0; i < 5; i++)
      {
        Thread.Sleep(SharedObjects.Random.Next(2000));
        SharedObjects.Message += "A";
        Write(".");
      }
    **}** 
    ```

    **良好实践**：注意，由于检查海螺是自愿的，如果您只在两种方法中的一种方法中使用`lock`语句，那么两种方法都将继续访问共享资源。确保所有访问共享资源的方法都尊重海螺。

3.  运行代码并查看结果，如以下输出所示：

    ```cs
    Please wait for the tasks to complete.
    ..........
    Results: BBBBBAAAAA.
    10,345 elapsed milliseconds. 
    ```

虽然经过的时间更长，但一次只能有一个方法访问共享资源。`MethodA`或`MethodB`可以先启动。一旦一个方法在共享资源上完成了它的工作，那么海螺就会被释放，而另一个方法就有机会完成它的工作。

### 理解 lock 语句

您可能会想知道`lock`语句在“锁定”对象变量时会做什么（提示：它不会锁定对象！），如下代码所示：

```cs
lock (SharedObjects.Conch)
{
  // work with shared resource
} 
```

C#编译器将`lock`语句更改为`try`-`finally`语句，使用`Monitor`类*进入*并*退出*海螺对象（我喜欢将其视为*接受*和*释放*海螺对象），如下代码所示：

```cs
try
{
  Monitor.Enter(SharedObjects.Conch);
  // work with shared resource
}
finally
{
  Monitor.Exit(SharedObjects.Conch);
} 
```

当一个线程对任何对象调用`Monitor.Enter`时，也就是引用类型，它会检查是否有其他线程已经获取了海螺。如果有，线程将等待。如果没有，线程将获取海螺并继续其在共享资源上的工作。一旦线程完成工作，它就会调用`Monitor.Exit`，释放海螺。如果另一个线程正在等待，它现在可以拿着海螺做它的工作。这要求所有线程通过适当地调用`Monitor.Enter`和`Monitor.Exit`来尊重海螺。

### 避免僵局

了解编译器如何将`lock`语句转换为`Monitor`类上的方法调用也很重要，因为使用`lock`语句可能会导致死锁。

当有两个或多个共享资源（每个资源都有一个海螺来监视哪个线程当前正在对每个共享资源进行工作）并且发生以下事件序列时，可能会发生死锁：

*   线程 X“锁定”海螺 A 并开始处理共享资源 A。
*   线程 Y“锁定”海螺 B 并开始处理共享资源 B。
*   在仍然处理资源 A 时，线程 X 还需要处理资源 B，因此它尝试“锁定”海螺 B，但被阻止，因为线程 Y 已经有海螺 B。
*   当仍在处理资源 B 时，线程 Y 也需要处理资源 A，因此它尝试“锁定”海螺 A，但被阻止，因为线程 X 已经有海螺 A。

防止死锁的一种方法是在尝试获取锁时指定超时。为此，必须手动使用`Monitor`类，而不是使用`lock`语句。

1.  修改您的代码，以将`lock`语句替换为尝试超时进入海螺并输出错误然后退出监视器的代码，允许其他线程进入监视器，如以下代码中突出显示的：

    ```cs
    **try**
    **{**
    **if** **(Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(****15****)))**
      {
        for (int i = 0; i < 5; i++)
        {
          Thread.Sleep(SharedObjects.Random.Next(2000));
          SharedObjects.Message += "A";
          Write(".");
        }
      }
    **else**
     **{**
     **WriteLine(****"Method A timed out when entering a monitor on conch."****);**
     **}**
    **}**
    **finally**
    **{**
     **Monitor.Exit(SharedObjects.Conch);**
    **}** 
    ```

2.  运行代码并查看结果，该结果应返回与之前相同的结果（尽管 A 或 B 可以首先抓取海螺），但这是更好的代码，因为它将防止潜在的死锁。

**良好实践**：如果您可以编写代码以避免潜在的死锁，则仅使用`lock`关键字。如果无法避免潜在的死锁，请始终使用`Monitor.TryEnter`方法而不是`lock`，并结合`try`-`finally`语句，这样您就可以提供一个超时，如果死锁发生，其中一个线程将退出死锁。您可以在以下链接上阅读有关良好线程实践的更多信息：[https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)

## 同步事件

在*第 6 章**实现接口和继承类*中，您学习了如何引发和处理事件。但是.NET 事件不是线程安全的，因此您应该避免在多线程场景中使用它们，遵循我前面向您展示的标准事件引发代码。

了解到.NET 事件不是线程安全的后，一些开发人员在添加和删除事件处理程序或引发事件时尝试使用排他锁，如下代码所示：

```cs
// event delegate field
public event EventHandler Shout;
// conch
private object eventLock = new();
// method
public void Poke()
{
  lock (eventLock) // bad idea
  {
    // if something is listening...
    if (Shout != null)
    {
      // ...then call the delegate to raise the event
      Shout(this, EventArgs.Empty);
    }
  }
} 
```

**良好实践**：您可以通过以下链接阅读更多关于事件和线程安全的信息：[https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)

但正如斯蒂芬·克利里（Stephen Cleary）在以下博文中解释的那样，这很复杂：[https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)

## 使 CPU 操作原子化

原子来自希腊语单词**atomos**，意思是*不可分割*。理解在多线程中哪些操作是原子操作非常重要，因为如果它们不是原子操作，那么它们可能会在操作的中途被另一个线程中断。C#增量运算符是原子的吗，如下面的代码所示？

```cs
int x = 3;
x++; // is this an atomic CPU operation? 
```

它不是原子的！递增整数需要以下三个 CPU 操作：

1.  将实例变量中的值加载到寄存器中。
2.  增加值。
3.  将该值存储在实例变量中。

执行前两个步骤后，线程可能会中断。然后，第二个线程可以执行所有三个步骤。当第一个线程恢复执行时，它将覆盖变量中的值，第二个线程执行的递增或递减的效果将丢失！

有一个名为`Interlocked`的类型可以对值类型（如整数和浮点）执行原子操作。让我们看看它的实际行动：

1.  在`SharedObjects`类中声明另一个字段，该字段将计算已发生的操作数，如以下代码所示：

    ```cs
    public static int Counter; // another shared resource 
    ```

2.  在方法 A 和方法 B 中，在`for`语句中，修改`string`值后，添加一条语句来安全地递增计数器，如下代码所示：

    ```cs
    Interlocked.Increment(ref SharedObjects.Counter); 
    ```

3.  输出经过的时间后，将计数器的当前值写入控制台，如下代码所示：

    ```cs
    WriteLine($"{SharedObjects.Counter} string modifications."); 
    ```

4.  运行代码并查看结果，如以下输出中突出显示的：

    ```cs
    Please wait for the tasks to complete.
    ..........
    Results: BBBBBAAAAA.
    13,531 elapsed milliseconds.
    **10 string modifications.** 
    ```

细心的读者会意识到，现有的海螺对象保护海螺锁定的代码块中访问的所有共享资源，因此在这个具体示例中实际上不需要使用`Interlocked`。但如果我们还没有保护另一个共享资源，比如`Message`，那么使用`Interlocked`是必要的。

## 应用其他类型的同步

`Monitor`和`Interlocked`是简单有效的互斥锁，但有时您需要更高级的选项来同步对共享资源的访问，如下表所示：

<colgroup><col> <col></colgroup> 
| 类型 | 描述 |
| `ReaderWriterLock`和`ReaderWriterLockSlim` | 这允许多个线程处于**读取模式**，一个线程处于**写入模式**，具有写入锁的独占所有权，一个具有读取访问权限的线程处于**可升级读取模式**，线程可以从中升级到写模式，而不必放弃对资源的读访问。 |
| `Mutex` | 与`Monitor`类似，这提供了对共享资源的独占访问，但用于进程间同步。 |
| `Semaphore`和`SemaphoreSlim` | 这些限制了通过定义插槽可以同时访问资源或资源池的线程数量。这称为资源节流，而不是资源锁定。 |
| `AutoResetEvent`和`ManualResetEvent` | 事件等待句柄允许线程通过相互发送信号和等待彼此的信号来同步活动。 |

# 理解异步和等待

C#5 在使用`Task`类型时引入了两个 C#关键字。它们在以下方面特别有用：

*   为**图形用户界面**（**GUI**实现多任务。
*   提高 web 应用程序和 web 服务的可扩展性。

在*第 15 章*中*使用模型-视图-控制器模式*构建网站，我们将看到`async`和`await`关键字如何提高网站的可伸缩性。

在*第 19 章*中*使用.NET MAUI*构建移动和桌面应用程序，我们将看到`async`和`await`关键字如何为 GUI 实现多任务处理。

但现在，让我们学习一下为什么引入这两个 C#关键字的理论，然后您将看到它们在实践中的使用。

## 提高控制台应用程序的响应能力

控制台应用程序的一个限制是，您只能在标记为`async`的方法中使用`await`关键字，但 C#7 及更早版本不允许将`Main`方法标记为异步！幸运的是，C#7.1 中引入的新功能是对`Main`中`async`的支持：

1.  使用您首选的代码编辑器向名为`AsyncConsole`的`Chapter12`解决方案/工作区添加新的控制台应用程序。
2.  在 Visual Studio 代码中，选择`AsyncConsole`作为活动的 OmniSharp 项目。
3.  在`Program.cs`中删除已有的语句，静态导入`Console`，如下代码所示：

    ```cs
    using static System.Console; 
    ```

4.  添加语句创建一个`HttpClient`实例，请求苹果主页，输出其字节数，如下代码所示：

    ```cs
    HttpClient client = new();
    HttpResponseMessage response =
      await client.GetAsync("http://www.apple.com/");
    WriteLine("Apple's home page has {0:N0} bytes.",
      response.Content.Headers.ContentLength); 
    ```

5.  构建项目并注意它已成功构建。在.NET 5 及更早版本中，您可能会看到一条错误消息，如以下输出所示：

    ```cs
    Program.cs(14,9): error CS4033: The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'. [/Users/markjprice/Code/ Chapter12/AsyncConsole/AsyncConsole.csproj] 
    ```

6.  您必须将`async`关键字添加到`Main`方法中，并将其返回类型更改为`Task`。在.NET 6 及更高版本中，console 应用程序项目模板使用顶级程序功能为您自动定义具有异步`Main`方法的`Program`类。
7.  运行代码并查看结果，由于 Apple 频繁更改其主页，结果可能有不同的字节数，如以下输出所示：

    ```cs
    Apple's home page has 40,252 bytes. 
    ```

## 提高 GUI 应用程序的响应能力

到目前为止，在本书中，我们只构建了控制台应用程序。当构建 web 应用程序、web 服务以及使用 GUI（如 Windows 桌面和移动应用程序）的应用程序时，程序员的生活变得更加复杂。

其中一个原因是，对于 GUI 应用程序，有一个特殊线程：**用户界面**（**UI**线程。

在 GUI 中工作有两条规则：

*   不要在 UI 线程上执行长时间运行的任务。
*   不要访问除 UI 线程之外的任何线程上的 UI 元素。

为了处理这些规则，程序员过去必须编写复杂的代码，以确保长时间运行的任务由非 UI 线程执行，但一旦完成，任务的结果将安全地传递给 UI 线程以呈现给用户。很快就会变得一团糟！

幸运的是，对于 C#5 和更高版本，您可以使用`async`和`await`。它们允许您继续编写代码，就像它是同步的一样，这样可以保持代码的整洁和易于理解，但在底层，C#编译器创建了一个复杂的状态机并跟踪运行的线程。这有点神奇！

让我们看一个例子。我们将使用 WPF 构建一个 Windows 桌面应用程序，该应用程序使用诸如`SqlConnection`、`SqlCommand`和`SqlDataReader`等低级类型从 SQL Server 数据库中的 Northwind 数据库获取员工。只有在 SQL Server 中存储了 Windows 和 Northwind 数据库时，才能完成此任务。这是本书中唯一一个非跨平台和现代的部分（WPF 已经有 16 年历史了！）。

在这一点上，我们专注于使 GUI 应用程序具有响应性。您将在*第 19 章*中学习 XAML 和构建跨平台 GUI 应用程序，*使用.NET MAUI*构建移动和桌面应用程序。由于本书没有在其他地方介绍 WPF，所以我认为这项任务将是一个很好的机会，至少可以看到使用 WPF 构建的示例应用程序，即使我们没有详细介绍它。

走吧！

1.  如果您正在使用 Visual Studio 2022 for Windows，请将名为`WpfResponsive`的新**WPF 应用程序【C#】**项目添加到`Chapter12`解决方案中。如果您使用的是 Visual Studio 代码，请使用以下命令：`dotnet new wpf`。
2.  在项目文件中，请注意输出类型是 Windows EXE，目标框架是.NET 6 for Windows（它不会在 macOS 和 Linux 等其他平台上运行），并且项目使用 WPF。
3.  将`Microsoft.Data.SqlClient`的包引用添加到项目中，如以下标记中突出显示的：

    ```cs
    <Project Sdk="Microsoft.NET.Sdk">
      <PropertyGroup>
        <OutputType>WinExe</OutputType>
        <TargetFramework>net6.0-windows</TargetFramework>
        <Nullable>enable</Nullable>
        <UseWPF>true</UseWPF>
      </PropertyGroup>
     **<ItemGroup>**
     **<PackageReference Include=****"Microsoft.Data.SqlClient"** **Version=****"3.0.0"** **/>**
     **</ItemGroup>**
    </Project> 
    ```

4.  构建项目以恢复包。
5.  In `MainWindow.xaml`, in the `<Grid>` element, add elements to define two buttons, a text box and a list box, laid out vertically in a stack panel, as shown highlighted in the following markup:

    ```cs
    <Grid>
    **<****StackPanel****>**
    **<****Button****Name****=****"GetEmployeesSyncButton"**
    **Click****=****"GetEmployeesSyncButton_Click"****>**
     **Get Employees Synchronously****</****Button****>**
    **<****Button****Name****=****"GetEmployeesAsyncButton"**
    **Click****=****"GetEmployeesAsyncButton_Click"****>**
     **Get Employees Asynchronously****</****Button****>**
    **<****TextBox****HorizontalAlignment****=****"Stretch"****Text****=****"Type in here"** **/>**
    **<****ListBox****Name****=****"EmployeesListBox"****Height****=****"400"** **/>**
    **</****StackPanel****>**
    </Grid> 
    ```

    Visual Studio 2022 for Windows 对构建 WPF 应用程序具有良好的支持，并将在您编辑代码和 XAML 标记时提供 IntelliSense。VisualStudio 代码没有。

6.  In `MainWindow.xaml.cs`, in the `MainWindow` class, import the `System.Diagnostics` and `Microsoft.Data.SqlClient` namespaces, then create two `string` constants for the database connection string and SQL statement and create event handlers for clicking on the two buttons that use those `string` constants to open a connection to the Northwind database and populate the list box with the ids and names of all employees, as shown in the following code:

    ```cs
    private const string connectionString = 
      "Data Source=.;" +
      "Initial Catalog=Northwind;" +
      "Integrated Security=true;" +
      "MultipleActiveResultSets=true;";
    private const string sql =
      "WAITFOR DELAY '00:00:05';" +
      "SELECT EmployeeId, FirstName, LastName FROM Employees";
    private void GetEmployeesSyncButton_Click(object sender, RoutedEventArgs e)
    {
      Stopwatch timer = Stopwatch.StartNew();
      using (SqlConnection connection = new(connectionString))
      {
        connection.Open();
        SqlCommand command = new(sql, connection);
        SqlDataReader reader = command.ExecuteReader();
        while (reader.Read())
        {
          string employee = string.Format("{0}: {1} {2}",
            reader.GetInt32(0), reader.GetString(1), reader.GetString(2));
          EmployeesListBox.Items.Add(employee);
        }
        reader.Close();
        connection.Close();
      }
      EmployeesListBox.Items.Add($"Sync: {timer.ElapsedMilliseconds:N0}ms");
    }
    private async void GetEmployeesAsyncButton_Click(
      object sender, RoutedEventArgs e)
    {
      Stopwatch timer = Stopwatch.StartNew();
      using (SqlConnection connection = new(connectionString))
      {
        await connection.OpenAsync();
        SqlCommand command = new(sql, connection);
        SqlDataReader reader = await command.ExecuteReaderAsync();
        while (await reader.ReadAsync())
        {
          string employee = string.Format("{0}: {1} {2}",
            await reader.GetFieldValueAsync<int>(0), 
            await reader.GetFieldValueAsync<string>(1), 
            await reader.GetFieldValueAsync<string>(2));
          EmployeesListBox.Items.Add(employee);
        }
        await reader.CloseAsync();
        await connection.CloseAsync();
      }
      EmployeesListBox.Items.Add($"Async: {timer.ElapsedMilliseconds:N0}ms");
    } 
    ```

    注意以下几点：

    *   SQL 语句使用 SQL Server 命令`WAITFOR DELAY`来模拟耗时 5 秒的处理过程。然后从`Employees`表中选择三列。
    *   `GetEmployeesSyncButton_Click`事件处理程序使用同步方法打开连接并获取员工行。
    *   `GetEmployeesAsyncButton_Click`事件处理程序标记为`async`，并使用带有`await`关键字的异步方法打开连接并获取员工行。
    *   两个事件处理程序都使用秒表记录操作所需的毫秒数，并将其添加到列表框中。
7.  在不调试的情况下启动WPF 应用程序。
8.  点击文本框，输入一些文本，注意 GUI 是响应的。
9.  点击**同步获取员工**按钮。
10.  尝试单击文本框，注意 GUI 没有响应。
11.  至少等待五秒钟，直到列表框中充满员工。
12.  单击文本框，输入一些文本，注意 GUI 再次响应。
13.  点击**异步获取员工**按钮。
14.  点击文本框，输入一些文本，注意 GUI 在执行操作时仍然有响应。继续键入，直到列表框中充满员工。
15.  注意这两个操作在计时上的差异。同步获取数据时，UI 被阻止，而异步获取数据时，UI 保持响应。
16.  关闭 WPF 应用程序。

## 提高 web 应用程序和 web 服务的可伸缩性

在构建网站、应用程序和服务时，也可以在服务器端应用`async`和`await`关键字。从客户端应用程序的角度来看，没有任何变化（或者他们可能甚至注意到返回请求所需的时间有一点增加。因此，从单个客户端的角度来看，使用`async`和`await`在服务器端实现多任务会让他们的体验更糟糕！

在服务器端，会创建更多更便宜的工作线程来等待长时间运行的任务完成，这样昂贵的 I/O 线程就可以处理其他客户端请求，而不是被阻塞。这提高了 web 应用程序或服务的总体可伸缩性。可以同时支持更多客户端。

## 支持多任务处理的常见类型

有很多常见的类型都有异步方法，您可以等待，如下表所示：

<colgroup><col> <col></colgroup> 
| 类型 | 方法 |
| `DbContext<T>` | `AddAsync`、`AddRangeAsync`、`FindAsync`和`SaveChangesAsync` |
| `DbSet<T>` | `AddAsync`、`AddRangeAsync`、`ForEachAsync`、`SumAsync`、`ToListAsync`、`ToDictionaryAsync`、`AverageAsync`和`CountAsync` |
| `HttpClient` | `GetAsync`、`PostAsync`、`PutAsync`、`DeleteAsync`、`SendAsync` |
| `StreamReader` | `ReadAsync`、`ReadLineAsync`和`ReadToEndAsync` |
| `StreamWriter` | `WriteAsync`、`WriteLineAsync`和`FlushAsync` |

**良好实践**：当您看到以后缀`Async`结尾的方法时，检查它是否返回`Task`或`Task<T>`。如果是的话，那么您可以使用它来代替同步的非`Async`后缀方法。记住用`await`来称呼它，并用`async`来装饰你的方法。

## 在 catch 块中使用 wait

当`async`和`await`首次在 C#5 中引入时，只能在`try`块中使用`await`关键字，但在`catch`块中不能使用。在 C#6 和更高版本中，现在可以在`try`和`catch`块中使用`await`。

## 使用异步流

在.NET Core 3.0 中，Microsoft 引入了流的异步处理。

您可以通过以下链接完成有关异步流的教程：[https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)

在 C#8.0 和.NET Core 3.0 之前，`await`关键字只适用于返回标量值的任务。NET 标准 2.1 中的异步流支持允许`async`方法返回一系列值。

让我们看一个模拟示例，它以异步流的形式返回三个随机整数。

1.  使用您首选的代码编辑器向名为`AsyncEnumerable`的`Chapter12`解决方案/工作区添加新的控制台应用程序。
2.  在 Visual Studio 代码中，选择`AsyncEnumerable`作为活动的 OmniSharp 项目。
3.  在`Program.cs`中删除已有的语句，静态导入`Console`，如下代码所示：

    ```cs
    using static System.Console; // WriteLine() 
    ```

4.  在`Program.cs`底部，创建一个方法，使用`yield`关键字异步返回三个数字的随机序列，如下代码所示：

    ```cs
    async static IAsyncEnumerable<int> GetNumbersAsync()
    {
      Random r = new();
      // simulate work
      await Task.Delay(r.Next(1500, 3000));
      yield return r.Next(0, 1001);
      await Task.Delay(r.Next(1500, 3000));
      yield return r.Next(0, 1001);
      await Task.Delay(r.Next(1500, 3000));
      yield return r.Next(0, 1001);
    } 
    ```

5.  在`GetNumbersAsync`上方，添加语句枚举数字序列，如下代码所示：

    ```cs
    await foreach (int number in GetNumbersAsync())
    {
      WriteLine($"Number: {number}");
    } 
    ```

6.  运行代码并查看结果，如以下输出所示：

    ```cs
    Number: 509
    Number: 813
    Number: 307 
    ```

# 实践与探索

通过回答一些问题来测试你的知识和理解，进行一些实际操作，并通过更深入的研究来探索本章的主题。

## 练习 12.1–测试您的知识

回答以下问题：

1.  关于流程，您可以了解哪些信息？
2.  `Stopwatch`类的准确度如何？
3.  按照惯例，返回`Task`或`Task<T>`的方法应该使用什么后缀？
4.  要在方法中使用`await`关键字，必须在方法声明中应用哪个关键字？
5.  如何创建子任务？
6.  为什么要避免使用`lock`关键字？
7.  你应该什么时候使用`Interlocked`课程？
8.  什么时候应该使用`Mutex`类而不是`Monitor`类？
9.  在网站或 web 服务中使用`async`和`await`有什么好处？
10.  你能取消一项任务吗？如果是，怎么做？

## 练习 12.2–探索主题

使用以下网页上的链接了解有关本章所涵盖主题的更多详细信息：

[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---使用多任务](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)提高性能和可扩展性

# 总结

在本章中，您不仅学习了如何定义和启动任务，还学习了如何等待一个或多个任务完成，以及如何控制任务完成顺序。您还学习了如何同步访问共享资源以及`async`和`await`背后的魔力。

在接下来的七章中，您将学习如何为.NET 支持的**应用程序模型**、又称**工作负载**创建应用程序，例如网站和服务，以及跨平台桌面和移动应用程序。