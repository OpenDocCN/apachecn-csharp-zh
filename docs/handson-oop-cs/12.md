# 十二、理解设计模式和原则

多年来，软件变得越来越复杂。现在，软件不仅用于数学计算或简单的**创建、读取、更新和删除** ( **CRUD** )操作:我们正在使用它来执行复杂的任务，例如控制火箭发动机或每天管理大量数据。来自广泛领域的企业已经开始采用软件系统，包括银行、保险公司、研究机构、教育机构和政府机构。对软件的需求越高，越多的人开始从事软件开发。从汇编语言编程开始，出现了过程编程，在引入**面向对象编程时代** ( **OOP** )之前，过程编程仍然是最流行的模型，尽管出现了其他类型的编程，如函数式编程。OOP 帮助开发人员编写了良好的模块化软件，易于维护和扩展。在本章中，我们将讨论成千上万开发人员遵循的一些最重要的设计原则和模式，我们将涵盖以下主题:

*   软件开发中的设计原则
*   软件开发中不同的设计模式
*   创新设计模式
*   行为设计模式
*   结构设计模式
*   **模型-视图-控制器** ( **MVC** )模式

# 设计原则

在开始讨论设计原则之前，让我们思考一下我们所说的**设计原则**在软件开发中的含义。当我们开发软件时，我们首先设计它的架构，然后我们开始编写它的代码。我们希望我们的代码不产生任何错误，或者说如果有错误的话很容易找到。我们还希望代码在我们阅读时易于理解，并且希望它的结构能够在以后需要时进行更改。虽然很难写出尽可能好的代码，但是有经验的计算机科学家已经开发出了软件开发的各种原则。使用这些，开发人员可以编写非常干净的代码。

软件开发人员罗伯特·c·马丁，也被称为鲍勃叔叔，提出了五个软件设计原则。这些原则对开发人员来说是如此有效和有帮助，以至于它们已经成为软件行业的规范。它们统称为固体原理，代表以下不同的定义:

*   **S** 代表**单一责任原则**

*   **O** 代表**开合原理**

*   **L** 代表**利科夫换人原则**

*   **I** 代表**界面分离原理**

*   **D** 代表**依存倒置原则**

让我们逐一讨论这些原则。

# 单一责任原则

"A class should have one, only one reason to change."

——*罗伯特 c .马丁*

这意味着当我们编写一个类时，我们应该以这样一种方式设计它，即它只有一个职责。你应该只需要因为一个原因改变类。如果你有多个理由换班，那就是违反了单一责任原则。

如果一个类有多个职责，并且您对一段代码进行了更改，这可能会破坏另一段代码，因为它们在同一个类中，并且共享一些依赖关系。您的代码可能没有很好地分离。

# 开闭原则

代码需要以这样一种方式编写，即在软件实体中添加新的东西，比如类、模块或函数，是好的，但是不应该允许修改实体本身。这降低了产生 bug 的可能性。

# 利斯科夫替代原则

"Derived types must be completely substitutable for their base types."

——*Barbara liskov*

这个原则规定，当你编写一个类时，如果它是从另一个类派生的，它应该可以被基类替换。否则，您的代码将非常脆弱和耦合。这一原理最早是由芭芭拉·利斯科夫发现的，因此以她的名字命名。

# 界面分离原理

有时候，开发人员会创建包含太多信息的大型接口。许多类可能使用这个接口，但是它们可能不需要其中的所有东西。为了遵循这个原则，这是你应该避免的。这个原则支持小接口而不是大接口，如果需要，一个类可以继承多个实际适用于该类的小接口。

# 依赖倒置原则

"High-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on details. Details should depend upon abstractions"

——*罗伯特 c .马丁*

我们知道，在软件开发中，我们与层一起工作。为了使这些层解耦，我们必须以这样一种方式设计这些层的依赖关系，即这些层应该依赖于抽象，而不是相互依赖。因此，如果您在高级模块或低级模块中更改了某些东西，它不会损害系统。当我们创建这些抽象时，我们必须以不依赖于实现细节的方式设计它们。抽象应该是独立的，实现这些接口或抽象类的类应该依赖于这些抽象。

# 创新设计模式

在面向对象程序设计中，所有的东西都被视为对象，跟踪对象是如何创建和管理的是非常重要的。如果开发人员不太注意这个问题，软件的对象可能会使软件变得脆弱和耦合。适当地维护对象以保持应用易于扩展是很重要的。创造性设计模式是以一种可以避免最常见的对象创建问题的方式来帮助创建对象的模式。

创造性设计模式中存在两个主要概念:

*   封装系统使用的具体类的知识
*   隐藏创建和组合具体类的实例

创造设计模式分为对象创造模式和类创造模式，其中**对象创造模式**处理对象的创造，**类创造模式**处理类的发现。

该行业有五种主要的创新设计模式:

*   抽象工厂模式
*   构建器模式
*   工厂方法模式
*   原型模式
*   单一模式

# 抽象工厂模式

这个模式的定义来自*设计模式:可重用面向对象* *软件*的元素，由“四人帮”提供一个组合来构建相似或依赖对象的家族，而不指定它们的具体类。

这种模式提供的最重要的东西是对象创建的分离或抽象。如果你没有遵循任何模式，当你创建一个对象时，你想到的最简单的事情就是使用`new`关键字，在任何你需要的地方创建一个对象。例如，如果我在我的`Bank`类中需要一个`Person`对象，最简单的方法是使用`Bank`类中的`new`关键字实例化一个`Person`对象。然而，使用这种方法有时会增加软件的复杂性。为了避免这种情况，我们可以使用抽象工厂模式。

抽象工厂模式主要用于对象来自同一个族，或者在某种程度上是相关或从属的情况。想法是创建工厂类来执行对象创建工作。如果一个对象`A`需要另一个对象`B`的实例，对象`A`应该要求对象`B`的工厂创建一个`B`的对象，并将其传递给对象`A`。这样，对象`A`独立于对象`B`的创建。现在，在抽象工厂模式中，还有另一层抽象。工厂类也是抽象的。这意味着对象`A`不会直接调用对象`B`的工厂，而是使用一个抽象。应该有一个机制来决定需要调用哪个`Factory`类。这意味着对象`A`不依赖于另一个对象的任何特定工厂。

# 构建器模式

构建器模式的主要思想是将复杂对象的计划与其模仿分开。在面向对象的软件开发中，我们有时需要创建非常复杂的对象。例如，我们可能创建一个使用其他对象的对象，而其他对象又使用其他对象。当您只需要该对象来执行另一种工作时，创建或实例化这种对象可能会很困难。这也可能使代码更加复杂，降低可读性。

让我们考虑一个例子。想象你正在做一些汉堡，其中一些是鸡肉汉堡，一些是牛肉汉堡。创建鸡肉汉堡对象时，每次创建鸡肉汉堡对象时，都必须创建一个鸡肉汉堡肉饼对象、一个番茄酱对象、一个奶酪对象和一个面包对象，这会导致代码混乱。创建牛肉汉堡对象时，也必须遵循相同的过程。这是处理和创建这些对象的一种非常复杂的方式。

构建器模式为解决这一复杂性提供了一个很好的方法。使用这种模式，我们创建了一个名为`Builder`的类，它的主要任务是创建复杂的对象并返回新创建的对象。对于构建器模式，我们使用另一种类型的类，通常称为`director`类。这个类的任务是调用`Builder`类并从中获取对象。

让我们回到汉堡的例子。我们可以有一个`ChickenBurgerBuilder`班和一个`BeefBurgerBuilder`班。这些将在课堂上设置项目，汉堡肉饼，面包，番茄酱和奶酪。当`BurgerDirector`类想要创建`chicken burger`时，它会调用`ChickenBurgerBuilder`。要创建一个`beef burger`，它会调用`BeefBurgerBuilder`。创建`burger patty`和其他成分的复杂性将由`Builder`类处理。

# 工厂方法模式

工厂方法模式与抽象工厂模式非常相似。不同的是，在工厂方法模式中，工厂层不是抽象的。使用这种模式意味着您将创建一个工厂类来处理实现相同抽象的类的创建。这意味着，如果有一个由许多子类定义的接口，`Factory`类可以根据传递给`Factory`的逻辑创建这些子类中的任何一个。

让我们考虑一个例子。我们将使用工厂方法模式来解决我们在*构建器模式*一节中提到的构建器模式示例中的汉堡创建问题。我们将创建一个`Factory`，称为`BurgerFactory`，它将接受输入，例如`typeOfBurger`(鸡肉或牛肉)。然后，`BurgerFactory`将决定应该创建哪个`Burger`类型的对象。假设我们有一个名为`Burger`的接口，它由`ChickenBurger`和`BeefBurger`实现。这意味着`BurgerFactory`将返回一个`Burger`类型的对象。客户端不知道将创建和返回哪个`Burger`对象。通过使用这种模式，我们将客户端与特定的对象隔离开来，这增加了代码的灵活性。

# 原型模式

当您希望避免使用传统的对象创建机制(如新关键字)创建相同类型或子类型的新类时，可以使用这种设计模式。简单地说，这个模式声明我们应该克隆一个对象，然后将克隆的对象作为另一个新创建的对象来使用。这样，就避免了传统的对象创建方法。

# 单一模式

单一模式是一种非常简单的设计模式。它只涉及在整个应用中创建一个类的一个对象。一个**单例对象**是一个不能有多个实例的对象。每当一段代码需要使用这个单例对象时，它不会创建一个新对象；相反，它将使用已经可用的旧对象。

当您只想处理来自一个来源的一些信息时，这种设计模式是适用的。当我们可能使用单例模式时，最好的例子是在数据库连接字符串中。在应用中，如果使用了多个数据库连接，数据库可能会损坏并导致应用出现异常。在这里，最好将连接字符串作为单例对象，这意味着所有通信只使用一个实例。这减少了差异的可能性。

# 结构设计模式

软件开发中可用的一些设计模式与代码结构有关。这些模式帮助您设计代码，使您能够避免常见的结构问题。在“四人帮”的《设计模式:可重用面向对象软件的要素》一书中，有七种结构设计模式。在本节中，我们将讨论其中的四个，如下所示:

*   适配器模式
*   装饰者模式
*   立面图案
*   代理模式

如果你想了解更多关于其他三个方面的信息，可以看看“四人帮”的书*设计模式:可重用面向对象软件的元素*。起初，开始使用这些模式可能会有点混乱，但是，随着经验的增加，识别哪种模式适合哪种情况会变得更加容易。

# 适配器模式

通常，当我们想到适配器这个词时，我们会想到一个小设备，它可以帮助我们将电子设备插入电源插座，插头上有不同类型的接口。适配器设计模式实际上在软件代码中做了同样的事情。这种设计模式规定，如果一个软件的两个模块想要相互通信，但是一个模块期望的接口与另一个模块具有的接口不同，那么应该使用适配器，而不是改变一个接口来匹配另一个接口。这样做的好处是，在未来，如果您希望您的代码与另一个接口对话，您将不必更改代码，而只需使用另一个适配器。

例如，假设您有一个接口`A`，但是您想要与之对话的代码想要另一个接口`B`。您可以使用将接口`A`转换为接口`B`的适配器，而不是将接口`A`更改为接口`B`。这样，使用接口`A`的代码就不会中断，你就可以和请求接口`B`的代码进行通信了。

# 装饰者模式

装饰器模式允许我们动态地向对象添加新的行为。当这个新行为被添加到一个对象时，它不应该影响已经存在于该对象上的任何其他行为。当您必须在运行时向对象添加新行为时，这种模式提供了一种解决方案。它还消除了仅仅为了给任务添加行为而创建子类的需要。

# 立面图案

有时，如果您有复杂的对象关系，很难将它们全部映射并在代码中使用它们。外观模式声明您应该使用一个中间对象来处理对象关系问题，并给客户端一个简单的接触点。让我们想一个例子:当你去餐馆点一些食物时，你实际上并没有去每个厨师或厨房里的人那里收集食物份额并自己制作食物；你告诉服务员你想要什么食物。你不知道物品会如何准备，也不知道谁来准备。你无法控制食物的制作，你只知道你会得到你想要的东西。在这里，接受订单的人是作为门面工作的。他们接受你的订单，让不同的人准备你要的东西。

假设你点了一个牛肉汉堡。您调用一个`GetBeefBurger()`方法，门面实际上会调用以下内容:

```cs
Bread.GetBread()
Sauce.PutSauceOnBread(Bread)
SliceTomato()
PutTomatoOnBread()
Beef.FryBeefPatty()
PutBeefPattyOnBread()
WrapTheBurger()
ServeTheBurger()
```

前面的方法不是真正的方法。我只想给你一个想法，门面的工作实际上是向客户隐藏复杂性。

# 代理模式

这种模式与我们已经讨论过的其他结构设计模式非常相似。如果一段代码由于某种原因不应该直接调用另一段代码，可以使用代理模式。当一段代码没有调用另一段代码的访问权限时，或者当直接调用一段代码在资源方面很昂贵时，代理模式特别有用。例如，如果我们希望在应用中使用第三方库，但出于安全原因，我们不希望代码直接调用该库，那么我们可能需要使用代理模式。在这种情况下，我们可以创建一个代理，让它与第三方代码通信。

# 行为设计模式

行为设计模式是处理对象之间通信的设计模式。这些设计模式允许您的对象以避免开发人员面临的与对象行为相关的常见问题的方式进行通信。这一类别中有许多模式:

*   责任链模式
*   命令模式
*   解释器模式
*   迭代器模式
*   中介模式
*   纪念品图案

*   观察者模式
*   国家模式
*   战略模式
*   模板方法模式
*   访客模式

然而，在本书中，我们只讨论以下行为设计模式:

*   命令模式
*   观察者模式
*   战略模式

如果你想了解更多，请参考我们前面提到的*设计模式:可重用面向对象软件的元素*一书。

# 命令模式

该模式规定，当一个对象想要通知另一个对象或调用另一个对象的方法时，它应该使用另一个对象，而不是直接这样做。将建立通信的对象称为命令对象。该命令将封装保存要调用的方法、要调用的方法名称和要传递的参数(如果有)的对象。命令模式有助于分离调用方和接收方之间的关系。

# 观察者模式

**观察者模式**是一个问题的解决方案，在这个问题中，许多对象需要知道特定对象何时发生变化，因为它们可能必须更新其末端的数据。一种方法是，所有的对象或观察者应该询问对象或可观察对象，数据是否已经改变。如果数据在可观察的范围内发生了变化，观察者就会做它的工作。然而，如果我们这样做，观察者必须非常频繁地询问可观察到的数据变化，以避免减慢您的应用。这需要大量的资源。

观察者模式说，被观察对象应该知道想要知道主体中数据变化的观察者列表，并在主体中的数据发生变化时通知每个观察者。这可以通过调用观察者的方法来实现。这种模式的一个很好的用法是 C# 中的事件和委托。

# 战略模式

让我们来看看“四人帮”在《设计模式:可重用面向对象软件的元素》一书中对策略模式的定义:

例如，一个方法可以有不同类型的实现，这取决于哪个类在使用它。因此，这个定义意味着我们需要让这些不同的算法实现一个基类或接口，这样它们就属于同一个家族，并且可以被客户端互换使用。定义的最后一部分意味着这种模式将允许客户端使用不同的算法，而不会影响其他客户端。

假设我们有一个类，叫做`Animal`，它有几个共同的属性，比如`eat`、`walk`、`noise`。现在，假设您想添加另一个属性，例如`fly`。你们班大多数动物会飞，但有一些不会。你可以把`Animal`类分成两个不同的类，比如`AnimalWhichCanFly`和`AnimalWhichCantFly`。然而，将这个`Animal`类分成两类可能会使事情过于复杂，因为这些动物也可能有其他不同的属性。因此，您可以不使用继承，而是使用组合，这意味着您可以在`Animal`类中添加一个名为`fly`的属性，并使用它来指示这种行为。

策略模式声明不使用固定类型`fly`作为属性类型，我们应该使用一个接口，比如`IFly`，然后创建实现`IFly`的`subclasses`，并且有不同的算法。然后，我们可以利用多态性，在创建`Animal`类的子类时，在运行时分配特定的子类。

让我们尝试在前面的例子中应用这一点。在`Animal`类中，我们将使用`IFly`而不是使用`Fly`属性，然后实现不同的实现`IFly`的类。例如，我们创建了`CanFly : IFly`和`CannotFly : IFly`类。`CanFly`和`CannotFly`将有不同的`Fly`方法实现。如果我们创建一个实现`Animal`类的`Dog`类，我们将把`Fly`属性设置为`CannotFly`类。如果我们创建一个`Bird`类，我们将创建一个`CanFly`的实例，并将其分配给`Fly`属性。通过应用这种模式，我们实现了一个不太复杂的对象结构和容易改变的算法。

# MVC 模式

MVC 模式是业界最流行的设计模式之一。你可能已经听说过了，即使你对这个行业还很陌生。这种模式在 web 开发中被大量使用。许多流行的网络开发框架使用这种设计模式。这里给出了一些使用 MVC 模式的流行框架:

*   **c# :**ASP.NET MVC Web 框架
*   **Java:** Spring 框架
*   **PHP:** Laravel 框架，Codeigniter 框架
*   **Ruby:** Rails 框架

MVC 设计模式规定我们应该将一个 web 应用分成三个部分:

*   模型
*   视角
*   控制器

**模型**是保存数据模型或对象的部分，将用于数据库事务。**视图**是指应用的前端，用户或客户查看。最后，**控制器**是处理应用所有业务逻辑的部分。所有的逻辑和决策部分都将在控制器中。

MVC 模式的好处是您的应用是解耦的。您的视图独立于业务逻辑，业务逻辑独立于数据源。这样，您可以轻松地更改应用的一部分，而不会影响应用的其他部分。

# 摘要

软件开发很有趣，因为它一直在变化。有很多方法可以让你开发、设计或编码一些东西。这些都不能被归类为最佳方式，因为您的代码可能需要根据情况进行更改。然而，因为软件开发是一种工程，所以有各种各样的规则会让你的软件更强大、更可靠。软件设计原则和设计模式就是这类规则的例子。了解这些概念并将其应用到您自己的情况中，将使您作为开发人员的生活更加轻松。

这一章有希望让你了解设计模式的基础知识，并告诉你在哪里可以找到更多的信息。在下一章中，我们将了解一个非常强大和有趣的软件，叫做 Git。Git 是一个版本控制系统，有助于跟踪软件代码。